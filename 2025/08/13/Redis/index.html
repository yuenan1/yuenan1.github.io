<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Redis | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="RedisRedis基础Redis 有什么作用?为什么要用 Redis&#x2F;为什么要用缓存？ Redis 是内存数据库，主要用作缓存和高速数据存储。 为什么要用Redis：内存操作比磁盘快1000倍，支持高并发访问。传统数据库在高并发下容易成为瓶颈，Redis将热点数据放在内存中，大幅提升响应速度。 核心优势：单机支持10万+QPS，支持多种数据结构，支持持久化和集群部署。 使用场景：缓存热">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2025/08/13/Redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RedisRedis基础Redis 有什么作用?为什么要用 Redis&#x2F;为什么要用缓存？ Redis 是内存数据库，主要用作缓存和高速数据存储。 为什么要用Redis：内存操作比磁盘快1000倍，支持高并发访问。传统数据库在高并发下容易成为瓶颈，Redis将热点数据放在内存中，大幅提升响应速度。 核心优势：单机支持10万+QPS，支持多种数据结构，支持持久化和集群部署。 使用场景：缓存热">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-13T01:27:34.000Z">
<meta property="article:modified_time" content="2025-08-13T06:38:19.218Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/13/Redis/" class="article-date">
  <time class="dt-published" datetime="2025-08-13T01:27:34.000Z" itemprop="datePublished">2025-08-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Redis
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h4><p><strong>Redis 有什么作用?为什么要用 Redis&#x2F;为什么要用缓存？</strong></p>
<p>Redis 是内存数据库，主要用作缓存和高速数据存储。</p>
<p>为什么要用Redis：内存操作比磁盘快1000倍，支持高并发访问。传统数据库在高并发下容易成为瓶颈，Redis将热点数据放在内存中，大幅提升响应速度。</p>
<p>核心优势：单机支持10万+QPS，支持多种数据结构，支持持久化和集群部署。</p>
<p>使用场景：缓存热点数据、会话存储、排行榜、计数器、消息队列等。</p>
<p>**Redis 除了做缓存，还能做什么？ **</p>
<p>分布式锁：利用SETNX命令实现，解决分布式系统中的并发控制问题。</p>
<p>限流：通过计数器、滑动窗口等算法实现API限流和流量控制。</p>
<p>消息队列：使用List结构实现简单的发布订阅，但不推荐用于生产环境。</p>
<p><strong>Redis 可以做消息队列么？</strong></p>
<p>Redis 5.0引入的Stream数据结构专门用于消息队列。</p>
<p>Stream优势：支持消息持久化、消费者组、消息确认机制、消息回溯等特性。</p>
<p>相比专业MQ的不足：缺乏消息优先级、死信队列、消息重试策略、集群高可用等企业级功能。</p>
<p>适用场景：简单的消息传递、日志收集、实时通知等轻量级应用。</p>
<p>不推荐场景：高可靠性要求、复杂路由、大规模消息处理的业务场景。</p>
<p>Redis Stream适合对消息可靠性要求不高的简单场景，复杂业务还是建议使用专业的消息队列。</p>
<p>**分布式缓存常见的技术选型方案有哪些？ **</p>
<p>主要方案：Memcached和Redis。</p>
<p>Memcached：纯内存缓存，简单高效，支持多线程，适合简单的key-value存储。</p>
<p>Redis：内存数据库，支持持久化、多种数据结构、集群部署，功能更丰富。</p>
<p>选型考虑：简单缓存用Memcached，需要复杂数据结构和持久化用Redis。</p>
<p>其他选择：Hazelcast、Ignite等JVM内缓存，本地缓存如Caffeine、Guava Cache。</p>
<p>主流选择：Redis因其功能完整性和生态成熟度成为分布式缓存的首选方案。</p>
<h4 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h4><p><strong>Redis 常用的数据结构有哪些？</strong></p>
<p>5种基础类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>3种特殊类型：HyperLogLogs（基数统计）、Bitmap（位存储）、Geospatial（地理位置）。</p>
<p><strong>使用 Redis 统计网站 UV 怎么做？</strong></p>
<p>HyperLogLog：专门基数统计，12KB内存可统计2^64个元素。</p>
<p>实现：PFADD key user_id 添加，PFCOUNT key 统计。</p>
<p>优势：内存占用固定，误差率0.81%，适合大数据量UV统计。</p>
<p>对比：Set存储占用内存大，Hash无法去重。</p>
<p>场景：网站UV、APP日活、商品访问量等去重统计。</p>
<p>**使用 Redis 实现一个排行榜怎么做？ **</p>
<p>Sorted Set：自动按分数排序，完美适合排行榜场景。</p>
<p>实现方式：ZADD key score member 添加成员和分数，ZREVRANGE key 0 9 获取前10名。</p>
<p>核心命令：ZADD添加，ZRANGE正序，ZREVRANGE倒序，ZRANK获取排名，ZSCORE获取分数。</p>
<p>优势：自动排序，支持范围查询，时间复杂度O(logN)。</p>
<p>应用场景：游戏积分榜、商品销量排行、用户活跃度排名等。</p>
<p>扩展功能：支持分数相同按时间排序，支持实时更新排名。</p>
<p>（ZSet &#x3D; Sorted Set，都是有序集合；Set是无序集合）</p>
<h4 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h4><p>**Redis 单线程模型了解吗？ **</p>
<p>单线程：Redis主线程是单线程，负责处理命令和网络IO。</p>
<p>IO多路复用：使用epoll&#x2F;select&#x2F;kqueue监听多个socket连接，单线程可以处理大量并发连接。</p>
<p>事件驱动：将读&#x2F;写事件注册到内核，当事件发生时通知Redis处理。</p>
<p>为什么快：内存操作、单线程无锁竞争、IO多路复用避免线程切换开销。</p>
<p>监听大量连接：IO多路复用程序监听所有socket，有事件时通知主线程处理，单线程可以高效处理成千上万的连接。</p>
<p>优势：避免了多线程的锁竞争和上下文切换，简化了内存管理。</p>
<p>**Redis6.0 之前为什么不使用多线程？ **</p>
<p>单线程优势：编程简单，易于维护，避免了多线程的复杂性。</p>
<p>性能瓶颈不在CPU：Redis主要瓶颈是内存和网络IO，CPU利用率不高。</p>
<p>避免锁竞争：单线程无需加锁，避免了多线程的锁竞争和死锁问题。</p>
<p>内存管理简单：单线程环境下内存分配和回收更简单，减少了内存碎片。</p>
<p>IO多路复用足够：单线程配合IO多路复用已经能处理大量并发连接。</p>
<p>权衡考虑：多线程带来的复杂性超过了性能提升，得不偿失。</p>
<p>**Redis6.0 之后为何引入了多线程？ **</p>
<p>网络IO瓶颈：随着网络带宽提升，单线程处理网络读写成为性能瓶颈。</p>
<p>多线程优化：引入多线程专门处理网络IO，主线程仍负责命令执行。</p>
<p>架构设计：主线程处理命令，多个IO线程处理网络读写，避免网络IO阻塞主线程。</p>
<p>性能提升：多线程网络IO显著提升吞吐量，特别是在高并发网络场景下。</p>
<p>保持兼容：命令执行仍为单线程，保证数据一致性和简单性。</p>
<p>实际效果：网络IO密集型场景下性能提升明显，CPU密集型场景提升有限。</p>
<h4 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h4><p>**Redis 给缓存数据设置过期时间有啥用？ **</p>
<p>内存管理：防止缓存数据无限增长导致内存溢出。</p>
<p>数据时效性：自动清理过期数据，保证缓存数据有效性。</p>
<p>成本控制：避免存储无用历史数据，节省内存成本。</p>
<p>缓存更新：过期后自动重新加载最新数据，保持数据新鲜度。</p>
<p>系统稳定性：防止内存耗尽导致Redis崩溃。</p>
<p><strong>Redis 是如何判断数据是否过期的呢？</strong></p>
<p>过期字典：Redis维护一个过期字典（hash表），存储key和过期时间的映射关系。</p>
<p>过期时间存储：EXPIRE key seconds 设置过期时间，Redis将key和过期时间戳存入过期字典。</p>
<p>过期检查：每次访问key时，Redis检查过期字典中是否存在该key，如果存在且时间已过期则删除。</p>
<p>内存优化：过期字典只存储有过期时间的key，节省内存空间。</p>
<p>**过期的数据的删除策略了解么？ **</p>
<p>惰性删除：访问key时才检查是否过期，过期则删除。对CPU友好，但过期key可能长期占用内存。</p>
<p>定期删除：Redis定期随机抽取部分过期key进行检查删除。对内存友好，但增加CPU开销。</p>
<p>混合策略：Redis采用定期删除+惰性删除的组合方式。</p>
<p>**Redis 内存淘汰机制了解么？ **</p>
<p>6种淘汰策略：noeviction（不淘汰）、allkeys-lru（所有key的LRU）、volatile-lru（过期key的LRU）、allkeys-random（随机淘汰）、volatile-random（过期key随机淘汰）、volatile-ttl（过期key按TTL淘汰）。</p>
<p>LRU算法：最近最少使用的key优先被淘汰，通过近似LRU实现。</p>
<p>配置方式：通过maxmemory-policy设置淘汰策略。</p>
<p>热点数据保证：使用LRU策略，自动淘汰访问频率低的key，保留热点数据。</p>
<p>内存限制：设置maxmemory限制Redis最大内存使用量。</p>
<p>实际应用：生产环境常用allkeys-lru，在内存不足时淘汰最少使用的key。</p>
<h4 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h4><p><strong>怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</strong></p>
<p>持久化机制：Redis提供RDB和AOF两种持久化方式。</p>
<p>RDB：定期将内存数据快照保存到磁盘文件，重启时加载快照恢复数据。</p>
<p>AOF：记录每个写操作命令到日志文件，重启时重放命令恢复数据。</p>
<p>混合持久化：Redis4.0引入，结合RDB和AOF优势，先加载RDB再重放AOF增量命令。</p>
<p>**什么是 RDB 持久化？ **</p>
<p>快照机制：Redis定期将内存数据快照保存到磁盘文件，获得某个时间点的数据副本。</p>
<p>触发方式：自动触发（配置save规则）、手动触发（BGSAVE命令）、shutdown时触发。</p>
<p>执行过程：fork子进程，子进程将内存数据写入临时RDB文件，完成后替换旧文件。</p>
<p>文件格式：二进制格式，文件名通常为dump.rdb。</p>
<p>优势：文件小、恢复快、适合备份和灾难恢复。</p>
<p>劣势：可能丢失最后一次快照后的数据，fork过程可能阻塞主线程。</p>
<p>配置参数：save 900 1（900秒内至少1个key变化则保存）。</p>
<p>**什么是 AOF 持久化？ **</p>
<p>命令记录：Redis将每个写操作命令追加到AOF文件，重启时重放命令恢复数据。</p>
<p>写入流程：命令执行后先写入内存缓冲区server.aof_buf，再根据appendfsync策略同步到磁盘。</p>
<p>fsync策略：always（每命令同步）、everysec（每秒同步）、no（系统控制同步）。</p>
<p>文件重写：AOF文件过大时，Redis重写文件，只保留最终状态，减少文件大小。</p>
<p>优势：数据丢失少，支持实时持久化，文件可读性好。</p>
<p>劣势：文件大、恢复慢、性能开销相对较高。</p>
<p>**Redis 4.0 对于持久化机制做了什么优化？ **</p>
<p>混合持久化：支持RDB和AOF混合使用，结合两者优势。</p>
<p>实现方式：AOF文件前半部分是RDB格式，后半部分是AOF增量命令。</p>
<p>配置开启：通过aof-use-rdb-preamble yes开启混合持久化。</p>
<p>优势：RDB部分恢复快，AOF部分数据完整，既保证恢复速度又保证数据安全。</p>
<h4 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h4><p><strong>如何使用 Redis 事务？</strong></p>
<p>基本命令：MULTI开启事务，EXEC执行事务，DISCARD取消事务，WATCH监控key变化。</p>
<p>事务流程：MULTI后输入多个命令，Redis将命令放入队列，EXEC时批量执行所有命令。</p>
<p>**Redis 事务支持原子性吗？ **</p>
<p>不支持原子性：Redis事务不满足ACID中的原子性要求。</p>
<p>错误处理：事务中某个命令运行时出错，其他命令仍会正常执行，不会回滚。</p>
<p>不支持回滚：Redis没有回滚机制，事务失败后无法自动撤销已执行的命令。</p>
<p><strong>Redis 事务还有什么缺陷？</strong></p>
<p>网络开销：事务中每条命令都需要单独网络交互，浪费网络资源。</p>
<p>设计不合理：明明可以批量传输，却采用逐条发送的方式。</p>
<p>资源浪费：增加了不必要的网络开销和服务器处理负担。</p>
<p>**如何解决 Redis 事务的缺陷？ **</p>
<p>Lua脚本：将多个命令写入Lua脚本，在Redis服务器端执行，避免网络往返。</p>
<p>Redis Functions：Redis7.0引入，类似Lua脚本但更强大，支持函数注册和调用。</p>
<p>原子性保证：Lua脚本和Functions在服务器端原子执行，满足原子性要求。</p>
<p>性能提升：减少网络开销，提升批量操作性能。</p>
<p>实际应用：复杂业务逻辑用Lua脚本，简单批量操作用Pipeline。</p>
<h4 id="Redis-性能优化"><a href="#Redis-性能优化" class="headerlink" title="Redis 性能优化"></a>Redis 性能优化</h4><p>**什么是 bigkey？有什么危害？ **</p>
<p>Bigkey定义：一个key对应的value占用内存过大，通常超过10KB或1MB。</p>
<p>危害：占用过多内存空间，影响Redis整体内存使用效率和性能，大value的读写操作耗时更长，删除时可能长时间阻塞主线程，增加网络开销。</p>
<p>**如何发现 bigkey？ **</p>
<p>Redis自带工具：使用redis-cli –bigkeys参数扫描，自动分析内存占用并输出bigkey统计信息。</p>
<p>RDB文件分析：分析Redis的RDB文件，查看各个key的内存占用情况。</p>
<p><strong>如何避免大量 key 集中过期？</strong></p>
<p>随机过期时间：给key设置随机过期时间，避免同时过期造成性能冲击。</p>
<p>开启lazy-free：启用惰性删除机制，过期key不会立即释放内存，减少集中释放的压力。</p>
<p>**什么是 Redis 内存碎片?为什么会有 Redis 内存碎片? **</p>
<p>内存碎片定义：Redis中不可用的空闲内存，虽然总量足够但无法分配给新数据。</p>
<p>产生原因：频繁的内存分配和释放导致内存空间不连续，大对象删除后留下小空间无法复用。</p>
<p>影响因素：内存分配器策略、数据删除模式、内存对齐要求等。</p>
<p>危害：降低内存利用率，可能导致内存不足错误。</p>
<p>解决方案：开启内存碎片整理、定期重启Redis、优化内存分配策略。</p>
<h4 id="Redis-生产问题"><a href="#Redis-生产问题" class="headerlink" title="Redis 生产问题"></a>Redis 生产问题</h4><p><strong>什么是缓存穿透？怎么解决？</strong></p>
<p>缓存穿透：大量请求的key根本不存在于缓存中，导致请求直接打到数据库上。</p>
<p>缓存无效key：将不存在的key也缓存到Redis中，设置较短的过期时间，避免重复查询数据库。</p>
<p>布隆过滤器：使用布隆过滤器快速判断key是否存在，不存在的key直接返回，减少数据库查询。</p>
<p>**什么是缓存雪崩？怎么解决？ **</p>
<p>缓存雪崩：缓存在同一时间大面积的失效，后面的请求都直接落到数据库上，造成数据库短时间内承受大量请求。</p>
<p>Redis集群：搭建Redis集群避免单点风险，提高服务可用性。</p>
<p>避免集中过期：给key设置随机过期时间，避免同时过期造成性能冲击。</p>
<p>**如何保证缓存和数据库数据的一致性？ **</p>
<p>3 种常见的缓存读写策略</p>
<p>Cache Aside（旁路缓存）：先更新数据库，再删除缓存，读取时先查缓存，缓存没有则查数据库并更新缓存。</p>
<p>Write Through（写透）：应用同时更新缓存和数据库，保证数据一致性。</p>
<p>Write Behind（写回）：先更新缓存，异步批量更新数据库，性能最好但可能丢失数据。</p>
<p>Cache Aside优势：实现简单，性能好，但存在短暂不一致窗口。</p>
<p>Write Through优势：数据一致性最好，但性能较差。</p>
<p>Write Behind优势：性能最好，但数据一致性最差。</p>
<p>总结：根据业务对一致性和性能的要求选择合适的缓存读写策略。</p>
<h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><p><strong>如何保证 Redis 服务高可用？</strong></p>
<p>Redis Sentinel集群：通过Sentinel监控Redis主从节点，自动故障检测和切换，保证服务高可用。</p>
<p>主从复制：配置主从节点，主节点负责写操作，从节点负责读操作，提高读取性能。</p>
<p><strong>Sentinel（哨兵） 有什么作用？</strong></p>
<p>监控功能：实时监控Redis主从节点的运行状态，包括节点存活、网络连接、数据同步等。</p>
<p>故障检测：自动检测Redis节点故障，如主节点宕机、网络分区等异常情况。</p>
<p>自动故障转移：当主节点故障时，自动将从节点提升为主节点，保证服务连续性。</p>
<p>高可用保证：通过Sentinel集群实现Redis服务的高可用，避免单点故障。</p>
<p>总结：Sentinel是Redis高可用的核心组件，负责监控、故障检测和自动故障转移。</p>
<p>**Redis 缓存的数据量太大怎么办? **</p>
<p>Redis Cluster：通过分片机制将数据分散到多个节点，每个节点只存储部分数据，解决单机内存限制问题。</p>
<p>分片策略：使用一致性哈希算法将key分配到不同的分片节点，支持动态扩容和缩容。</p>
<p>节点管理：每个分片包含主从节点，保证数据高可用，支持自动故障转移。</p>
<p>客户端路由：客户端根据key计算分片位置，直接连接对应的Redis节点。</p>
<p>数据迁移：支持在线数据迁移，扩容时数据自动重新分片。</p>
<p>总结：Redis Cluster通过分片机制解决大数据量问题，支持水平扩展，是Redis大规模部署的标准方案。</p>
<p>**Redis Cluster 虚拟槽分区有什么优点？ **</p>
<p>解耦数据和节点：通过虚拟槽将数据和物理节点解耦，数据迁移时只需重新分配槽位，无需移动实际数据。</p>
<p>横向扩展性：新增节点时只需分配部分槽位，支持在线扩容，提升集群处理能力。</p>
<p>容错性提升：节点故障时槽位可以重新分配到其他节点，提高集群的容错能力。</p>
<p>负载均衡：槽位可以均匀分配到各个节点，实现负载均衡，避免单节点压力过大。</p>
<p>维护简单：槽位管理相对简单，集群维护和故障处理更加便捷。</p>
<p>总结：虚拟槽分区通过解耦数据和节点关系，显著提升了Redis Cluster的扩展性和容错性。</p>
<p>**Redis Cluster 中的各个节点是如何实现数据一致性的？ **</p>
<p>Gossip协议：Redis Cluster使用Gossip协议实现节点间信息传播和状态同步，保证集群数据一致性。</p>
<p>信息传播：节点间定期交换集群状态信息，包括节点存活状态、槽位分配、数据同步等。</p>
<p>状态同步：通过Gossip协议快速传播节点故障、槽位变更等信息，所有节点及时更新集群视图。</p>
<p>故障检测：节点间相互监控，通过Gossip协议快速发现故障节点，触发故障转移。</p>
<p>数据同步：主从节点间通过异步复制保持数据同步，Gossip协议确保集群拓扑信息一致。</p>
<p>总结：Redis Cluster通过Gossip协议实现节点间信息传播和状态同步，保证集群数据一致性和高可用性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/13/Redis/" data-id="cme9lxtnh000av4qq5lkl7yac" data-title="Redis" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/08/12/MySOL/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MySOL</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" rel="tag">创建文章</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" style="font-size: 10px;">创建文章</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">工具学习</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E9%87%8D%E7%82%B9/" style="font-size: 15px;">重点</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/13/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2025/08/12/MySOL/">MySOL</a>
          </li>
        
          <li>
            <a href="/2025/08/04/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/2025/08/01/Java/">Java</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>