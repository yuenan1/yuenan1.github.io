<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-二分搜索树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T08:42:25.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">二分搜索树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="二叉搜索树的数据结构"><a href="#二叉搜索树的数据结构" class="headerlink" title="二叉搜索树的数据结构"></a>二叉搜索树的数据结构</h4><p>二叉搜索树（Binary Search Tree），也称二叉查找树。如果你看见有序二叉树（Ordered Binary tree）、排序二叉树（Sorted Binary Tree）那么说的都是一个东西。</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>二叉搜索树也是一颗没有经过调衡的基础性数据结构，在一定概率上它完成有可能退化成链表，也就是从近似O(logn)的时间复杂度退化到O(n)。关于二叉搜索树的平衡解决方案，包括；AVL树、2-3树、红黑树等。</p>
<hr>
<h4 id="二叉搜索树结构实现"><a href="#二叉搜索树结构实现" class="headerlink" title="二叉搜索树结构实现"></a>二叉搜索树结构实现</h4><p>二叉搜索树是整个树结构中最基本的树，同时也是树这个体系中实现起来最容易的数据结构。但之所以要使用基于二叉搜索树之上的其他树结构，主要是因为使用数据结构就是对数据的存放和读取。那么为了提高吞吐效率，则需要尽可能的平衡元素的排序，体现在树上则需要进行一些列操作，所以会有不同的结构树实现。</p>
<ul>
<li><em><strong>树枝定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer value;</span><br><span class="line"><span class="keyword">public</span> Node parent;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于组成一颗树的节点，则需要包括；值和与之关联的三角结构，一个父节点、两个孩子节点。如果是AVL树还需要树高，红黑树还需要染色标记。</li>
</ul>
<ul>
<li><em><strong>插入节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引出待插入元素位置，也就是插入到哪个父元素下</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">search</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (search != <span class="literal">null</span> &amp;&amp; search.value != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = search;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; search.value) &#123;</span><br><span class="line">            search = search.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            search = search.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (parent.value &gt; newNode.value) &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断插入元素时候是否有树根，没有则会把当前节点创建出一颗树根来。</li>
<li>如果当前树是有树根的，则对插入元素与当前树进行一个节点遍历操作，找到元素可以插入的索引位置 parent（挂到这个父节点下）。也就是 search 搜索过程。</li>
<li>最后就是插入元素，通过给插入值创建一个 Node 节点，并绑定它的父元素，以及把新元素挂到索引到的 parent 节点下。</li>
</ul>
<ul>
<li><em><strong>索引节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.value != <span class="literal">null</span> &amp;&amp; node.value != e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; node.value) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值查找的过程，就是对二叉搜索树的遍历，不断的循环节点，按照节点值的左右匹配，找出最终相当的值节点。</li>
</ul>
<ul>
<li><em><strong>删除节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">delNode</span> <span class="operator">=</span> search(e);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == delNode) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> delete(delNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node delNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (delNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为删除的节点，有2个孩子节点，这个时候找到这条分支下，最左侧做小的节点。用它来替换删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">miniNode</span> <span class="operator">=</span> getMiniNode(delNode.right);</span><br><span class="line">        <span class="keyword">if</span> (miniNode.parent != delNode) &#123;</span><br><span class="line">            <span class="comment">// 交换位置，用miniNode右节点，替换miniNode</span></span><br><span class="line">            transplant(miniNode, miniNode.right);</span><br><span class="line">            <span class="comment">// 把miniNode 提升父节点，设置右子树并进行挂链。替代待删节点</span></span><br><span class="line">            miniNode.right = delNode.right;</span><br><span class="line">            miniNode.right.parent = miniNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置，删除节点和miniNode 可打印测试观察；System.out.println(this);</span></span><br><span class="line">        transplant(delNode, miniNode);</span><br><span class="line">        <span class="comment">// 把miniNode 提升到父节点，设置左子树并挂链</span></span><br><span class="line">        miniNode.left = delNode.left;</span><br><span class="line">        miniNode.left.parent = miniNode;</span><br><span class="line">        result = miniNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">transplant</span><span class="params">(Node delNode, Node addNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除元素是左/右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delNode.parent.left == delNode) &#123;</span><br><span class="line">        delNode.parent.left = addNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delNode.parent.right = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addNode) &#123;</span><br><span class="line">        addNode.parent = delNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有右子树</strong></p>
<ul>
<li>直接用右子树替换删除节点</li>
</ul>
<p><strong>只有左子树</strong></p>
<ul>
<li>直接用左子树替换删除节点</li>
</ul>
<p><strong>有两个子树</strong></p>
<ul>
<li>找到右子树中的最小节点（后继节点）</li>
<li>用后继节点替换删除节点</li>
<li>处理后继节点的原位置</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li>
</ul>
<p>​	基本性质：左子树 &lt; 根节点 &lt; 右子树，中序遍历有序，平均O(log n)操作复杂度。</p>
<p>​	核心操作：查找（比较递归）、插入（找位置插入）、删除（三种情况：0&#x2F;1&#x2F;2个子节点）。</p>
<p>​	主要变体：AVL树（自平衡）、红黑树（着色平衡）、B树（多路）、线索二叉树（利用空指针）。核心目标都是避免退化成链表，保持O(log n)性能。</p>
<ul>
<li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li>
</ul>
<p>​	平均情况：插入、删除、查找都是 O(log n)。最坏情况：当树退化成链表时（如顺序插入），所有操作变成 O(n)。关键：平衡二叉树通过自平衡保证最坏情况也是 O(log n)。</p>
<ul>
<li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li>
</ul>
<p>​	核心思路 ：找到右子树中的最小节点（后继节点）来替换被删除节点。</p>
<p>​	具体步骤：1）找到右子树最左侧的最小节点；2）如果最小节点不是右子树根，先将其右子树移植到原位置；3）用最小节点替换被删除节点，重新连接左右子树和父节点关系。</p>
<p>​	原理：右子树最小节点值刚好大于左子树所有值且小于右子树其余值，替换后仍保持BST性质。</p>
<ul>
<li><strong>二叉搜索树的节点都包括了哪些信息</strong></li>
</ul>
<p>​	基本信息：节点值（key&#x2F;data）、左子节点指针、右子节点指针。可选信息：父节点指针（便于向上遍历和删除操作）。扩展信息：节点颜色（红黑树）、平衡因子（AVL树）、子树大小等附加属性。</p>
<p>​	核心结构：<code>&#123;value, left, right, parent&#125;</code>，其中parent可选但常用。</p>
<ul>
<li><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></li>
</ul>
<p>​	核心问题：普通二叉搜索树在最坏情况下会退化成链表，时间复杂度从O(log n)恶化到O(n)。<strong>红黑树优势</strong>：通过着色和旋转机制保证树的近似平衡，确保最坏情况下仍是O(log n)。<strong>HashMap场景</strong>：哈希冲突时链表过长影响性能，红黑树能稳定保证查找效率，避免恶意构造数据导致性能攻击。</p>
<p>​	简单说：红黑树是自平衡的BST，防止极端情况下性能退化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" data-id="cme9lxtnl000gv4qqf08jeyfb" data-title="二分搜索树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字典树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T03:05:39.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/">字典树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="字典树数据结构"><a href="#字典树数据结构" class="headerlink" title="字典树数据结构"></a>字典树数据结构</h4><p>在计算机科学中，字典树(Trie)也被称为”单词查找树“或”数字树“，有时候也被称为基数树或前缀树（因为可以通过前缀的方式进行索引）。—— 它是一种搜索树，一种已排序的数据结构，通常用于存储动态集或键为字符串的关联数组。</p>
<p>与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<hr>
<h4 id="字典树结构实现"><a href="#字典树结构实现" class="headerlink" title="字典树结构实现"></a>字典树结构实现</h4><p>字典树字母的存放有26个，也就是说在实现的过程中，每一个节点的分支都有26个槽位用来存放可能出现的字母组合。同理如果是数字树的话就是10个数字的组合，每个字典树上的节点对应的分支则有10个操作存放可能出现组合的数字。</p>
<ul>
<li><em><strong>树枝节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 形成一个链 */</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] slot = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字母 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：数量 &gt; 0 表示一个单词 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前缀 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：具体的一个单词字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String word;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解释：单词的注释说明 */</span></span><br><span class="line">    <span class="keyword">public</span> String explain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字典的树的节点需要包括此节点内嵌的关联节点，之后是节点的字母、到此字母是否为单词、单词的前缀、单词字符串和当前单词的非必要注释。</li>
</ul>
<ul>
<li><em><strong>插入元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String words, String explain)</span> &#123; <span class="comment">// 插入单词及其解释到字典树</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = words.toCharArray(); <span class="comment">// 将单词转为字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算字符在 slot 数组中的下标（假设都是小写字母）</span></span><br><span class="line">        <span class="keyword">if</span> (root.slot[idx] == <span class="literal">null</span>) &#123; <span class="comment">// 如果对应子节点不存在</span></span><br><span class="line">            root.slot[idx] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>(); <span class="comment">// 创建新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        root.c = c; <span class="comment">// 记录当前字符</span></span><br><span class="line">        root.prefix++; <span class="comment">// 前缀计数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    root.explain = explain; <span class="comment">// 存储单词的解释说明</span></span><br><span class="line">    root.isWord = <span class="literal">true</span>;     <span class="comment">// 标记该节点为单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png" alt="插入元素"></p>
<ul>
<li>insert 方法接收单词和注释信息，并对一个单词按照 char 进行拆分，拆分后则计算出索引位置并以此存放。存放完成后标记单词和附属上单词的注释信息。</li>
</ul>
<ul>
<li><em><strong>索引元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123; <span class="comment">// 查找所有以 prefix 为前缀的单词</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = prefix.toCharArray(); <span class="comment">// 将前缀转为字符数组</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 用于缓存已匹配的前缀</span></span><br><span class="line">    <span class="comment">// 精准匹配：根据前缀逐步查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历前缀的每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算下标</span></span><br><span class="line">        <span class="comment">// 匹配为空，前缀不存在</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; root.slot.length || idx &lt; <span class="number">0</span> || root.slot[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// 没有匹配，返回空列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        cache.append(c); <span class="comment">// 缓存当前字符</span></span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模糊匹配：递归查找所有以 prefix 开头的单词</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">if</span> (root.prefix != <span class="number">0</span>) &#123; <span class="comment">// 如果有以该前缀开头的单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.slot.length; i++) &#123; <span class="comment">// 遍历所有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 计算字符</span></span><br><span class="line">                collect(root.slot[i], String.valueOf(cache) + c, list, <span class="number">15</span>); <span class="comment">// 递归收集单词，最多15个</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt;= <span class="number">15</span>) &#123; <span class="comment">// 达到上限提前返回</span></span><br><span class="line">                    <span class="keyword">return</span> list;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(TrieNode trieNode, String pre, List&lt;String&gt; queue, <span class="type">int</span> resultLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到单词</span></span><br><span class="line">    <span class="keyword">if</span> (trieNode.isWord) &#123; <span class="comment">// 当前节点是单词结尾</span></span><br><span class="line">        trieNode.word = pre; <span class="comment">// 记录完整单词</span></span><br><span class="line">        <span class="comment">// 保存检索到的单词和解释到 queue</span></span><br><span class="line">        queue.add(trieNode.word + <span class="string">&quot; -&gt; &quot;</span> + trieNode.explain);</span><br><span class="line">        <span class="keyword">if</span> (queue.size() &gt;= resultLimit) &#123; <span class="comment">// 达到结果上限</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用，查找所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trieNode.slot.length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i); <span class="comment">// 计算字符</span></span><br><span class="line">        <span class="keyword">if</span> (trieNode.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">            collect(trieNode.slot[i], pre + c, queue, resultLimit); <span class="comment">// 递归收集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E7%B4%A2%E5%BC%95.png" alt="索引"></p>
<ul>
<li>从字典树从检索元素的过程分为2部分，第1部分是根据提供的索引前缀精准匹配到单词信息，第2部分是根据索引前缀的最后一个单词开始，循环递归遍历从当前位置所能关联到的字母直至判断为是单词标记为结束，通过这样的方式把所有匹配动的单词索引出来。</li>
<li>list.size() &gt;&#x3D; 15 是判定索引的最大长度，超过这个数量就停止索引了，毕竟这是一种O(n)时间复杂度的操作，如果加载数十万单词进行匹配，执行速度还是比较耗时的。</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>简述字典树的数据结构</strong></li>
</ul>
<p>​	本质： 树形结构存储字符串，共享公共前缀</p>
<p>​	结构：</p>
<ul>
<li>节点存储字符</li>
<li>路径 &#x3D; 字符串</li>
<li>标记单词结尾</li>
</ul>
<p>​	复杂度： O(字符串长度)</p>
<p>​	用途： 自动补全、前缀匹配、拼写检查</p>
<p>​	优势： 前缀查询快，节省空间</p>
<ul>
<li><strong>叙述你怎么来实现一个字典树</strong></li>
</ul>
<p>​	子节点数组（26个字母）</p>
<p>​	布尔标记（是否单词结尾）</p>
<p>​	插入： 逐字符遍历，不存在就创建节点，最后标记结尾</p>
<p>​	查找：*逐字符遍历，检查路径是否存在且标记为单词</p>
<p>​	前缀查询： 遍历到前缀末尾即可</p>
<p>​	关键点： 字符映射到数组索引，路径即字符串</p>
<ul>
<li><strong>字典树的实际业务场景举例【排序、全文搜索、网络搜索引擎、生物信息】</strong></li>
</ul>
<p>​	字符串字典序排序\关键词索引构建\查询补全\DNA序列匹配</p>
<p>​	<strong>核心优势：</strong> 前缀匹配效率高，特别适合大规模字符串集合的快速检索场景。</p>
<ul>
<li><strong>字典树的存入和检索的时间复杂度</strong></li>
</ul>
<p>​	存入（Insert）：O(m)</p>
<p>​	检索（Search）：O(m)</p>
<p>​	前缀查找：O(p)</p>
<p>​	其中 m 是字符串长度，p 是前缀长度(字典树是典型的<strong>空间换时间</strong>的数据结构，特别适合字符串查找和前缀匹配场景。)</p>
<ul>
<li><strong>还有哪些字典树的实现方式</strong></li>
</ul>
<ol>
<li><p>数组实现</p>
<p>固定大小数组存储子节点</p>
<ul>
<li>优点：O(1)访问速度</li>
<li>缺点：空间浪费</li>
</ul>
</li>
<li><p>哈希表实现</p>
<p>HashMap存储子节点</p>
<ul>
<li>优点：空间高效，支持任意字符集</li>
<li>缺点：哈希冲突影响性能</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" data-id="cme9lxtnr000yv4qqdu6r7dtf" data-title="字典树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%A0%86/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T01:44:53.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%A0%86/">堆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h4><p>在计算机科学中，<strong>堆(heap)</strong> 的实现是一种基于树的特殊的数据结构，它可以在数组上构建出树的结构体，并满足堆的属性；</p>
<ul>
<li><p>最小堆：如果<code>P</code> 是 <code>C</code> 的一个父级节点， 那么 <code>P</code> 的key(或value)应小于或等于 <code>C</code> 的对应值。</p>
</li>
<li><p>最大堆：与最小堆的定义正好相反，最大堆(max heap) , <code>P</code> 的key(或value)大于 <code>C</code> 的对应值。</p>
</li>
</ul>
<hr>
<h4 id="堆的代码实现"><a href="#堆的代码实现" class="headerlink" title="堆的代码实现"></a>堆的代码实现</h4><ul>
<li><em><strong>实现介绍</strong></em></li>
</ul>
<p>堆的实现在 Java API 中主要体现在延迟队列的实现二叉堆上，这里小傅哥单独把这部分代码拆分出来，了解下关于小堆和大堆的实现。</p>
<p>从对堆的数据结构介绍上可以看到，小堆和大堆的唯一区别仅是对元素的排序方式不同。所以也就是说在存放和获取元素的时候对元素的填充和摘除时，排序方式不同而已。</p>
<ul>
<li><em><strong>入堆实现</strong></em></li>
</ul>
<p>堆的在存放元素时，以遵循它的特点，会在存放过程中，通过队尾元素向上比对迁移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】元素：&#123;&#125; 当前队列：&#123;&#125;&quot;</span>, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点Idx，相当于除以2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        logger.info(<span class="string">&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;</span>, k, parent);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="comment">// 如果当前位置元素，大于父节点元素，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;</span>, JSON.toJSONString(e), JSON.toJSONString(x));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相反父节点位置大于当前位置元素，则进行替换</span></span><br><span class="line">        logger.info(<span class="string">&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;</span>, JSON.toJSONString(e), k);</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \r\n当前队列：&#123;&#125; \r\n&quot;</span>, k, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>入堆的实现 add 方法最终会调用到 siftUpComparable 方法，进行排序的方式进行处理。而这个排序 compareTo 方法是由具体的 MinHeap、MaxHeap 来做实现。</li>
<li>以入堆元素2举例，如图所示入堆过程。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%85%A5%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="入堆实现"></p>
<ul>
<li>首先将元素2挂到队列尾部，之后通过 (k - 1) &gt;&gt;&gt; 1 计算父节点位置，与对应元素进行比对和判断交换。</li>
<li>交换过程包括 2-&gt;6、2-&gt;5，以此交换结束后元素保存完毕。</li>
</ul>
<ul>
<li><em><strong>出堆实现</strong></em></li>
</ul>
<p>元素的出堆其实很简单，只要把根元素直接删除弹出即可。但剩余接下里的步骤才是复杂的，因为需要在根元素迁移走后，寻找另外的最小元素迁移到对头。这个过程与入堆正好相反，这是一个不断向下迁移的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="comment">// 先找出中间件节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 找到左子节点和右子节点，两个节点进行比较，找出最大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子节点与右子节点比较，取最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; compareTo((E) c, (E) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;</span>, JSON.toJSONString(c), JSON.toJSONString(queue[right]));</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) c) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值小于c值，位置替换，继续比较</span></span><br><span class="line">        logger.info(<span class="string">&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;</span>, JSON.toJSONString(queue[k]), JSON.toJSONString(c));</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把目标值放到对应位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;</span>, k, JSON.toJSONString(x));</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不断地向下迁移元素。这个过程会比对左右子节点的值，找到最小的。所以整个过程会比入堆麻烦一些。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%87%BA%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="出堆实现"></p>
<p>这里以弹出元素1举例，之后将堆尾元素替换到相应的位置。整个过程分为6张图表述。</p>
<ol>
<li>图1到图2，找出根元素弹出。</li>
<li>图3到图4，将根元素向下迁移，与子元素比对，并替换位置。如果这个位置与8相比，小于8则继续向下迁移。</li>
<li>图4到图5，继续迁移，在原节点4的位置对应的两个子元素，都比8大，这个时候就可以停下来了。</li>
<li>图5到图6，更换元素位置，把队尾的元素替换到对应元素1向下迁移检测的位置。</li>
</ol>
<ul>
<li><em><strong>最小堆（MinHeap）和最大堆（MaxHeap）</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstElement.compareTo(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> secondElement.compareTo(firstElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用：实现最小堆。</p>
<ul>
<li><p>原理：compareTo 返回 firstElement.compareTo(secondElement)，即：</p>
</li>
<li><p>如果 firstElement &lt; secondElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最小的元素。</p>
</li>
</ul>
</li>
<li><p>作用：实现最大堆。</p>
<ul>
<li><p>原理：compareTo 返回 secondElement.compareTo(firstElement)，即：</p>
</li>
<li><p>如果 secondElement &lt; firstElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最大的元素。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>堆的数据结构是什么样？</strong></li>
</ul>
<p>​	堆是一种完全二叉树结构，通常用数组实现。</p>
<ul>
<li><p>最大堆：每个节点的值都大于等于其子节点（堆顶是最大值）。</p>
</li>
<li><p>最小堆：每个节点的值都小于等于其子节点（堆顶是最小值）。</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li><p>父子节点通过数组下标可以快速定位（如父节点下标为 i，左子为 2i+1，右子为 2i+2）。</p>
</li>
<li><p>结构紧凑，没有“空洞”。</p>
</li>
<li><p><strong>堆的数据结构使用场景？</strong></p>
</li>
</ul>
<p>​	堆常用于优先队列（如任务调度）、排序算法（堆排序）、动态获取最大&#x2F;最小值（如实时统计Top K）、图算法（如Dijkstra最短路径）等需要频繁取最大&#x2F;最小元素的场景。</p>
<ul>
<li><strong>堆的数据结构实现方式有哪些？</strong></li>
</ul>
<ol>
<li>数组实现（最常用）</li>
</ol>
<p>​		利用完全二叉树的性质，父子节点通过下标计算关联，结构紧凑，效率高。</p>
<ol start="2">
<li>链式二叉树实现</li>
</ol>
<p>​		用指针（引用）连接父子节点，结构灵活，但空间利用率和访问效率不如数组。</p>
<ol start="3">
<li>多路堆（如d叉堆）</li>
</ol>
<p>​		可以用数组或链表实现，每个节点有 d 个子节点，适合特殊场景（如堆优化的优先队列）。</p>
<ul>
<li><strong>最小堆和最大堆的区别是什么？</strong></li>
</ul>
<p>​	最小堆和最大堆的区别在于堆顶元素的大小关系：</p>
<ul>
<li><p>最小堆：每个节点的值都小于等于其子节点，堆顶是最小值。</p>
</li>
<li><p>最大堆：每个节点的值都大于等于其子节点，堆顶是最大值。</p>
</li>
</ul>
<p>用途不同：</p>
<ul>
<li><p>最小堆适合快速获取最小元素。</p>
</li>
<li><p>最大堆适合快速获取最大元素。</p>
</li>
<li><p><strong>有了解斐波那契堆吗？</strong></p>
</li>
</ul>
<p>​	斐波那契堆（Fibonacci Heap）是一种<strong>高级堆数据</strong>结构，支持更快的合并（合并两个堆）、插入和减少键值等操作，适用于<strong>需要大量合并和减少最小值操作</strong>的场景（如Dijkstra最短路径算法）。它的结构比普通二叉堆复杂，操作的<strong>摊还时间复杂度更低</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%A0%86/" data-id="cme9lxtnp000qv4qq7dij3u5j" data-title="堆" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-哈希表-散列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T07:48:47.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/">哈希表(散列)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="哈希数据结构"><a href="#哈希数据结构" class="headerlink" title="哈希数据结构"></a>哈希数据结构</h4><p>哈希表的存在是为了解决能通过O(1)时间复杂度直接索引到指定元素。</p>
<p>HashMap 中的拉链寻址 + 红黑树、扰动函数、负载因子、合并散列、杜鹃散列、跳房子哈希、罗宾汉哈希等各类数据结构设计。让元素在发生哈希冲突时，也可以存放到新的槽位，并尽可能保证索引的时间复杂度小于O(n)</p>
<hr>
<h4 id="实现哈希散列"><a href="#实现哈希散列" class="headerlink" title="实现哈希散列"></a>实现哈希散列</h4><p>哈希散列是一个非常常见的数据结构，无论是我们使用的 HashMap、ThreaLocal 还是你在刷题中位了提升索引效率，都会用到哈希散列。</p>
<p>只要哈希桶的长度由负载因子控制的合理，每次查找元素的平均时间复杂度与桶中存储的元素数量无关。另外许多哈希表设计还允许对键值对的任意插入和删除，每次操作的摊销固定平均成本。</p>
<ul>
<li><em><strong>哈希碰撞</strong></em></li>
</ul>
<p><strong>说明</strong>：通过模拟简单 HashMap 实现，去掉拉链寻址等设计，验证元素哈希索引位置碰撞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap01</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] tab = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        tab[idx] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (V) tab[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap01 的实现只是通过哈希计算出的下标，散列存放到固定的数组内。那么这样当发生元素下标碰撞时，原有的元素就会被新的元素替换掉。</li>
</ul>
<ul>
<li><em><strong>拉链寻址</strong></em></li>
</ul>
<p><strong>说明</strong>：既然我们没法控制元素不碰撞，但我们可以对碰撞后的元素进行管理。比如像 HashMap 中拉链法一样，把碰撞的元素存放到链表上。这里我们就来简化实现一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap02BySeparateChaining</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Node&lt;K, V&gt;&gt;[] tab = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果该位置还没有链表，就新建一个链表并添加节点。</span></span><br><span class="line"><span class="comment">			如果已经有链表，直接把新节点加到链表末尾。</span></span><br><span class="line"><span class="comment">			注意：这里没有去重（同一个 key 会重复插入）。*/</span></span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*计算 key 的哈希值，找到对应链表。</span></span><br><span class="line"><span class="comment">		遍历链表，找到 key 相等的节点，返回其 value。</span></span><br><span class="line"><span class="comment">		如果没找到，返回 null。*/</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt; kvNode : tab[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(kvNode.getKey())) &#123;</span><br><span class="line">                <span class="keyword">return</span> kvNode.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为元素在存放到哈希桶上时，可能发生下标索引膨胀，所以这里我们把每一个元素都设定成一个 Node 节点，这些节点通过 LinkedList 链表关联，当然你也可以通过 Node 节点构建出链表 next 元素即可。</li>
<li>那么这时候在发生元素碰撞，相同位置的元素就都被存放到链表上了，获取的时候需要对存放多个元素的链表进行遍历获取。</li>
</ul>
<ul>
<li><em><strong>开放寻址</strong></em></li>
</ul>
<p><strong>说明</strong>：除了对哈希桶上碰撞的索引元素进行拉链存放，还有不引入新的额外的数据结构，只是在哈希桶上存放碰撞元素的方式。它叫开放寻址，也就是 ThreaLocal 中运用斐波那契散列+开放寻址的处理方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap03ByOpenAddressing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果该位置已被占用（哈希冲突），则向后线性探查，找到下一个空位插入。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tab[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i ++)&#123;</span><br><span class="line">            <span class="comment">//从 idx 开始向后线性查找，遇到 key 相等的节点就返回 value。</span></span><br><span class="line">            <span class="keyword">if</span> (tab[idx] != <span class="literal">null</span> &amp;&amp; tab[idx].key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>开放寻址的设计会对碰撞的元素，寻找哈希桶上新的位置，这个位置从当前碰撞位置开始向后寻找，直到找到空的位置存放。</li>
<li>在 ThreadLocal 的实现中会使用斐波那契散列、索引计算累加、启发式清理、探测式清理等操作，以保证尽可能少的碰撞。</li>
</ul>
<ul>
<li><em><strong>合并散列</strong></em></li>
</ul>
<p><strong>说明</strong>：合并散列是开放寻址和单独链接的混合，碰撞的节点在哈希表中链接。此算法适合固定分配内存的哈希桶，通过存放元素时识别哈希桶上的最大空槽位来解决合并哈希中的冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap04ByCoalescedHashing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//从数组末尾向前找一个空位（cursor），插入新节点。</span></span><br><span class="line">		<span class="comment">//然后在原冲突链的末尾，将idxOfNext指向新节点的下标（cursor），形成“链”。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> tab.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tab[cursor] != <span class="literal">null</span> &amp;&amp; tab[cursor].key != key) &#123;</span><br><span class="line">            --cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        tab[cursor] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将碰撞节点指向这个新节点</span></span><br><span class="line">        <span class="keyword">while</span> (tab[idx].idxOfNext != <span class="number">0</span>)&#123;</span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[idx].idxOfNext = cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (tab[idx].key != key) &#123;</span><br><span class="line">            <span class="comment">//如果不是目标 key，就顺着idxOfNext跳到下一个节点，直到找到 key 相等的节点。</span></span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="type">int</span> idxOfNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>合并散列的最大目的在于将碰撞元素链接起来，避免因为需要寻找碰撞元素所发生的循环遍历。也就是A、B元素存放时发生碰撞，那么在找到A元素的时候可以很快的索引到B元素所在的位置。</p>
</li>
<li><p>相对于直接使用开放寻址，这样的挂在链路指向的方式，可以提升索引的性能。因为在实际的数据存储上，元素的下一个位置不一定空元素，可能已经被其他元素占据，这样就增加了索引的次数。所以使用直接指向地址的方式，会更好的提高索引性能。</p>
</li>
</ul>
<ul>
<li><em><strong>杜鹃散列</strong></em></li>
</ul>
<p><strong>说明</strong>：这个名字起的比较有意思，也代表着它的数据结构。杜鹃鸟在孵化🐣的时候，雏鸟会将其他蛋或幼崽推出巢穴；类似的这个数据结构会使用2组key哈希表，将冲突元素推到另外一个key哈希表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> isRehash)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">k</span> <span class="operator">=</span> maskNull(key);</span><br><span class="line">    <span class="keyword">if</span> (containsKey(k)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (insertEntry(<span class="keyword">new</span> <span class="title class_">Entry</span>&lt;K, V&gt;((K) k, value))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRehash) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rehash(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="keyword">return</span> put((K) k, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">insertEntry</span><span class="params">(Entry&lt;K, V&gt; e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Entry&lt;K, V&gt; current = e;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(hash1, current.key);</span><br><span class="line">    <span class="keyword">while</span> (current != e || count &lt; table.length) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; temp = table[index];</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">            table[index] = current;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = current;</span><br><span class="line">        current = temp;</span><br><span class="line">        <span class="keyword">if</span> (index == hash(hash1, current.key)) &#123;</span><br><span class="line">            index = hash(hash2, current.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = hash(hash1, current.key);</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当多个键映射到同一个单元格时会发生这种情况。杜鹃散列的基本思想是通过使用两个散列函数而不是仅一个散列函数来解决冲突。</li>
<li>这为每个键在哈希表中提供了两个可能的位置。在该算法的一种常用变体中，哈希表被分成两个大小相等的较小的表，每个哈希函数都为这两个表之一提供索引。两个散列函数也可以为单个表提供索引。</li>
<li>在实践中，杜鹃哈希比线性探测慢约 20-30%，线性探测是常用方法中最快的。然而，由于它对搜索时间的最坏情况保证，当需要实时响应率时，杜鹃散列仍然很有价值。杜鹃散列的一个优点是它的无链接列表属性，非常适合 GPU 处理。</li>
</ul>
<ul>
<li><em><strong>跳房子散列</strong></em></li>
</ul>
<p><strong>说明</strong>：跳房子散列是一种基于开放寻址的算法，它结合了杜鹃散列、线性探测和链接的元素，通过桶邻域的概念——任何给定占用桶周围的后续桶，也称为“虚拟”桶。 该算法旨在在哈希表的负载因子增长超过 90% 时提供更好的性能；它还在并发设置中提供了高吞吐量，因此非常适合实现可调整大小的并发哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(AnyType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentPos</span> <span class="operator">=</span> findPos(x);</span><br><span class="line">    <span class="keyword">if</span> (currentPos == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (array[currentPos] != <span class="literal">null</span>) &#123;</span><br><span class="line">        x = array[currentPos].element;</span><br><span class="line">        array[currentPos].isActive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String hope;</span><br><span class="line">    <span class="keyword">if</span> (array[currentPos] != <span class="literal">null</span>) &#123;</span><br><span class="line">        hope = array[currentPos].hope;</span><br><span class="line">        x = array[currentPos].element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hope = <span class="string">&quot;10000000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[currentPos] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;&gt;(x, hope, <span class="literal">true</span>);</span><br><span class="line">    theSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该算法使用一个包含n 个桶的数组。对于每个桶，它的邻域是H个连续桶的小集合（即索引接近原始散列桶的那些）。邻域的期望属性是在邻域的桶中找到一个项目的成本接近于在桶本身中找到它的成本（例如，通过使邻域中的桶落在同一缓存行中）。在最坏的情况下，邻域的大小必须足以容纳对数个项目（即它必须容纳 log( n ) 个项目），但平均只能是一个常数。如果某个桶的邻域被填满，则调整表的大小。</li>
</ul>
<ul>
<li><em><strong>罗宾汉哈希</strong></em></li>
</ul>
<p><strong>说明</strong>：罗宾汉哈希是一种基于开放寻址的冲突解决算法；冲突是通过偏向从其“原始位置”（即项目被散列到的存储桶）最远或最长探测序列长度（PSL）的元素的位移来解决的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 元素碰撞检测</span></span><br><span class="line">    <span class="keyword">while</span> (table[idx] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset &gt; table[idx].offset) &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量不止一个，则查看条目交换位置，entry 是正在查看的条目，增加现在搜索的事物的偏移量和 idx</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">garbage</span> <span class="operator">=</span> table[idx];</span><br><span class="line">            table[idx] = entry;</span><br><span class="line">            entry = garbage;</span><br><span class="line">            idx = increment(idx);</span><br><span class="line">            entry.offset++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset == table[idx].offset) &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量与正在查看的检查键是否相同，如果是则它们交换值，如果不是，则增加 idx 和偏移量并继续</span></span><br><span class="line">            <span class="keyword">if</span> (table[idx].key.equals(key)) &#123;</span><br><span class="line">                <span class="comment">// 发现相同值</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> table[idx].value;</span><br><span class="line">                table[idx].value = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idx = increment(idx);</span><br><span class="line">                entry.offset++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量小于我们正在查看的我们增加 idx 和偏移量并继续</span></span><br><span class="line">            idx = increment(idx);</span><br><span class="line">            entry.offset++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经到达了 null 所在的 idx，将新/移动的放在这里</span></span><br><span class="line">    table[idx] = entry;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 超过负载因子扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= loadFactor * table.length) &#123;</span><br><span class="line">        rehash(table.length * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>09、12 和 01 发生哈希索引碰撞，进行偏移量计算调整。通过最长位置探测碰撞元素位移来处理。</p>
</li>
<li><p>通过测试结果和调试的时候可以看到，哈希索引冲突是通过偏向从其“原始位置”（即项目被散列到的存储桶）最远或最长<em>探测序列长度（PSL）的元素的位移来解决</em>。这块可以添加断点调试验证。</p>
</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>介绍一下散列表</strong></li>
</ul>
<p>​	散列表（Hash Table）是一种基于键值对存储的数据结构。它通过哈希函数将键（key）映射到数组的某个位置（桶或槽），以实现高 效的插入、查找和删除操作，平均时间复杂度为 O(1)。</p>
<ul>
<li><strong>为什么使用散列表</strong></li>
</ul>
<p>​	使用散列表的主要原因是查找、插入和删除操作非常高效，平均时间复杂度为 O(1)，远快于数组、链表等结构。</p>
<ul>
<li><strong>拉链寻址和开放寻址的区别</strong></li>
</ul>
<p>​	拉链法用链表解决冲突，元素可分散在链表中；开放寻址所有元素都在数组内，通过探查空位解决冲突。</p>
<ul>
<li><strong>还有其他什么方式可以解决散列哈希索引冲突</strong></li>
</ul>
<p>​	再哈希法:冲突时，使用另一个哈希函数计算新的位置，减少聚集。</p>
<p>​	合链哈希:结合拉链法和开放寻址，将链表节点也放在哈希表数组中。</p>
<p>​	罗宾汉哈希\跳房子散列\杜鹃散列</p>
<ul>
<li><strong>对应的Java源码中，对于哈希索引冲突提供了什么样的解决方案</strong></li>
</ul>
<p>​	Java标准库的哈希表（如 HashMap、Hashtable、ConcurrentHashMap）主要采用拉链法（链表或红黑树）来解决哈希冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/" data-id="cme9lxtnm000iv4qq8f9ie5q1" data-title="哈希表(散列)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-堆栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/%E5%A0%86%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T06:57:00.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/24/%E5%A0%86%E6%A0%88/">堆栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="堆栈数据结构"><a href="#堆栈数据结构" class="headerlink" title="堆栈数据结构"></a>堆栈数据结构</h4><p>在计算机科学中，堆栈是一种抽象数据类型，用作元素的集合，具有两个主要的操作；</p>
<ul>
<li>PUSH：将元素添加到集合</li>
<li>POP：删除最近添加但尚未删除的元素</li>
</ul>
<p>堆栈是一种 LIFO（后进先出）的线性的数据结构，或者更抽象说是一种顺序集合，push 和 pop 操作只发生在结构的一端，称为栈顶。这种结构可以很容易地从堆栈顶部取出一个项目，而要到达堆栈更深处的一个项目可能需要先取出多个其他项目。例如；我们经常看到的浏览器访问记录，总是把最近记录展示给你。还包括：一摞书、一叠盘子、一脑瓜子生活琐事。</p>
<h4 id="实现堆栈结构"><a href="#实现堆栈结构" class="headerlink" title="实现堆栈结构"></a>实现堆栈结构</h4><p>Deque 接口及其实现提供了一组更完整和一致的 LIFO 堆栈操作，应优先使用此类。所以我们本章也是以 ArrayDeque 为原型做代码实现。</p>
<ul>
<li>*** ArrayDeque 介绍***</li>
</ul>
<p>ArrayDeque 是一个基于数组实现的堆栈数据结构，在数据存放时元素通过二进制与运算获取对应的索引存放元素。当数组长度超过初始空间后，进行2的n次幂左移一位扩容，并将数组内容的元素按照分半分别进行迁移。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/ArrayDeque.png" alt="ArrayDeque"></p>
<ul>
<li>堆栈的数据结构是以2的次幂进行初始化，扩容时候为2的倍数。它之所这样是因为保证了在后续计算元素索引位置时，可以进行与运算。也就说 2的n次幂-1 得到的值是一个011111的范围，在与元素索引位置计算时候，找到两个值之间1的位置即可。</li>
<li>数据的压栈，压栈是一个在数组中倒放的方式，通过与运算得到索引值。当发生空间不足时扩容迁移数据，会有2次操作。一次是空间的前半段复制，另外一次是后半段复制。</li>
<li>最后在数据弹出时，按照空间的元素数量总数开始，同样通过与运算计算索引值。分为弹出队列中未发生迁移的数据，和已经完全迁移好的数据。<em>凡是迁移的数据，都是保证了一个顺序。</em></li>
</ul>
<ul>
<li><em><strong>添加元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//计算新元素插入的位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;push.idx head：&#123;&#125;&quot;</span>, head);</span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//如果head和tail重合，说明数组已满，需要扩容。</span></span><br><span class="line">        doubleCapacity();<span class="comment">//调用doubleCapacity()方法将数组容量翻倍。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="添加元素"></p>
<ul>
<li>push 元素的过程相当于找到初始化数组长度的队尾，另外是扩容后从新的队尾开始依次添加元素。此时不用担心元素的输出，因为输出时是从扩容起始点开始输出元素。</li>
</ul>
<ul>
<li><em><strong>扩容空间</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * src      - 源数组</span></span><br><span class="line"><span class="comment">     * srcPos   – 源数组中的起始位置</span></span><br><span class="line"><span class="comment">     * dest     - 目标数组</span></span><br><span class="line"><span class="comment">     * destPos  – 目标数据中的起始位置</span></span><br><span class="line"><span class="comment">     * length   – 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 第一次拷贝元素：[2、1、4、3] 将数组中的扩容后一半元素拷贝到新数组0开始往后的位置。拷贝4、3</span></span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    <span class="comment">// 第二次拷贝元素：[2、1、4、3] 将数组中的前面一半数量的元素，拷贝到新数组后一半开始的位置往后。拷贝2、1</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%89%A9%E5%AE%B9%E7%A9%BA%E9%97%B4.png" alt="扩容空间"></p>
<ul>
<li>空间扩容以2的倍数进行操作，以此保证2的幂等。</li>
<li>System.arraycopy 是操作数据迁移的本地方法，从源数组的某个指定位置，把元素迁移到新数组的指定位置和指定个数个元素。</li>
<li>另外是数据迁移，以 [2、1、4、3] 举例；<ul>
<li>第一次拷贝元素：[2、1、4、3] 将数组中的扩容后一半元素拷贝到新数组0开始往后的位置。拷贝4、3</li>
<li>第二次拷贝元素：[2、1、4、3] 将数组中的前面一半数量的元素，拷贝到新数组后一半开始的位置往后。拷贝2、1</li>
</ul>
</li>
</ul>
<ul>
<li><em><strong>弹出元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[h];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[h] = <span class="literal">null</span>;</span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;pop.idx &#123;&#125; = &#123;&#125; &amp; &#123;&#125;&quot;</span>, head, Integer.toBinaryString(h + <span class="number">1</span>), Integer.toBinaryString(elements.length - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%BC%B9%E5%87%BA%E5%85%83%E7%B4%A0.png" alt="弹出元素"></p>
<ul>
<li>按照索引的计算，以此是弹出索引为：6、7、0、1、2、3、4 对应的元素。head 的值从扩容的长度添加元素后逐步减小，所以当前最开始弹出的元素是6索引对应的值。</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>堆栈的使用场景？</strong></li>
</ul>
<p>​	括号匹配：判断括号是否成对出现。（需要使用先入后出的数据结构的场景）</p>
<ul>
<li><strong>为什么不是用 Stack 类？</strong></li>
</ul>
<p>​	Stack十分粗糙，效率低下。（Stack 过时且效率低，推荐用 ArrayDeque 或 LinkedList 实现栈结构。）</p>
<ul>
<li><strong>ArrayDeque 是基于什么实现的？</strong></li>
</ul>
<p>​	ArrayDeque 是用环形数组实现的双端队列，支持高效的头尾插入和删除操作。</p>
<ul>
<li><strong>ArrayDeque 数据结构使用过程叙述。</strong></li>
</ul>
<p>​	ArrayDeque是双端队列，使用的时候提供从两端插入或弹出，那它可以同时实现栈和队列的功能</p>
<ul>
<li><strong>ArrayDeque 为什么要初始化2的n次幂个长度？</strong></li>
</ul>
<p>​	为了便于进行无符号取模(2^n - 1)得到索引</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/24/%E5%A0%86%E6%A0%88/" data-id="cme9lxtnq000vv4qqcex60dsz" data-title="堆栈" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T02:58:30.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/24/%E9%98%9F%E5%88%97/">队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h4><p>在计算机科学中, 一个 <strong>队列(queue)</strong> 是一种特殊类型的抽象数据类型或集合。集合中的实体按顺序保存。</p>
<ul>
<li>从理论上讲，队列的一个特征是它没有特定的容量。不管已经包含多少元素，总是可以再添加一个新元素。</li>
<li>队列既可以是数组实现也可以是链表实现。所以当我们在 Java 中使用队列的时候，Deque 的实现类就是；LinkedList 和 ArrayDeque的实现类。</li>
<li>队列不只是单端从一个口入另外一个口出，也可以是双端队列。例如在 Java 中 Queue 是单端队列接口、Deque 是双端队列接口，都有对应的实现类。</li>
</ul>
<hr>
<h4 id="延迟队列介绍"><a href="#延迟队列介绍" class="headerlink" title="延迟队列介绍"></a>延迟队列介绍</h4><p>队列的数据结构更像是数组和链表的变种，只要能看懂数组和链表，就能看懂队列。那么这里我们来扩展实现一个<strong>延迟队列</strong>，并在这个过程中会涉及到<strong>阻塞队列</strong>、<strong>优先队列</strong>的使用。通过这样的一个手写源码的学习队列的扩展使用。</p>
<h5 id="1-延迟队列说明"><a href="#1-延迟队列说明" class="headerlink" title="1. 延迟队列说明"></a>1. 延迟队列说明</h5><p>DelayQueue 是一个 BlockingQueue（无界阻塞）队列，它封装了一个使用完全二叉堆排序元素的 PriorityQueue（优先队列）。在添加元素时使用 Delay（延迟时间）作为排序条件，延迟最小的元素会优先放到队首。</p>
<ul>
<li>延迟队列的第一个核心点在于对所加入的元素按照一定的规则进行排序存放，这样才能让在延迟弹出元素的时候，按照所存放元素的排序进行输出。</li>
<li>那么这个延迟队列中用到的排序方式就是 PriorityQueue 优先队列，它的数据结构是数组实现的队列，但体现形式是一棵二叉堆树结构。在元素存放时，通过对存放元素的比较和替换形成二叉堆结构。</li>
</ul>
<h5 id="2-二叉堆结构"><a href="#2-二叉堆结构" class="headerlink" title="2. 二叉堆结构"></a>2. 二叉堆结构</h5><p>二叉堆是一种特殊结构的堆，它的表现形态可以是一棵完整或近似二叉树的结构。如我们本章节要实现的延迟队列中的元素存放，使用的就是 PriorityQueue 实现的平衡二叉堆结构，数据以队列形式存放在基础数组中。</p>
<ul>
<li><strong>父子节点索引关系</strong>：<ul>
<li>假如父节点为queue[n]，那么左子节点为queue[2n+1]，右子节点为queue[2n+2]</li>
<li>任意孩子节点的父节点位置，都是 <code>(n-1)&gt;&gt;&gt;1</code> 相当于减1后除2取整</li>
</ul>
</li>
<li><strong>节点间大小关系</strong>：<ul>
<li>父节点小于等于任意孩子节点</li>
<li>同一层级的两个孩子节点大小不需要维护，它是在弹出元素的时候进行判断的</li>
</ul>
</li>
<li><strong>子叶节点与非子叶节点</strong>：<ul>
<li>一个长度为 size 的优先级队列，当 index &gt;&#x3D; size &gt;&gt;&gt; 1 时，该节点为叶子节点。否则，为非叶子节点。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="延迟队列实现"><a href="#延迟队列实现" class="headerlink" title="延迟队列实现"></a>延迟队列实现</h4><ul>
<li><em><strong>实现介绍</strong></em></li>
</ul>
<p>延迟队列的实现，主要为在优先队列的基础上，添加可重入锁 ReentrantLock 对阻塞队列的实现。当数据存放时，按照二叉堆结构排序元素，出队时依照排序结构进行迁移。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.png" alt="队列实现"></p>
<ol>
<li><p>延迟队列的使用，是以在 DelayQueue 中存放实现了 Delayed 延迟接口的对象。因为只有实现这个对象，才能比较出当前元素与所需存放到对应位置的一个比对计算过程。</p>
</li>
<li><p>另外这里的核心点包括：PriorityQueue —— 优先队列、ReentrantLock —— 可重入锁、Condition —— 信号量</p>
</li>
</ol>
<ul>
<li><em><strong>入队实现</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点Idx，相当于除以2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        logger.info(<span class="string">&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;</span>, k, parent);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="comment">// 如果当前位置元素大于父节点元素，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;</span>, JSON.toJSONString(e), JSON.toJSONString(key));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相反当前位置元素小于父节点位置，则进行替换</span></span><br><span class="line">        logger.info(<span class="string">&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;</span>, JSON.toJSONString(e), k);</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \r\n当前队列：&#123;&#125; \r\n&quot;</span>, k, JSON.toJSONString(key), JSON.toJSONString(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>DelayQueue 延迟队列，元素入队最终会调用到优先队列的 PriorityQueue#siftUpComparable 方法。</p>
</li>
<li><p>以入队元素2举例，如图所示入队过程。</p>
</li>
<li><p><code>(k - 1) &gt;&gt;&gt; 1</code> 为什么使用<code> &gt;&gt;&gt;</code>右移1位；</p>
</li>
<li><p>首先我们是需要通过右移替代除以2的运算，提升运算效率，找到父节点。<em>移位器比除法器简单得多，在大多数处理器上，移位指令的执行速度比除法指令快</em></p>
</li>
<li><p><code>&gt;&gt;</code> 是算术位移，<code>&gt;&gt;&gt;</code> 是逻辑右移</p>
</li>
<li><p>算术和逻辑左移和乘法的等价，但由于符号位的存在算术右移和除法不等价。</p>
</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%85%A5%E9%98%9F%E5%AE%9E%E7%8E%B0.png" alt="入队实现"></p>
<ol>
<li>首先将元素2挂到队列尾部，之后通过 (k - 1) &gt;&gt;&gt; 1 计算父节点位置，与对应元素进行比对和判断交换。</li>
<li>交换过程包括2-&gt;6、2-&gt;5，以此交换结束后元素保存完毕。</li>
</ol>
<ul>
<li><em><strong>出队实现</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">    <span class="comment">// 先找出中间件节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 找到左子节点和右子节点，两个节点进行比较，找出最大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子节点与右子节点比较，取最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; ((Comparable&lt;? <span class="built_in">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;</span>, JSON.toJSONString(c), JSON.toJSONString(queue[right]));</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值大于c值，位置替换，继续比较</span></span><br><span class="line">        logger.info(<span class="string">&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;</span>, JSON.toJSONString(queue[k]), JSON.toJSONString(c));</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把目标值放到对应位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;</span>, k, JSON.toJSONString(key));</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DelayQueue 延迟队列，元素出队会调用到 PriorityQueue#siftDownComparable 方法，不断地向下迁移元素。这个过程会比对左右子节点的值，找到最小的。所以整个过程会比入队麻烦一些。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%87%BA%E9%98%9F%E5%AE%9E%E7%8E%B0.png" alt="出队实现"></p>
<p>这里以弹出元素1举例，之后将队尾元素替换到相应的位置。整个过程分为6张图表述。</p>
<ol>
<li>图1到图2，找出根元素弹出。</li>
<li>图3到图4，将根元素向下迁移，与子元素比对，并替换位置。如果这个位置与8相比，小于8则继续向下迁移。</li>
<li>图4到图5，继续迁移，在原节点4的位置对应的两个子元素，都比8大，这个时候就可以停下来了。</li>
<li>图5到图6，更换元素位置，把队尾的元素替换到对应元素1向下迁移检测的位置。</li>
</ol>
<ul>
<li><em><strong>操作加锁</strong></em></li>
</ul>
<p><strong>offer：</strong>——入队元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//加锁，保证下面的代码块同一时刻只有一个线程能执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);<span class="comment">// 向队列q插入元素e</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            available.signal();<span class="comment">// 如果e是队首元素，唤醒等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 无论如何都要释放锁，防止死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>poll：</strong>——出队元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">// 加锁，保证下面的代码块同一时刻只有一个线程能执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek();<span class="comment">// 查看队首元素</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 队列为空或队首元素还没到期，返回null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q.poll();<span class="comment">// 队首元素可用，出队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 无论如何都要释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素的入队和出队都会使用 ReentrantLock 的方式进行加锁处理。确保线程安全。</li>
</ul>
<h5 id="为什么要用-ReentrantLock？"><a href="#为什么要用-ReentrantLock？" class="headerlink" title="为什么要用 ReentrantLock？"></a>为什么要用 ReentrantLock？</h5><ul>
<li><p>在多线程环境下，多个线程可能同时对队列进行入队（offer）和出队（poll）操作。</p>
</li>
<li><p>如果不加锁，可能会出现数据竞争、状态不一致等问题（比如两个线程同时插入或删除元素，导致队列结构损坏）。</p>
</li>
<li><p>ReentrantLock 是一种可重入的互斥锁，能保证同一时刻只有一个线程能执行被保护的代码块，从而保证队列操作的<strong>原子性</strong>和<strong>一致性</strong>。</p>
</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>单端队列和双端队列，分别对应的实现类是哪个？</strong></li>
</ul>
<p>​	单端队列（Queue）</p>
<ol>
<li><p>典型实现类：LinkedList、ArrayBlockingQueue、PriorityQueue、DelayQueue 等。</p>
</li>
<li><p>最大区别：只能在一端插入（入队），另一端删除（出队），即“先进先出”（FIFO）。</p>
</li>
</ol>
<p>​	双端队列（Deque）</p>
<ol>
<li><p>典型实现类：LinkedList、ArrayDeque、LinkedBlockingDeque。</p>
</li>
<li><p>最大区别：两端都可以插入和删除元素，既支持队列（FIFO）也支持栈（LIFO）操作。</p>
</li>
</ol>
<ul>
<li><strong>简述延迟队列&#x2F;优先队列的实现方式</strong></li>
</ul>
<p>​	优先队列（PriorityQueue）：底层通常用二叉堆实现，元素按优先级自动排序，每次出队都是优先级最高（或最低）的元素。</p>
<p>​	延迟队列（DelayQueue）：底层也是用优先队列（PriorityQueue）实现，元素按到期时间排序，只有到期的元素才能出队。</p>
<ul>
<li><strong>二叉堆插入&#x2F;弹出元素的过程</strong></li>
</ul>
<p>​	二叉堆插入元素过程：</p>
<ol>
<li><p>新元素放到堆的最后一个位置。</p>
</li>
<li><p>不断与父节点比较，如果不满足堆序（如小顶堆新元素比父节点小），就交换位置。</p>
</li>
<li><p>直到堆序满足或到达根节点，插入完成。</p>
<p>二叉堆弹出元素过程：</p>
</li>
<li><p>取出堆顶元素（最小或最大）。</p>
</li>
<li><p>用最后一个元素填补堆顶空位。</p>
</li>
<li><p>从堆顶开始，不断与子节点比较，如果不满足堆序就交换位置。</p>
</li>
<li><p>直到堆序满足或到达叶子节点，弹出完成。</p>
</li>
</ol>
<ul>
<li><strong>延迟队列的使用场景</strong></li>
</ul>
<ol>
<li><p>定时任务调度：如定时发送消息、定时执行某个操作。</p>
</li>
<li><p>订单超时处理：如电商下单后30分钟未支付自动取消订单。</p>
</li>
<li><p>缓存过期处理：缓存数据到期后自动清理。</p>
</li>
<li><p>消息延迟投递：消息队列中延迟发送消息。</p>
</li>
<li><p>重试机制：任务失败后延迟一段时间再重试。</p>
</li>
</ol>
<ul>
<li><strong>延迟队列为什么添加信号量</strong></li>
</ul>
<p>​	延迟队列添加信号量（如Condition）是为了在没有到期元素时让线程阻塞等待，而不是一直占用CPU自旋。当有新元素到期或插入时，通过信号量唤醒等待线程，保证高效和线程安全。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/24/%E9%98%9F%E5%88%97/" data-id="cme9lxto50022v4qq57vg1pkn" data-title="队列" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/23/%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2025-07-23T11:54:21.000Z" itemprop="datePublished">2025-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/23/%E6%95%B0%E7%BB%84/">数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="数组的数据结构"><a href="#数组的数据结构" class="headerlink" title="数组的数据结构"></a>数组的数据结构</h4><ul>
<li>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型数据的集合。</li>
<li>数组的特点：<ol>
<li>数组是相同数据类型的元素集合（int 不能存放 double）</li>
<li>数组中各元素的存储是有先后顺序的，它们在内存中按照这个顺序连续存放到一起。内存地址连续。</li>
<li>数组获取元素的时间复杂度为O(1)</li>
</ol>
</li>
</ul>
<hr>
<h4 id="实现一个ArrayList-数组"><a href="#实现一个ArrayList-数组" class="headerlink" title="实现一个ArrayList 数组"></a>实现一个ArrayList 数组</h4><ul>
<li><em><strong>基本设计</strong></em></li>
</ul>
<p>数组是一个固定的、连续的、线性的数据结构，那么想把它作为一个自动扩展容量的数组列表，则需要做一些扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//ArrayList 元素数组缓存区</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化 ArrayList 阶段，如果不指定大小，默认会初始化一个空的元素。这个时候是没有默认长度的。</li>
<li>那么什么时候给初始化的长度呢？是在首次添加元素的时候，因为所有的添加元素操作，也都是需要判断容量，以及是否扩容的。那么在 add 添加元素时统一完成这个事情，还是比较好处理的。</li>
<li>之后就是随着元素的添加，容量是会不足的。当容量不足的是，需要进行扩容操作。同时还得需要把旧数据迁移到新的数组上。<em>所以数据的迁移算是一个比较耗时的操作</em></li>
</ol>
<ul>
<li><em><strong>添加元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="comment">//计算添加新元素后所需的最小容量（当前元素个数+1）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minCapacity</span> <span class="operator">=</span> size + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果当前数组是“空数组”（即还没分配实际空间），则将最小容量设为默认容量（如10）和minCapacity中的较大者，保证初次分配时有足够空间。</span></span><br><span class="line">    <span class="keyword">if</span>(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)&#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果最小所需容量大于当前数组长度，说明需要扩容。</span></span><br><span class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//记录旧容量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新容量为旧容量的1.5倍（右移1位等于除以2），即扩容50%。</span></span><br><span class="line">        <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			newCapacity = minCapacity;<span class="comment">//如果1.5倍扩容后仍然不够，则直接扩容到minCapacity，保证能放下新元素。	</span></span><br><span class="line">        &#125;</span><br><span class="line">        elementData = Arrays.copyOf(elementData,newCapacity);<span class="comment">//用Arrays.copyOf扩容数组，将原有元素复制到新数组。</span></span><br><span class="line">    &#125;</span><br><span class="line">    elementData[size++] = e;<span class="comment">//将新元素放到数组末尾，size自增。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示添加成功。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="添加元素"></p>
<ol>
<li>判断当前容量与初始化容量，使用 Math.max 函数取最大值最为最小初始化空间。</li>
<li>接下来是判断 minCapacity 和元素的数量，是否达到了扩容。首次创建 ArrayList 是一定会扩容的，也就是初始化 DEFAULT_CAPACITY &#x3D; 10 的容量。</li>
<li>Arrays.copyOf 实际上是创建一个新的空间数组，之后调用的 System.arraycopy 迁移到新创建的数组上。这样后续所有的扩容操作，也就都保持统一了。</li>
<li>ArrayList 扩容完成后，就是使用 elementData[size++] &#x3D; e; 添加元素操作了。</li>
</ol>
<ul>
<li><em><strong>移除元素</strong></em></li>
</ul>
<p>ArrayList 的重点离不开对 System.arraycopy 的使用，它是一个本地方法，可以让你从原数组的特定位置，迁移到新数组的指定位置和迁移数量。如图 2-5 所示，数据迁移 <em>测试代码在 java-algorithms</em></p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/System.arraycopy.png" alt="System.arraycopy"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    E <span class="title function_">oldValue</span> <span class="params">(E)</span> elementData[index];<span class="comment">//取出下标为index的元素，保存到oldValue，用于最后返回。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index -<span class="number">1</span>;<span class="comment">//计算需要向前移动的元素个数。</span></span><br><span class="line">    <span class="comment">//如果numMoved&gt;0，说明被删除元素后面还有元素，需要整体向前移动一位。</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*System.arraycopy的含义：</span></span><br><span class="line"><span class="comment">		从elementData的index+1位置开始，拷贝numMoved个元素，</span></span><br><span class="line"><span class="comment">		拷贝到elementData的index位置开始。*/</span></span><br><span class="line">        System.arraycopy(elemnetData,index + <span class="number">1</span>,elementData,index,numMoved);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//size--，数组长度减一。把原来最后一个元素位置（现在已经没有用了）置为null，帮助垃圾回收（GC）。</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;<span class="comment">//返回被删除的元素。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>ArrayList 的元素删除，就是在确定出元素位置后，使用 System.arraycopy 拷贝数据方式移动数据，把需要删除的元素位置覆盖掉。</p>
</li>
<li><p>此外它还会把已经删除的元素设置为 null 一方面让我们不会在读取到这个元素，另外一方面也是为了 GC</p>
</li>
</ol>
<ul>
<li><em><strong>获取元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span><span class="comment">//重写了 Object 类的 toString() 方法，用于打印当前对象的字符串表示。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ArrayList&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;elementData=&quot;</span> + Arrays.toString(elementData) +</span><br><span class="line">            <span class="string">&quot;, size=&quot;</span> + size +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;<span class="comment">//  ArrayList&#123;elementData=[元素1, 元素2, ...], size=实际元素个数&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取元素就比较简单了，直接从 elementData 使用索引直接获取即可。这个是一个 O(1) 操作。也正因为搜索元素的便捷性，才让 ArrayList 使用的那么广泛。同时为了兼容可以通过元素来获取数据，而不是直接通过下标，引出了 HashMap 使用哈希值计算下标的计算方式，也引出了斐波那契散列。它们的设计都是在尽可能减少元素碰撞的情况下，尽可能使用贴近 O(1) 的时间复杂度获取数据。</li>
</ol>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>数据结构中有哪些是线性表数据结构？</strong></li>
</ul>
<p>​	数组、链表、栈、队列</p>
<ul>
<li><strong>数组的元素删除和获取，时间复杂度是多少？</strong></li>
</ul>
<p>​	数组元素的获取的时间复杂度是o(1)，因为可以根据索引精确的获取到内存地址，删除，在最坏的情况下是o(n)</p>
<ul>
<li><strong>ArrayList 中默认的初始化长度是多少？</strong></li>
</ul>
<p>​	ArrayList 中默认的初始化长度是10。</p>
<ul>
<li><strong>ArrayList 中扩容的范围是多大一次？</strong></li>
</ul>
<p>​	ArrayList 中扩容的范围是当前容量的一半。</p>
<ul>
<li><strong>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什么？</strong></li>
</ul>
<p>​	ArrayList 完成扩容是通过创建一个新的更大容量的数组，然后将旧数组中的元素复制到新数组中。</p>
<p>​	当前容量 + 当前容量&gt;&gt;1 也就是1.5倍的当前容量，然后调用arraycopy,数据迁移，将容量+1返回</p>
<p>​	System.arraycopy的参数 </p>
<p>​	1. src:原来的数组 </p>
<p>​	2. srcPos：原来数组要复制的起始位置</p>
<p>​	3. dest:目标数组 </p>
<p>​	4. destPos:目标数组放置的起始位置 </p>
<p>​	5. length:复制的长度 </p>
<p>​	Array.arraycopy底层调用的也是System.arraycopy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/23/%E6%95%B0%E7%BB%84/" data-id="cme9lxtnu001bv4qq8jvi2jpl" data-title="数组" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-链表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/23/%E9%93%BE%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2025-07-23T02:00:51.000Z" itemprop="datePublished">2025-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/23/%E9%93%BE%E8%A1%A8/">链表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="链表的数据结构"><a href="#链表的数据结构" class="headerlink" title="链表的数据结构"></a>链表的数据结构</h4><ul>
<li>链表是数据元素的线性集合，元素的线性顺序不是由它们在内存中的物理地址给出的。它是由一组节点组成的数据结构，每个元素指向下一个元素，这些节点一起，表示线性序列。</li>
<li>链表是一种由<strong>节点</strong>构成的数据结构，每个·节点都包含<strong>数据部分</strong>和<strong>指向下一节点的指针</strong>，根据指针的不同又有单向指针，双向指针，循环指针之分。<strong>（单向链表、双向链表、循环链表）</strong></li>
</ul>
<hr>
<h4 id="实现一个-LinkedList链表"><a href="#实现一个-LinkedList链表" class="headerlink" title="实现一个 LinkedList链表"></a>实现一个 LinkedList链表</h4><ul>
<li><em><strong>链表节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node&lt;E&gt; prev,E element,Node&lt;E&gt; next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>链表的数据结构核心根基就在于节点对象的使用，并在节点对象中关联当前节点的上一个和下一个节点。通过这样的方式构建出链表结构。</p>
</li>
<li><p>但也因为在链表上添加每个元素的时候，都需要创建新的 Node 节点，所以这也是一部分耗时的操作。</p>
</li>
</ol>
<ul>
<li><em><strong>头插节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkFirsr</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="comment">//把当前链表的头节点 first 赋值给局部变量 f,为了后续操作时保留原来的头节点引用</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//创建一个新的节点 newNode，它的前驱节点是 null（因为它将成为新的头节点），值为 e，后继节点为原来的头节点 f。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = Node&lt;E&gt;(<span class="literal">null</span>,e,f);</span><br><span class="line">    <span class="comment">//把链表的头指针 first 指向新创建的节点 newNode，即新节点成为链表的第一个节点。</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果原来的头节点 f 是 null，说明链表原本是空的。</span></span><br><span class="line">    <span class="keyword">if</span>(f == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;<span class="comment">//这时，插入的新节点既是头节点也是尾节点，所以把 last 也指向 newNode。</span></span><br><span class="line">    <span class="comment">//如果原来的头节点 f 不是 null，说明链表原本不为空。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;<span class="comment">//这时，把原头节点的 prev 指针指向新节点 newNode，完成双向链表的前向链接。</span></span><br><span class="line">    size++;<span class="comment">//链表长度加一，维护链表的元素个数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%A4%B4%E6%8F%92%E6%B3%95.png" alt="头插法"></p>
<ol>
<li><p>头插的操作流程，先把头节点记录下来。之后创建一个新的节点，新的节点构造函数的头节点入参为null，通过这样的方式构建出一个新的头节点。</p>
</li>
<li><p>原来的头结点，设置 f.prev 连接到新的头节点，这样的就可以完成头插的操作了。另外如果原来就没有头节点，头节点设置为新的节点即可。最后记录当前链表中节点的数量，也就是你使用 LinkedList 获取 size 时候就是从这个值获取的。</p>
</li>
</ol>
<ul>
<li><em><strong>尾插节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = Node&lt;E&gt;(l,e,<span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B0%BE%E6%8F%92%E6%B3%95.png" alt="尾插法"></p>
<ol>
<li>尾差节点与头插节点正好相反，通过记录当前的结尾节点，创建新的节点，并把当前的结尾节点，通过 l.next 关联到新创建的节点上。同时记录 size 节点数量值。</li>
</ol>
<ul>
<li><em><strong>拆链操作</strong></em></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span>&#123;</span><br><span class="line">    <span class="comment">//保存要删除节点的值（element），以及它的前驱（prevNode）和后继（nextNode）节点。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; nextNode = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prevNode = x.prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(prevNode == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果 prevNode == null，说明 x 是头节点，直接把 first 指向 x 的下一个节点。</span></span><br><span class="line">        first = nextNode;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//否则，把 x 的前驱节点的 next 指向 x 的后继节点，并断开 x 的 prev 指针。</span></span><br><span class="line">        prevNode.next = nextNode;</span><br><span class="line">    	x.prev == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nextNode == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果 next == null，说明 x 是尾节点，直接把 last 指向 x 的前驱节点。</span></span><br><span class="line">        last = prevNode;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//否则，把 x 的后继节点的 prev 指向 x 的前驱节点，并断开 x 的 next 指针。</span></span><br><span class="line">        nextNode.prev = prevNode;</span><br><span class="line">    	x.next == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把 x 的数据清空（有助于垃圾回收），链表长度减一，返回被删除节点的元素。</span></span><br><span class="line">    x.item == <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8B%86%E9%93%BE.png" alt="拆链"></p>
<ol>
<li><p>unlink 是一种拆链操作，只要你给定一个元素，它就可以把当前这个元素的上一个节点和一个节点进行相连，之后把自己拆除。</p>
</li>
<li><p>这个方法常用于 remove 移除元素操作，因为整个操作过程不需要遍历，拆除元素后也不需要复制新的空间，所以时间复杂读为 O(1)</p>
</li>
</ol>
<ul>
<li><em><strong>删除节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果要删除的对象 o 是 null，就遍历链表，找到第一个 item == null 的节点，调用 unlink(x) 删除它，返回 true。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果 o 不是 null，就遍历链表，找到第一个 item.equals(o) 的节点，调用 unlink(x) 删除它，返回 true。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历完都没找到，返回 false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png" alt="删除节点"></p>
<ol>
<li><p>删除元素的过程需要 for 循环判断比删除元素的值，找到对应的元素，进行删除。</p>
</li>
<li><p>循环比对的过程是一个 O(n) 的操作，删除的过程是一个 O(1) 的操作。所以如果这个链表较大，删除的元素又都是贴近结尾，那么这个循环比对的过程也是比较耗时的。</p>
</li>
<li><p>remove(o) 负责查找要删除的节点。找到后，调用 unlink(x) 负责断开节点并维护链表结构。删除成功返回 true，否则返回 false。</p>
</li>
</ol>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>描述一下链表的数据结构？</strong></li>
</ul>
<p>​	链表是一种物理结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p>
<ul>
<li><strong>Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</strong></li>
</ul>
<p>​	jdk1.8之前源码是循环双向的 1.8之后就是双向的链表</p>
<ul>
<li><strong>链表中数据的插入、删除、获取元素，时间复杂度是多少？</strong></li>
</ul>
<p>​	O(1)、O(1)、O(n)</p>
<ul>
<li><strong>什么场景下使用链表更合适？</strong></li>
</ul>
<p>​	当需要频繁地进行插入和删除操作时，链表的插入和删除效率更高，因为它不需要像数组那样进行元素的移动。当数据的大小不	      	确定，需要动态地分配内存空间时，链表可以动态地分配内存，不需要事先指定大小。</p>
<hr>
<h4 id="（补）单向链表头插尾插与删除"><a href="#（补）单向链表头插尾插与删除" class="headerlink" title="（补）单向链表头插尾插与删除"></a>（补）单向链表头插尾插与删除</h4><ul>
<li>头插法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e, first);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尾插法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = newNode;</span><br><span class="line">        last = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = newNode;</span><br><span class="line">        last = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; prev, Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="literal">null</span>; <span class="comment">// 可选，帮助GC</span></span><br><span class="line">    x.next = <span class="literal">null</span>; <span class="comment">// 可选，帮助GC</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/23/%E9%93%BE%E8%A1%A8/" data-id="cme9lxtnw001lv4qqdker4riq" data-title="链表" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MarkDown基本使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/09/MarkDown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2025-07-09T13:25:13.000Z" itemprop="datePublished">2025-07-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/09/MarkDown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">MarkDown基本使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>标题</p>
</blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>（# 一级标题）</p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>（## 二级标题）</p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>（### 三级标题）</p>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>（#### 四级标题）</p>
<h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>（##### 五级标题）</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>（###### 六级标题）</p>
<blockquote>
<p>文本</p>
</blockquote>
<p><strong>加粗文本内容</strong><br>*<em>加粗文本内容</em>*</p>
<p>加粗<strong>文本</strong>内容<br>加粗**文本**内容</p>
<p><em>斜体文本内容</em><br>*斜体文本内容*</p>
<p><em>斜体</em>文本内容<br>*斜体*文本内容</p>
<p><em><strong>斜体加粗文本内容</strong></em><br>**<em>*<em>斜体加粗文本内容</em></em>*</p>
<p><del>删除线文本内容</del><br>~<del>删除线文本内容~</del></p>
<blockquote>
<p>分割线</p>
</blockquote>
<hr>
<p>***</p>
<blockquote>
<p>列表与勾选</p>
</blockquote>
<ul>
<li><p>第一项任务<br>* 第一项任务</p>
</li>
<li><p>第二项任务<br>* 第二项任务</p>
</li>
<li><p><input disabled="" type="checkbox"> 
第一项任务<br>* [ ] 第一项任务</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
第二项任务<br>* [x] 第二项任务</p>
</li>
</ul>
<blockquote>
<p>代码块</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>`&#96;&#96;java<br>System.out.println(“Hello World”)<br>`&#96;&#96;</p>
<p>比较字符串对象使用<code>equals()</code>方法<br>比较字符串对象使用`equals()&#96;方法</p>
<blockquote>
<p>超链接</p>
</blockquote>
<p>点击<a href="www.baidu.com">百度</a><br>点击[百度](<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)</p>
<p>注释内容[^1]<br>[^1]:我是注释</p>
<blockquote>
<p>图片</p>
</blockquote>
<p><img src="C:\Users\Administrator\Downloads\44a5b2b0515d3cb73d9ddc1f43660647.jpeg" alt="图片"><br>![图片](C:\Users\Administrator\Downloads\44a5b2b0515d3cb73d9ddc1f43660647.jpeg)</p>
<blockquote>
<p>表格</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小明</td>
<td align="center">18</td>
</tr>
</tbody></table>
<p>| 姓名 | 年龄 |<br>| :—: | :—:|<br>| 小明 | 18 |</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/09/MarkDown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" data-id="cme9lxtng0006v4qq0zz28h8t" data-title="MarkDown基本使用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第一篇文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2025-07-09T02:28:35.000Z" itemprop="datePublished">2025-07-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">第一篇文章</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>代码测试：<br>print(“Hello”)</p>
<p>注意：这里因为我放在md文件中的，所以加上了\，不解析&#96;&#96;&#96;，实际测试时请去掉\。</p>
<p>引用测试：</p>
<blockquote>
<p>这是一条引用</p>
</blockquote>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p>
<ul>
<li>哈哈</li>
<li>嘿嘿</li>
<li>吼吼</li>
</ul>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" data-id="cme9lxtnv001ev4qq3b127fft" data-title="第一篇文章" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" rel="tag">创建文章</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" rel="tag">创建文章</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" style="font-size: 10px;">创建文章</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">工具学习</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E9%87%8D%E7%82%B9/" style="font-size: 15px;">重点</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/13/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2025/08/12/MySOL/">MySOL</a>
          </li>
        
          <li>
            <a href="/2025/08/04/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/2025/08/01/Java/">Java</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>