<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-MySOL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/12/MySOL/" class="article-date">
  <time class="dt-published" datetime="2025-08-12T07:18:13.000Z" itemprop="datePublished">2025-08-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/12/MySOL/">MySOL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h4><p>**说说 MySQL 的架构？ **</p>
<ol>
<li>连接层：客户端连接，验证身份权限</li>
<li>服务层：</li>
</ol>
<ul>
<li><p>查询缓存：检查是否有缓存结果（已废弃）</p>
</li>
<li><p>解析器：词法分析→语法分析→语法树</p>
</li>
<li><p>优化器：生成执行计划，选择索引</p>
</li>
<li><p>执行器：调用存储引擎接口</p>
</li>
</ul>
<ol start="3">
<li>存储引擎层：</li>
</ol>
<ul>
<li>根据执行计划访问数据</li>
<li>返回查询结果</li>
</ul>
<ol start="4">
<li>返回结果：结果集返回给客户端</li>
</ol>
<p>关键点：</p>
<ul>
<li><p>解析器生成语法树</p>
</li>
<li><p>优化器选择最优执行路径</p>
</li>
<li><p>执行器调用存储引擎获取数据</p>
</li>
<li><p>整个流程在服务层协调完成</p>
</li>
</ul>
<p>核心：SQL→解析→优化→执行→结果</p>
<p><strong>一条 SQL语句在MySQL中的执行过程</strong></p>
<p>连接验证：客户端连接，身份认证</p>
<p>查询缓存：检查是否有缓存结果（已废弃）</p>
<p>解析优化：SQL解析成语法树，优化器生成执行计划</p>
<p>执行查询：执行器调用存储引擎接口获取数据</p>
<p>返回结果：结果集返回给客户端</p>
<p>核心流程：连接→解析→优化→执行→返回</p>
<h4 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h4><p><strong>MySQL 提供了哪些存储引擎？</strong></p>
<p>InnoDB：默认引擎，支持事务、行锁、外键，最常用</p>
<p>MyISAM：表锁、全文索引，不支持事务，已逐渐淘汰</p>
<p>Memory：内存表，数据存内存，重启丢失</p>
<p>Archive：高压缩归档存储</p>
<p>核心：InnoDB是主流，其他引擎针对特定场景使用。</p>
<p>**MySQL 存储引擎架构了解吗？ **</p>
<p>插件式设计：存储引擎作为插件，可独立开发和加载</p>
<p>统一接口：Handler接口定义存储引擎必须实现的方法</p>
<p>工作流程：执行器→Handler接口→存储引擎→数据文件</p>
<p>优势：可插拔、统一接口、便于扩展</p>
<p>**MyISAM 和 InnoDB 的区别 **</p>
<p>事务：MyISAM不支持，InnoDB支持ACID</p>
<p>锁机制：MyISAM表锁，InnoDB行锁</p>
<p>外键：MyISAM不支持，InnoDB支持</p>
<p>崩溃恢复：MyISAM不支持，InnoDB支持</p>
<p>存储结构：MyISAM三个文件，InnoDB一个文件</p>
<p>适用场景：MyISAM读多写少，InnoDB读写均衡</p>
<p>核心：InnoDB功能全面，MyISAM性能简单</p>
<h4 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h4><p>**何谓事务？ **</p>
<p>事务：数据库操作的最小逻辑单元，要么全部成功，要么全部失败</p>
<p><strong>何谓数据库事务？</strong><br>数据库事务：一组数据库操作构成逻辑整体，要么全部成功，要么全部失败</p>
<p>**ACID 特性指的是什么？ **</p>
<p>原子性（Atomicity）：事务是不可分割的工作单位，要么全部成功，要么全部失败</p>
<p>一致性（Consistency）：事务执行前后，数据库从一个一致状态转换到另一个一致状态</p>
<p>隔离性（Isolation）：多个事务并发执行时，事务间相互隔离，互不干扰</p>
<p>持久性（Durability）：事务提交后，对数据库的修改永久保存</p>
<p>核心：保证事务的可靠性和数据完整性</p>
<p><strong>并发事务带来了哪些问题?</strong></p>
<p>脏读：事务A读取事务B未提交的数据</p>
<p>不可重复读：事务A多次读取同一数据，事务B修改提交，A读取结果不一致</p>
<p>幻读：事务A查询范围数据，事务B插入新数据，A再次查询发现数据增多</p>
<p>丢失更新：两个事务同时修改同一数据，后提交的覆盖先提交的</p>
<p>核心：并发导致数据不一致，需要隔离级别解决</p>
<p><strong>不可重复读和幻读区别</strong></p>
<p>不可重复读：同一事务内多次读取同一行数据，结果不一致（数据被修改）</p>
<p>幻读：同一事务内多次读取同一范围数据，结果不一致（数据行数变化）</p>
<p>关键区别：</p>
<ul>
<li><p>不可重复读：同一行数据内容变化</p>
</li>
<li><p>幻读：同一范围数据行数变化</p>
</li>
</ul>
<p>核心：不可重复读关注数据值，幻读关注数据行数</p>
<p><strong>SQL 标准定义了哪些事务隔离级别?</strong></p>
<p>读未提交（Read Uncommitted）：最低级别，允许脏读</p>
<p>读已提交（Read Committed）：只读已提交数据，避免脏读</p>
<p>可重复读（Repeatable Read）：同一事务内多次读取结果一致，避免不可重复读</p>
<p>串行化（Serializable）：最高级别，完全隔离，避免所有并发问题</p>
<p>核心：隔离级别越高，并发性能越低，数据一致性越强</p>
<p><strong>MySQL 的默认隔离级别是什么?能解决幻读问题么？</strong></p>
<p>MySQL默认隔离级别：可重复读（Repeatable Read）</p>
<p>能否解决幻读：不能，可重复读只能解决脏读和不可重复读</p>
<p>核心：可重复读级别下仍会出现幻读问题</p>
<p><strong>什么是 MVCC？有什么用？原理了解么？</strong></p>
<p>MVCC：多版本并发控制，通过数据快照实现并发读取</p>
<p>作用：提高并发性能，避免读写冲突，实现非阻塞读</p>
<p>原理：</p>
<ul>
<li><p>每行数据维护多个版本</p>
</li>
<li><p>事务开始时获取快照</p>
</li>
<li><p>读取时根据事务ID选择合适版本</p>
</li>
<li><p>写操作创建新版本</p>
</li>
</ul>
<p>核心：通过版本链实现读不阻塞写，写不阻塞读</p>
<p><strong>InnoDB 事务隔离级别实现原理</strong></p>
<p>读未提交：直接读取最新数据</p>
<p>读已提交：每次读取生成新的ReadView</p>
<p>可重复读：事务开始时生成ReadView，整个事务期间使用同一个</p>
<p>串行化：加锁实现完全隔离</p>
<p>核心机制：MVCC + 锁，不同级别使用不同的ReadView策略和锁机制</p>
<h4 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h4><p><strong>表级锁和行级锁了解吗？有什么区别？</strong></p>
<p>表级锁：锁定整个表，粒度大，并发性能低</p>
<p>行级锁：锁定特定行，粒度小，并发性能高</p>
<p>区别：</p>
<ul>
<li><p>粒度：表锁大，行锁小</p>
</li>
<li><p>并发性：表锁低，行锁高</p>
</li>
<li><p>死锁：表锁少，行锁多</p>
</li>
<li><p>开销：表锁小，行锁大</p>
</li>
</ul>
<p>核心：行级锁并发性好但开销大，表级锁开销小但并发性差</p>
<p><strong>行级锁的使用有什么注意事项？</strong></p>
<p>死锁风险：多个事务按不同顺序加锁容易死锁</p>
<p>锁升级：行锁可能升级为表锁，影响并发</p>
<p>索引使用：必须使用索引，否则锁表</p>
<p>事务时长：事务越长，锁持有时间越长</p>
<p>锁范围：注意锁的范围，避免锁过多行</p>
<p>核心：合理设计加锁顺序，控制事务时长，正确使用索引</p>
<p><strong>共享锁和排他锁呢？</strong></p>
<p>共享锁（S锁）：读锁，多个事务可同时持有，不阻塞读操作</p>
<p>排他锁（X锁）：写锁，独占资源，阻塞其他锁的获取</p>
<p>兼容性：</p>
<ul>
<li><p>S锁与S锁兼容</p>
</li>
<li><p>S锁与X锁不兼容</p>
</li>
<li><p>X锁与X锁不兼容</p>
</li>
</ul>
<p>核心：共享锁允许多读，排他锁独占写</p>
<p><strong>意向锁有什么作用？</strong></p>
<p>快速判断：避免逐行检查是否有行锁，提高加表锁效率</p>
<p>锁兼容性：表级锁和行级锁的协调机制</p>
<p>类型：</p>
<ul>
<li><p>意向共享锁（IS）：表示表中有行级共享锁</p>
</li>
<li><p>意向排他锁（IX）：表示表中有行级排他锁</p>
</li>
</ul>
<p>核心：意向锁是表级锁和行级锁的桥梁，提高锁检查效率</p>
<p><strong>InnoDB 有哪几类行锁？</strong></p>
<p>记录锁（Record Lock）：锁定索引记录</p>
<p>间隙锁（Gap Lock）：锁定索引记录之间的间隙</p>
<p>临键锁（Next-Key Lock）：记录锁+间隙锁的组合</p>
<p>插入意向锁（Insert Intention Lock）：插入时的特殊间隙锁</p>
<p>核心：通过不同类型的行锁实现可重复读隔离级别，防止幻读</p>
<h4 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h4><p><strong>何为索引？有什么作用？</strong></p>
<p>索引：数据库中的数据结构，用于快速定位数据</p>
<p>作用：</p>
<ul>
<li><p>提高查询速度：避免全表扫描</p>
</li>
<li><p>加速排序：利用索引顺序</p>
</li>
<li><p>加速连接：外键关联查询</p>
</li>
<li><p>唯一约束：保证数据唯一性</p>
</li>
</ul>
<p>核心：索引是数据库性能优化的关键，以空间换时间</p>
<p><strong>索引的优缺点</strong></p>
<p>优点：</p>
<ul>
<li><p>提高查询速度</p>
</li>
<li><p>加速排序和分组</p>
</li>
<li><p>保证数据唯一性</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>占用存储空间</p>
</li>
<li><p>降低写操作性能（插入、更新、删除）</p>
</li>
<li><p>维护成本高</p>
</li>
</ul>
<p>核心：索引是双刃剑，提高查询但影响写入，需要合理使用</p>
<p><strong>索引的底层数据结构</strong></p>
<p>B+树：MySQL主要索引结构，多路平衡树</p>
<p>特点：</p>
<ul>
<li><p>叶子节点存储数据</p>
</li>
<li><p>非叶子节点只存储键值</p>
</li>
<li><p>叶子节点通过链表连接</p>
</li>
<li><p>支持范围查询</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li><p>查询效率高</p>
</li>
<li><p>支持范围查询</p>
</li>
<li><p>磁盘友好</p>
</li>
</ul>
<p>核心：B+树是MySQL索引的标准实现，平衡了查询效率和存储效率</p>
<p><strong>MySQL 的索引结构为什么使用 B+树？</strong></p>
<p>相比其他树的优势：</p>
<p>二叉查找树：可能退化成链表，查询效率低</p>
<p>平衡二叉树：树高较高，磁盘I&#x2F;O次数多</p>
<p>红黑树：树高较高，不适合磁盘存储</p>
<p>B树：非叶子节点也存储数据，节点利用率低</p>
<p>B+树优势：</p>
<ul>
<li><p>树高低，减少磁盘I&#x2F;O</p>
</li>
<li><p>叶子节点链表支持范围查询</p>
</li>
<li><p>非叶子节点只存键值，节点利用率高</p>
</li>
<li><p>所有查询到叶子节点，性能稳定</p>
</li>
</ul>
<p>核心：B+树在磁盘存储和查询性能间找到最佳平衡点</p>
<p><strong>主键索引和二级索引</strong></p>
<p>主键索引：</p>
<ul>
<li><p>唯一标识，不允许重复</p>
</li>
<li><p>叶子节点存储完整行数据</p>
</li>
<li><p>自动创建，不可删除</p>
</li>
</ul>
<p>二级索引：</p>
<ul>
<li><p>辅助查询，允许重复</p>
</li>
<li><p>叶子节点存储主键值</p>
</li>
<li><p>需要手动创建，可删除</p>
</li>
</ul>
<p>核心：主键索引存储完整数据，二级索引存储主键值，查询时需要回表</p>
<p><strong>聚集索引与非聚集索引</strong></p>
<p>聚集索引：</p>
<ul>
<li><p>数据行按索引顺序物理存储</p>
</li>
<li><p>一个表只能有一个</p>
</li>
<li><p>通常是主键索引</p>
</li>
</ul>
<p>非聚集索引：</p>
<ul>
<li><p>索引结构与数据分离</p>
</li>
<li><p>叶子节点存储指针或主键</p>
</li>
<li><p>一个表可以有多个</p>
</li>
</ul>
<p>核心：聚集索引决定数据物理存储顺序，非聚集索引是辅助查询结构</p>
<p><strong>覆盖索引</strong></p>
<p>定义：查询的列都在索引中，无需回表查询</p>
<p>优势：</p>
<ul>
<li><p>减少磁盘I&#x2F;O</p>
</li>
<li><p>提高查询性能</p>
</li>
<li><p>避免回表操作</p>
</li>
</ul>
<p>示例：索引包含(name, age)，查询SELECT name, age FROM table WHERE name&#x3D;’张三’</p>
<p>核心：索引覆盖查询需求，直接返回结果，性能最优</p>
<p><strong>联合索引</strong></p>
<p>定义：多个列组合的索引</p>
<p>最左前缀原则：查询必须使用最左边的列，否则索引失效</p>
<p>优势：</p>
<ul>
<li><p>支持多列查询</p>
</li>
<li><p>减少索引数量</p>
</li>
<li><p>支持排序和分组</p>
</li>
</ul>
<p>示例：索引(name, age, city)，查询WHERE name&#x3D;’张三’ AND age&#x3D;25有效</p>
<p>核心：遵循最左前缀，合理设计列顺序</p>
<p><strong>最左前缀匹配原则</strong></p>
<p>定义：联合索引必须从最左列开始使用，不能跳过中间列</p>
<p>规则：</p>
<ul>
<li><p>必须包含最左列</p>
</li>
<li><p>可以只使用最左列</p>
</li>
<li><p>不能跳过最左列使用后面的列</p>
</li>
</ul>
<p>示例：</p>
<ul>
<li><p>索引(name, age, city)</p>
</li>
<li><p>WHERE name&#x3D;’张三’ ✓</p>
</li>
<li><p>WHERE name&#x3D;’张三’ AND age&#x3D;25 ✓</p>
</li>
<li><p>WHERE age&#x3D;25 ✗ (跳过name列)</p>
</li>
<li><p>WHERE name&#x3D;’张三’ AND city&#x3D;’北京’ ✓ (age列缺失但name列存在)</p>
</li>
</ul>
<p>核心：联合索引必须从最左列开始，不能跳跃使用</p>
<p><strong>创建索引的注意事项有哪些？</strong></p>
<p>选择性：选择区分度高的列，避免重复值过多</p>
<p>查询频率：为经常查询的列创建索引</p>
<p>列数量：联合索引列数不宜过多，通常不超过5列</p>
<p>列顺序：最左前缀原则，常用列放前面</p>
<p>避免冗余：避免创建功能重复的索引</p>
<p>维护成本：考虑写操作的性能影响</p>
<p>核心：索引要精准，避免过度索引，平衡查询和写入性能</p>
<h4 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h4><p>**MySQL 中常见的日志有哪些？ **</p>
<p>错误日志：记录错误信息和启动信息</p>
<p>查询日志：记录所有SQL语句（默认关闭）</p>
<p>慢查询日志：记录执行时间超过阈值的SQL</p>
<p>二进制日志（binlog）：记录数据变更，用于主从复制和恢复</p>
<p>重做日志（redo log）：InnoDB事务日志，保证持久性</p>
<p>回滚日志（undo log）：记录事务回滚信息</p>
<p>核心：不同日志承担不同职责，保证数据一致性和可恢复性</p>
<p><strong>慢查询日志有什么用？</strong></p>
<p>性能分析：识别执行时间长的SQL语句</p>
<p>优化指导：找出需要优化的查询</p>
<p>监控告警：监控数据库性能问题</p>
<p>阈值设置：通过long_query_time参数设置慢查询阈值</p>
<p>核心：慢查询日志是数据库性能优化的关键工具，帮助识别性能瓶颈</p>
<p><strong>binlog 主要记录了什么？有什么用？</strong></p>
<p>binlog记录内容：</p>
<p>数据变更：INSERT、UPDATE、DELETE、DDL等操作</p>
<p>作用：</p>
<ul>
<li><p>主从复制：从库同步主库数据</p>
</li>
<li><p>数据恢复：恢复到指定时间点</p>
</li>
<li><p>审计追踪：记录数据变更历史</p>
</li>
</ul>
<p>核心：binlog是MySQL的数据变更记录，支持复制和恢复</p>
<p><strong>redo log 如何保证事务的持久性？</strong></p>
<p>WAL机制：先写日志，再写数据</p>
<p>流程：</p>
<ol>
<li><p>事务提交时先写redo log</p>
</li>
<li><p>redo log写入磁盘后事务才算提交成功</p>
</li>
<li><p>数据页异步刷新到磁盘</p>
</li>
</ol>
<p>崩溃恢复：重启后通过redo log重放未刷盘的数据</p>
<p>核心：redo log确保事务提交后数据不丢失，即使崩溃也能恢复</p>
<p><strong>页修改之后为什么不直接刷盘呢？</strong></p>
<p>性能考虑：</p>
<ul>
<li><p>随机I&#x2F;O性能差</p>
</li>
<li><p>多个页修改合并刷盘效率高</p>
</li>
</ul>
<p>WAL机制：</p>
<ul>
<li><p>redo log是顺序写入，性能好</p>
</li>
<li><p>先保证事务持久性，数据页异步刷盘</p>
</li>
</ul>
<p>批量优化：多个脏页一起刷盘，减少I&#x2F;O次数</p>
<p>核心：直接刷盘性能差，WAL机制既保证持久性又提高性能</p>
<p><strong>binlog 和 redolog 有什么区别？</strong></p>
<p>作用范围：</p>
<ul>
<li><p>binlog：MySQL层面，所有存储引擎</p>
</li>
<li><p>redo log：InnoDB层面，只记录InnoDB变更</p>
</li>
</ul>
<p>记录内容：</p>
<ul>
<li><p>binlog：逻辑日志，记录SQL语句</p>
</li>
<li><p>redo log：物理日志，记录页的物理变更</p>
</li>
</ul>
<p>用途：</p>
<ul>
<li><p>binlog：主从复制、数据恢复</p>
</li>
<li><p>redo log：崩溃恢复、事务持久性</p>
</li>
</ul>
<p>核心：binlog是逻辑日志用于复制，redo log是物理日志用于恢复</p>
<p><strong>undo log 如何保证事务的原子性？</strong></p>
<p>回滚机制：事务失败时通过undo log回滚到之前状态</p>
<p>MVCC支持：为并发事务提供数据快照</p>
<p>存储方式：记录数据变更前的值</p>
<p>事务回滚：根据undo log恢复数据到事务开始前的状态</p>
<p>核心：undo log记录数据变更历史，支持事务回滚，保证原子性</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>SQL 优化</strong></p>
<p>项目背景：电商系统订单查询接口响应慢</p>
<p>优化过程：</p>
<ol>
<li><p>慢查询分析：通过慢查询日志发现订单表查询耗时2-3秒</p>
</li>
<li><p>Explain分析：发现缺少复合索引，导致全表扫描</p>
</li>
<li><p>索引优化：为(user_id, status, create_time)创建复合索引</p>
</li>
<li><p>查询优化：避免SELECT <em>，只查询必要字段</em></p>
</li>
</ol>
<p>具体优化：</p>
<ul>
<li><p>添加复合索引，查询时间从2秒降到50ms</p>
</li>
<li><p>使用覆盖索引，避免回表查询</p>
</li>
<li><p>分页查询优化，使用游标分页替代OFFSET</p>
</li>
</ul>
<p>效果：接口响应时间从2秒降到100ms以内，提升20倍性能</p>
<p>核心：通过索引优化和查询语句优化，显著提升SQL性能</p>
<p><strong>慢查询问题排查</strong></p>
<p>项目问题：用户订单列表查询接口响应慢，平均2-3秒</p>
<p>排查过程：</p>
<ol>
<li><p>慢查询日志分析：发现订单表查询频繁出现在慢查询日志中</p>
</li>
<li><p>Explain执行计划：发现type&#x3D;ALL，说明是全表扫描</p>
</li>
<li><p>索引检查：发现查询条件(user_id, status, create_time)缺少复合索引</p>
</li>
</ol>
<p>根本原因：</p>
<ul>
<li><p>缺少复合索引导致全表扫描</p>
</li>
<li><p>查询使用了OFFSET分页，大数据量时性能差</p>
</li>
<li><p>查询了不必要的字段，增加了数据传输</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>创建(user_id, status, create_time)复合索引</p>
</li>
<li><p>使用游标分页替代OFFSET分页</p>
</li>
<li><p>只查询必要字段，避免SELECT *</p>
</li>
</ul>
<p>优化效果：查询时间从2秒降到50ms，提升40倍性能</p>
<p>核心：通过索引优化和查询语句优化，解决慢查询问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/12/MySOL/" data-id="cme8cu3530006r8qqfgq1a1q3" data-title="MySOL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/04/JVM/" class="article-date">
  <time class="dt-published" datetime="2025-08-04T06:51:28.000Z" itemprop="datePublished">2025-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/04/JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><strong>运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？哪些区域可能会出现OutOfMemoryError？哪些区域不会出现OutOfMemoryError?【⭐⭐⭐⭐⭐】</strong></p>
<p>线程共享：</p>
<ul>
<li><p>堆区：存储对象实例，会出现OOM</p>
</li>
<li><p>方法区：存储类信息、常量，会出现OOM</p>
</li>
</ul>
<p>线程独享：</p>
<ul>
<li><p>虚拟机栈：存储局部变量、方法调用，会出现OOM</p>
</li>
<li><p>本地方法栈：本地方法调用，会出现OOM</p>
</li>
<li><p>程序计数器：当前线程执行位置，不会出现OOM</p>
</li>
</ul>
<p>可能出现OOM的区域：</p>
<ul>
<li><p>堆区：内存不足</p>
</li>
<li><p>方法区：类加载过多</p>
</li>
<li><p>虚拟机栈：栈深度过大</p>
</li>
<li><p>本地方法栈：本地方法调用过深</p>
</li>
</ul>
<p>不会出现OOM的区域：</p>
<ul>
<li>程序计数器：空间很小且固定</li>
</ul>
<p>总结： 除了程序计数器，其他区域都可能出现OOM</p>
<p><em><strong>注</strong></em>：</p>
<p><strong>JDK 1.8 之前：</strong></p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/cfa7b253-92a7-4d97-b646-04e6b7be6254.png"></p>
<p><strong>JDK 1.8 ：</strong></p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/008c1c0d-0c5c-44c3-ba70-011e87f622d5.png"></p>
<p>线程私有的：程序计数器、虚拟机栈、本地方法栈</p>
<p>线程共享的：堆、方法区、直接内存 (非运行时数据区的一部分)</p>
<p><strong>说一下方法区和永久代的关系。【⭐⭐⭐】</strong></p>
<p>方法区： JVM规范定义的逻辑概念，存储类信息、常量、静态变量</p>
<p>永久代： HotSpot虚拟机对方法区的具体实现</p>
<p>关系：</p>
<ul>
<li><p>方法区是规范，永久代是实现</p>
</li>
<li><p>类似接口和类的关系</p>
</li>
<li><p>JDK1.8后永久代被元空间替代</p>
</li>
</ul>
<p>变化：</p>
<ul>
<li><p>JDK1.8前：方法区&#x3D;永久代</p>
</li>
<li><p>JDK1.8后：方法区&#x3D;元空间（本地内存）</p>
</li>
</ul>
<p>总结： 方法区是规范，永久代是HotSpot的具体实现，JDK1.8后改为元空间</p>
<p><strong>Java 对象的创建过程。【⭐⭐⭐⭐】</strong></p>
<ol>
<li><p>类加载检查： 检查类是否已加载</p>
</li>
<li><p>分配内存：</p>
</li>
</ol>
<ul>
<li><p>指针碰撞：内存规整</p>
</li>
<li><p>空闲列表：内存不规整</p>
</li>
<li><p>初始化零值： 对象字段初始化为默认值</p>
</li>
<li><p>设置对象头： 设置Mark Word、类型指针</p>
</li>
<li><p>执行init方法： 执行构造函数</p>
</li>
</ul>
<p>总结： 加载→分配→初始化→设置头→构造</p>
<p><strong>对象的访问定位的两种方式知道吗？各有什么优缺点。【⭐⭐⭐⭐】</strong></p>
<p>句柄： 引用指向句柄，句柄指向对象</p>
<ul>
<li><p>优点：对象移动时引用不变</p>
</li>
<li><p>缺点：多一次指针访问</p>
</li>
</ul>
<p>直接指针： 引用直接指向对象</p>
<ul>
<li><p>优点：访问速度快</p>
</li>
<li><p>缺点：对象移动时引用需更新</p>
</li>
</ul>
<p>HotSpot采用： 直接指针方式</p>
<p><strong>如何判断对象是否死亡（两种方法）。 讲一下可达性分析算法的流程。 【⭐⭐⭐⭐】</strong></p>
<p>判断对象死亡方法：</p>
<ol>
<li>引用计数法：</li>
</ol>
<ul>
<li><p>统计对象被引用次数</p>
</li>
<li><p>计数为0则死亡</p>
</li>
<li><p>缺点：无法解决循环引用</p>
</li>
</ul>
<ol start="2">
<li>可达性分析：</li>
</ol>
<ul>
<li><p>从GC Roots开始搜索</p>
</li>
<li><p>无法到达的对象标记为死亡</p>
</li>
</ul>
<p>GC Roots包括：</p>
<ul>
<li><p>虚拟机栈中引用的对象</p>
</li>
<li><p>方法区中静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
<li><p>本地方法栈中引用的对象</p>
</li>
</ul>
<p>可达性分析流程：</p>
<ol>
<li><p>标记GC Roots可达的对象</p>
</li>
<li><p>递归标记可达对象引用的对象</p>
</li>
<li><p>未标记的对象判定为垃圾</p>
</li>
</ol>
<p>总结： 引用计数法简单但有缺陷，可达性分析是主流方法</p>
<p><strong>JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】</strong></p>
<p>强引用： 最常见的引用，不会被GC回收</p>
<p>软引用： 内存不足时才回收，适合缓存</p>
<p>弱引用： 下次GC时回收，适合观察对象生命周期</p>
<p>虚引用： 不影响对象生命周期，用于跟踪对象回收</p>
<p>引用强度： 强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p>
<p>使用场景：</p>
<ul>
<li><p>软引用：内存敏感缓存</p>
</li>
<li><p>弱引用：ThreadLocal、WeakHashMap</p>
</li>
<li><p>虚引用：跟踪对象回收</p>
</li>
</ul>
<p><strong>堆空间的基本结构了解吗？什么情况下对象会进入老年代？【⭐⭐⭐⭐⭐】</strong></p>
<p>堆空间结构：</p>
<ul>
<li><p>新生代：Eden + Survivor0 + Survivor1</p>
</li>
<li><p>老年代：存储长期存活对象</p>
</li>
</ul>
<p>对象进入老年代情况：</p>
<ul>
<li><p>年龄达到阈值： 默认15次GC后进入老年代</p>
</li>
<li><p>大对象： 超过阈值直接进入老年代</p>
</li>
<li><p>动态年龄： 同年龄对象总大小超过Survivor一半，大于该年龄的对象进入老年代</p>
</li>
<li><p>空间分配担保： Minor GC时老年代空间不足，直接进入老年代</p>
</li>
</ul>
<p>总结： 长期存活、大对象、空间不足时对象进入老年代</p>
<p><strong>垃圾收集有哪些算法，各自的特点？【⭐⭐⭐⭐⭐】</strong></p>
<p>标记-清除： 标记垃圾对象，直接清除</p>
<ul>
<li><p>优点：简单</p>
</li>
<li><p>缺点：内存碎片</p>
</li>
</ul>
<p>复制算法： 将存活对象复制到另一区域</p>
<ul>
<li><p>优点：无碎片</p>
</li>
<li><p>缺点：空间利用率低</p>
</li>
</ul>
<p>标记-整理： 标记后移动存活对象</p>
<ul>
<li><p>优点：无碎片，空间利用率高</p>
</li>
<li><p>缺点：移动开销大</p>
</li>
</ul>
<p>分代收集： 新生代用复制，老年代用标记-整理</p>
<ul>
<li><p>优点：结合各算法优势</p>
</li>
<li><p>缺点：实现复杂</p>
</li>
</ul>
<p>总结： 标记-清除简单但碎片多，复制算法无碎片但浪费空间，标记-整理综合较好，分代收集最实用</p>
<p><strong>有哪些常见的 GC?谈谈你对 Minor GC、还有 Full GC 的理解。Minor GC 与 Full GC 分别在什么时候发生？ Minor GC 会发生 stop the world 现象吗？【⭐⭐⭐⭐⭐】</strong></p>
<p>Minor GC： 新生代垃圾收集</p>
<ul>
<li><p>触发条件：Eden区空间不足</p>
</li>
<li><p>会发生Stop The World</p>
</li>
<li><p>频率高，时间短</p>
</li>
</ul>
<p>Major GC： 老年代垃圾收集</p>
<ul>
<li><p>触发条件：老年代空间不足</p>
</li>
<li><p>会发生Stop The World</p>
</li>
<li><p>频率低，时间长</p>
</li>
</ul>
<p>Full GC： 整堆收集</p>
<ul>
<li><p>收集新生代+老年代+方法区</p>
</li>
<li><p>会发生Stop The World</p>
</li>
<li><p>时间最长</p>
</li>
</ul>
<p>触发时机：</p>
<ul>
<li><p>Minor GC：Eden区满</p>
</li>
<li><p>Major GC：老年代满</p>
</li>
<li><p>Full GC：老年代满或方法区满</p>
</li>
</ul>
<p>总结： Minor GC频繁但快，Major GC少但慢，Full GC最慢但全面</p>
<p><strong>讲一下 CMS 垃圾收集器的四个步骤。CMS 有什么缺点？【⭐⭐⭐⭐】</strong></p>
<p>CMS垃圾收集器四个步骤：</p>
<ol>
<li>初始标记： 标记GC Roots直接关联的对象，Stop The World</li>
<li>并发标记： 并发标记所有可达对象</li>
<li>重新标记： 修正并发标记期间的变化，Stop The World</li>
<li>并发清除： 并发清除垃圾对象</li>
</ol>
<p>CMS缺点：</p>
<ul>
<li><p>内存碎片：无法压缩</p>
</li>
<li><p>CPU敏感：并发阶段占用CPU</p>
</li>
<li><p>浮动垃圾：并发期间产生的垃圾无法处理</p>
</li>
<li><p>预留内存：需要预留空间给并发线程</p>
</li>
</ul>
<p>总结： CMS通过并发减少停顿时间，但会产生内存碎片和浮动垃圾</p>
<p><strong>并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？【⭐⭐⭐⭐】</strong></p>
<p>并发标记要解决的是GC暂停时间过长的问题，通过让标记阶段与应用线程并发执行来减少停顿时间。</p>
<p>并发标记带来的主要问题是对象消失问题：在标记过程中，应用线程可能修改对象引用，导致某些对象被遗漏标记。</p>
<p>解决对象消失问题采用三色标记算法：</p>
<ul>
<li><p>白色：未访问对象</p>
</li>
<li><p>灰色：已访问但子对象未完全扫描</p>
</li>
<li><p>黑色：已访问且子对象已完全扫描</p>
</li>
</ul>
<p>当灰色对象引用白色对象时，如果灰色对象变黑，白色对象可能被遗漏。解决方案是写屏障：在对象引用更新时，将新引用的对象标记为灰色，确保不会遗漏。</p>
<p>这样既实现了并发标记减少停顿，又保证了标记的完整性。</p>
<p><strong>G1 垃圾收集器的步骤。有什么缺点？【⭐⭐⭐⭐】</strong></p>
<p>G1垃圾收集器步骤：初始标记（STW）→ 并发标记 → 最终标记（STW）→ 筛选回收（STW）。</p>
<p>G1主要缺点：内存占用高（需要记忆集记录跨代引用）、写屏障开销大（维护记忆集）、小内存场景下性能不如CMS、并发标记阶段CPU占用高影响应用性能。</p>
<p><strong>ZGC 了解吗？【⭐⭐⭐⭐】</strong></p>
<p>ZGC是低延迟垃圾收集器，主要特点：</p>
<p>并发处理：标记、重定位、压缩都并发执行，停顿时间极短（通常&lt;1ms）</p>
<p>三色标记：使用指针着色技术，在对象头中存储标记信息</p>
<p>读屏障：应用线程读取对象时检查颜色，处理重定位后的对象引用</p>
<p>分代设计：支持分代收集，年轻代使用复制算法，老年代使用标记-压缩</p>
<p>大堆友好：支持TB级别堆内存，延迟几乎不随堆大小增长</p>
<p>缺点：CPU占用较高、内存开销大、JDK11+才支持</p>
<p><strong>JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐】</strong></p>
<p>安全点：JVM中GC时必须暂停所有线程的位置，通常是方法调用、循环跳转、异常抛出等指令处。线程执行到安全点时会主动检查是否需要暂停。</p>
<p>安全区：线程长时间执行（如循环）时，如果进入安全区，JVM可以安全地进行GC，线程离开安全区时会检查GC状态。</p>
<p>写屏障：在对象引用更新时插入的代码片段，用于维护GC的正确性。主要类型：</p>
<ul>
<li><p>写前屏障：更新前执行</p>
</li>
<li><p>写后屏障：更新后执行</p>
</li>
</ul>
<p>写屏障在并发GC中至关重要，确保对象引用变化时GC能正确追踪，避免对象遗漏或错误回收。</p>
<p><strong>虚拟机基础故障处理工具有哪些？【⭐⭐⭐】</strong></p>
<p>jstack、jmap、jstat是最核心的命令行工具，MAT是最重要的内存分析工具。</p>
<p><strong>什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】</strong></p>
<p>字节码：Java源代码编译后的中间表示，是JVM执行的指令集，与平台无关。</p>
<p>魔数 版本号 常量池 访问标志 类索引 字段表 方法表 属性表 Code属性 异常表 </p>
<p>类文件是JVM加载、验证、执行的基础，字节码指令包括加载、存储、运算、跳转、方法调用等类型。</p>
<p><strong>类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】</strong></p>
<p>类的生命周期：加载→验证→准备→解析→初始化→使用→卸载</p>
<p>类加载过程：</p>
<ol>
<li><p>加载：通过类名获取二进制数据，生成Class对象</p>
</li>
<li><p>验证：确保字节码格式正确、语义合法</p>
</li>
<li><p>准备：为静态变量分配内存，设置默认值</p>
</li>
<li><p>解析：将符号引用转换为直接引用</p>
</li>
<li><p>初始化：执行静态代码块，初始化静态变量</p>
</li>
</ol>
<p>加载阶段主要工作：</p>
<ul>
<li><p>通过全限定名获取类的二进制数据</p>
</li>
<li><p>将二进制数据转换为方法区内的运行时数据结构</p>
</li>
<li><p>在内存中生成Class对象，作为方法区数据的访问入口</p>
</li>
</ul>
<p>必须初始化的6种情况：</p>
<ol>
<li>创建类实例（new）</li>
<li>访问静态变量或调用静态方法</li>
<li>反射调用（Class.forName）</li>
<li>初始化子类时父类未初始化</li>
<li>包含main方法的启动类</li>
<li>使用JDK7动态语言支持时</li>
</ol>
<p><strong>双亲委派模型了解么？如果我们不想用双亲委派模型怎么办？【⭐⭐⭐⭐⭐】</strong></p>
<p>双亲委派模型：类加载器收到加载请求时，先委托给父加载器，父加载器无法加载时才自己尝试加载。形成层次结构：Bootstrap→Extension→Application→自定义加载器。</p>
<p>作用：保证类加载的唯一性，避免重复加载，保护核心类库安全。</p>
<p>不使用双亲委派的方案：</p>
<p>破坏双亲委派：重写loadClass方法，直接调用findClass或defineClass</p>
<p>线程上下文类加载器：通过Thread.setContextClassLoader设置，绕过双亲委派</p>
<p>OSGi模块化：每个Bundle有自己的类加载器，可以加载不同版本的类</p>
<p>热部署：自定义类加载器加载修改后的类，实现运行时更新</p>
<p>自定义类加载器：继承ClassLoader，重写findClass方法实现特殊加载逻辑</p>
<p>最常见的是重写loadClass方法或使用线程上下文类加载器。</p>
<p><strong>双亲委派模型有什么好处？双亲委派模型是为了保证一个 Java 类在 JVM 中是唯一的？ 【⭐⭐⭐⭐⭐】</strong></p>
<p>安全性：防止用户自定义的java.lang.String等核心类替换系统类，保护JVM核心类库</p>
<p>避免重复加载：父加载器已加载的类，子加载器不会重复加载，节省内存</p>
<p>类加载一致性：确保同一个类在不同类加载器下的一致性</p>
<p>是的，双亲委派模型确实是为了保证Java类在JVM中的唯一性。</p>
<p>通过向上委托机制，同一个类只会被一个类加载器加载，避免了多个类加载器加载同一个类导致的问题。这确保了类的唯一性，防止了类冲突，维护了JVM的稳定性和安全性。</p>
<p><strong>JDK 中有哪些默认的类加载器？ 【⭐⭐⭐⭐】</strong></p>
<p>Bootstrap ClassLoader：启动类加载器，加载JAVA_HOME&#x2F;jre&#x2F;lib下的核心类库（rt.jar等），C++实现，无父加载器</p>
<p>Extension ClassLoader：扩展类加载器，加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext下的扩展类库，Java实现，父加载器为Bootstrap</p>
<p>Application ClassLoader：应用类加载器，加载classpath下的应用类，Java实现，父加载器为Extension</p>
<p>System ClassLoader：系统类加载器，通常就是Application ClassLoader的别名</p>
<p>Platform ClassLoader：JDK9+引入，替代Extension ClassLoader，加载平台模块</p>
<p>App ClassLoader：JDK9+中Application ClassLoader的别名</p>
<p>这些加载器形成层次结构，通过双亲委派机制协同工作。</p>
<p><strong>堆内存相关的 JVM 参数有哪些？你在项目中实际配置过了吗？ 【⭐⭐⭐⭐⭐】</strong></p>
<p>堆大小：</p>
<ul>
<li><p>-Xms：初始堆大小</p>
</li>
<li><p>-Xmx：最大堆大小</p>
</li>
<li><p>-XX:InitialRAMPercentage：初始堆占物理内存百分比</p>
</li>
<li><p>-XX:MaxRAMPercentage：最大堆占物理内存百分比</p>
</li>
</ul>
<p>新生代：</p>
<ul>
<li><p>-Xmn：新生代大小</p>
</li>
<li><p>-XX:NewRatio：新生代与老年代比例</p>
</li>
<li><p>-XX:SurvivorRatio：Eden与Survivor比例</p>
</li>
</ul>
<p>其他：</p>
<ul>
<li><p>-XX:MetaspaceSize：元空间初始大小</p>
</li>
<li><p>-XX:MaxMetaspaceSize：元空间最大大小</p>
</li>
<li><p>-XX:+UseG1GC：使用G1收集器</p>
</li>
</ul>
<p>实际配置经验：</p>
<p>是的，在生产环境中配置过。通常设置-Xms&#x3D;-Xmx避免堆大小动态调整，新生代占堆的1&#x2F;3，根据业务特点调整GC参数。高并发系统会适当增大堆大小，低延迟系统会选择合适的GC算法。</p>
<p><strong>如何对栈进行参数调优？【⭐⭐⭐⭐】</strong></p>
<p>线程栈大小：</p>
<ul>
<li><p>-Xss：设置线程栈大小，默认1MB</p>
</li>
<li><p>-XX:ThreadStackSize：同样设置栈大小</p>
</li>
</ul>
<p>调优策略：</p>
<ul>
<li><p>增大栈大小：递归调用深、局部变量多的场景</p>
</li>
<li><p>减小栈大小：线程数量多、内存紧张时，可减少到256KB-512KB</p>
</li>
<li><p>平衡考虑：栈太小容易StackOverflowError，太大影响线程数量</p>
</li>
</ul>
<p>实际应用：</p>
<ul>
<li><p>计算密集型：适当增大栈大小</p>
</li>
<li><p>高并发IO：减小栈大小，增加线程数</p>
</li>
<li><p>递归算法：根据递归深度调整栈大小</p>
</li>
</ul>
<p>注意事项：</p>
<p>栈大小影响最大线程数，需要结合系统内存和线程需求综合考虑。</p>
<p><strong>你在项目中遇到过 GC 问题吗？怎么分析和解决的？【⭐⭐⭐⭐⭐】</strong></p>
<p>问题描述：生产环境频繁Full GC，应用响应慢，出现OOM</p>
<p>分析过程：</p>
<ol>
<li><p>监控发现：通过JVM监控发现老年代内存持续增长</p>
</li>
<li><p>堆转储分析：用jmap生成堆转储，MAT分析发现大对象占用</p>
</li>
<li><p>线程分析：jstack查看线程状态，发现线程阻塞</p>
</li>
<li><p>GC日志分析：查看GC日志，发现GC频率和耗时异常</p>
</li>
</ol>
<p>根本原因：</p>
<ul>
<li><p>缓存对象未设置过期时间，内存泄漏</p>
</li>
<li><p>大文件上传处理不当，临时对象未及时释放</p>
</li>
<li><p>GC参数配置不合理，老年代空间不足</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>修复缓存泄漏，添加过期机制</p>
</li>
<li><p>优化文件处理逻辑，及时释放资源</p>
</li>
<li><p>调整JVM参数：增大堆大小，优化GC算法</p>
</li>
<li><p>添加监控告警，及时发现问题</p>
</li>
</ul>
<p>效果：GC频率降低80%，应用响应时间恢复正常。</p>
<p><strong>GC 性能指标了解吗？调优原则呢？【⭐⭐⭐⭐⭐】</strong></p>
<p>GC性能指标：</p>
<p>吞吐量：应用运行时间占总时间的比例，越高越好</p>
<p>延迟：GC停顿时间，越低越好，通常要求&lt;100ms</p>
<p>内存占用：GC本身占用的内存，越少越好</p>
<p>GC频率：GC发生的次数，频率过高影响性能</p>
<p>调优原则：</p>
<p>优先原则：吞吐量优先（批处理）或延迟优先（交互式应用）</p>
<p>内存分配：合理设置堆大小，避免频繁GC</p>
<p>分代调优：新生代大小影响Minor GC频率，老年代大小影响Full GC频率</p>
<p>GC算法选择：根据应用特点选择，高并发选G1&#x2F;ZGC，批处理选ParallelGC</p>
<p>监控调优：基于实际GC日志和性能数据调优，不是盲目调整</p>
<p>平衡考虑：吞吐量、延迟、内存占用三者平衡，找到最佳配置点</p>
<p><strong>如何降低 Full GC 的频率？【⭐⭐⭐⭐⭐】</strong></p>
<p>降低Full GC频率的方法：</p>
<p>增大堆内存：-Xmx设置合理值，给老年代更多空间</p>
<p>优化新生代：增大-Xmn，减少对象过早进入老年代</p>
<p>调整晋升阈值：-XX:MaxTenuringThreshold控制对象晋升年龄</p>
<p>优化对象分配：减少大对象创建，及时释放不再使用的对象</p>
<p>选择合适的GC算法：G1、ZGC等并发收集器减少停顿</p>
<p>调整GC参数：-XX:InitiatingHeapOccupancyPercent控制G1触发时机</p>
<p>代码层面优化：避免内存泄漏，合理使用缓存，及时清理集合</p>
<p>监控分析：通过GC日志分析对象生命周期，找出问题根源</p>
<p>分代调优：根据对象存活特征调整分代比例</p>
<p>定期维护：定期清理无用数据，避免内存碎片</p>
<p>核心是减少对象进入老年代的速度和数量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/04/JVM/" data-id="cme8cu34z0001r8qq13qm9ew0" data-title="JVM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/01/Java/" class="article-date">
  <time class="dt-published" datetime="2025-08-01T06:20:28.000Z" itemprop="datePublished">2025-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/01/Java/">Java</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><strong>Java 中有哪 8 种基本数据类型？它们的默认值和占用的空间大小知道不？ 说说这 8 种基本数据类型对应的包装类型。</strong></p>
<p>Java 8种基本数据类型：byte(1字节,0)、short(2字节,0)、int(4字节,0)、long(8字节,0L)、float(4字节,0.0f)、double(8字节,0.0d)、char(2字节,’\u0000’)、boolean(1字节,false)。对应包装类型：Byte、Short、Integer、Long、Float、Double、Character、Boolean，包装类支持null值并提供工具方法。</p>
<p><strong>包装类型的常量池技术了解么？</strong></p>
<p>包装类型常量池技术：Integer、Byte、Short、Long的-128到127范围内的对象会被缓存在常量池中，使用valueOf()或自动装箱时返回同一个对象实例。Character缓存0-127，Boolean缓存true&#x2F;false两个实例。Float和Double不使用常量池。核心作用：节省内存，提高性能，但要注意&#x3D;&#x3D;比较可能的陷阱。</p>
<p><strong>为什么要有包装类型？</strong></p>
<p>包装类型存在的原因：Java是面向对象语言但基本类型不是对象，包装类型让基本类型具备对象特性。主要用途：支持泛型（如List）、提供工具方法（如Integer.parseInt()）、支持null值、用于集合框架、反射操作、数据库映射等需要对象的场景。核心：弥补基本类型无法作为对象使用的限制。</p>
<p><strong>什么是自动拆装箱？原理？</strong></p>
<p>自动拆装箱定义：Java编译器自动在基本类型和包装类型间转换的语法糖。装箱：基本类型→包装类型，调用valueOf()方法。拆箱：包装类型→基本类型，调用xxxValue()方法。</p>
<p>原理：编译时自动插入转换代码，如<code>Integer i = 5</code>编译成<code>Integer i = Integer.valueOf(5)</code>，<code>int j = i</code>编译成<code>int j = i.intValue()</code>。</p>
<p><strong>遇到过自动拆箱引发的 NPE 问题吗？</strong></p>
<p>自动拆箱NPE问题：当包装类型为null时进行自动拆箱会抛出NullPointerException。常见场景：Integer num &#x3D; null; int value &#x3D; num;（拆箱时NPE）、三元运算符中包装类型和基本类型混用、集合中取出null值直接赋给基本类型、数据库查询结果为null时自动拆箱等。解决方案：使用前先判空或使用包装类型接收。</p>
<p><strong>String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</strong></p>
<p>可变性：String不可变（每次操作创建新对象），StringBuffer和StringBuilder可变（在原对象上修改）。</p>
<p>线程安全性：String不可变天然线程安全，StringBuffer线程安全（方法加synchronized），StringBuilder线程不安全。</p>
<p>性能：String频繁操作性能最差（大量对象创建），StringBuilder性能最好，StringBuffer因同步机制性能居中。</p>
<p>String不可变原因：底层char[]数组被final修饰，类被final修饰不可继承，没有提供修改内部状态的方法，保证了字符串常量池、哈希缓存、线程安全等特性。</p>
<p>使用建议：少量操作用String，大量字符串拼接用StringBuilder，多线程环境用StringBuffer。</p>
<p><strong>重载和重写的区别？</strong></p>
<p>发生范围：重载在同一个类中，重写在父子类之间。</p>
<p>参数列表：重载必须不同（个数、类型、顺序），重写必须相同。</p>
<p>返回值类型：重载可以不同，重写必须相同（或协变返回类型）。</p>
<p>异常：重载无限制，重写不能抛出更宽泛的异常。</p>
<p>访问修饰符：重载无限制，重写不能降低访问权限（可以提高）。</p>
<p>发生阶段：重载在编译期确定（静态绑定），重写在运行期确定（动态绑定）。</p>
<p>核心：重载是同名不同参的多个方法，重写是子类对父类方法的重新实现。</p>
<p><strong>&#x3D;&#x3D; 和 equals() 的区别</strong></p>
<p>&#x3D;&#x3D; 操作符：</p>
<ul>
<li>基本类型：比较值是否相等</li>
<li>引用类型：比较内存地址是否相同（是否为同一对象）</li>
</ul>
<p>equals() 方法：</p>
<ul>
<li>只能用于对象：不能判断基本数据类型</li>
<li>未重写时：等价于&#x3D;&#x3D;，比较对象引用（Object默认实现）</li>
<li>重写后：比较对象内容是否相等（如String、Integer等）</li>
</ul>
<p><strong>Java 反射？反射有什么优点&#x2F;缺点？你是怎么理解反射的（为什么框架需要反射）？</strong></p>
<p>Java反射：运行时动态获取类信息、创建对象、调用方法、访问字段的机制。</p>
<p>优点：动态性强（运行时决定行为）、灵活性高（无需编译时确定类型）、支持框架开发（如Spring的依赖注入）。</p>
<p>缺点：性能开销大、破坏封装性、代码可读性差、编译时无法检查错误。</p>
<p>核心理解：反射让框架能够”看懂”你的代码结构，根据配置或注解自动完成对象创建、方法调用等工作，这就是为什么我们只需要写个@Autowired就能自动注入依赖的原因。</p>
<p>本质：用灵活性换取性能，让代码更加动态和可配置。</p>
<p><strong>谈谈对 Java 注解的理解，解决了什么问题？</strong></p>
<p>Java注解理解：一种元数据机制，为代码提供额外信息而不影响程序执行逻辑。</p>
<p>解决的问题：</p>
<ul>
<li>配置简化：用@Autowired替代复杂的XML配置</li>
<li>代码解耦：业务逻辑与配置信息分离</li>
<li>减少样板代码：@Override、@Data等减少重复编写</li>
<li>声明式编程：@Transactional声明事务，无需手写事务代码</li>
</ul>
<p>工作原理：注解本身只是标记，真正的功能由<strong>反射机制</strong>实现。框架在运行时通过反射读取注解信息，然后执行相应的处理逻辑。</p>
<p><strong>Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？</strong></p>
<p>Java泛型：参数化类型，允许在定义类、接口、方法时使用类型参数</p>
<p>泛型的作用 ：</p>
<ul>
<li>类型安全：编译期检测类型错误，避免ClassCastException</li>
<li>消除强制转换：无需手动类型转换</li>
<li>代码复用：一套代码适用多种类型</li>
<li>可读性提升：明确表达代码意图</li>
</ul>
<p>类型擦除：Java泛型是”伪泛型”，编译后泛型信息被擦除，运行时只保留原始类型（Raw Type）。如<code>List&lt;String&gt;</code>编译后变成<code>List</code>，这是为了向后兼容。</p>
<p>泛型限制：</p>
<ul>
<li>不能用基本类型（如<code>List&lt;int&gt;</code>）</li>
<li>不能创建泛型数组</li>
<li>不能在静态上下文中使用类型参数</li>
<li>不能进行instanceof检查</li>
</ul>
<p>常用通配符：</p>
<ul>
<li>? extends T：上界通配符，只能读取</li>
<li>? super T：下界通配符，只能写入</li>
<li>?：无界通配符，表示任意类型</li>
</ul>
<p>核心：泛型提供编译时类型安全，但运行时类型信息丢失，这是Java泛型的特点和局限。 </p>
<p><strong>内部类了解吗？匿名内部类了解吗？</strong></p>
<p><strong>Java内部类</strong>：定义在类内部的类，可以访问外部类的成员变量和方法。</p>
<p><strong>4种内部类类型</strong>：</p>
<p>成员内部类：定义在外部类成员位置，可访问外部类所有成员，需要外部类实例才能创建。</p>
<p>静态内部类：用static修饰，不依赖外部类实例，只能访问外部类静态成员，可直接通过外部类名创建。</p>
<p>局部内部类：定义在方法内部，只能在该方法中使用，可访问外部类成员和方法的final变量。</p>
<p>匿名内部类：没有类名的内部类，通常用于实现接口或继承类的临时对象，常见于事件处理、回调函数等场景。</p>
<p>匿名内部类特点：</p>
<ul>
<li>只能使用一次，无法重复使用</li>
<li>自动持有外部类引用（可能导致内存泄漏）</li>
<li>只能访问final或effectively final的局部变量</li>
<li>常用于Lambda表达式出现前的函数式编程</li>
</ul>
<p>使用场景：回调接口、事件监听器、线程创建等需要临时实现的场合。</p>
<p><strong>BIO,NIO,AIO 有什么区别?</strong></p>
<p>BIO（Blocking I&#x2F;O）：同步阻塞I&#x2F;O，一个连接一个线程，线程在I&#x2F;O操作时阻塞等待。适合连接数少且稳定的场景。</p>
<p>NIO（Non-blocking I&#x2F;O）：同步非阻塞I&#x2F;O，一个线程处理多个连接，使用选择器（Selector）轮询检查I&#x2F;O事件。线程不阻塞但需要主动查询。</p>
<p> AIO（Asynchronous I&#x2F;O）：异步非阻塞I&#x2F;O，I&#x2F;O操作完成后通过回调函数通知，线程无需等待或轮询。</p>
<p>核心区别 ：</p>
<ul>
<li>BIO：阻塞等待，资源消耗大</li>
<li>NIO：非阻塞轮询，适合高并发</li>
<li>AIO：异步回调，真正的异步处理</li>
</ul>
<p>使用场景：BIO适合连接少的传统应用，NIO适合高并发服务器（如Netty），AIO适合连接数多且连接时间长的应用。</p>
<h3 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h3><p><strong>说说 List,Set,Map 三者的区别？</strong></p>
<p>List（列表）：</p>
<ul>
<li>有序：按插入顺序存储，支持索引访问</li>
<li>可重复：允许存储重复元素</li>
<li>存储类型：单一元素</li>
<li>常见实现：ArrayList、LinkedList、Vector</li>
</ul>
<p>Set（集合）：</p>
<ul>
<li>无序&#x2F;有序：HashSet无序，LinkedHashSet&#x2F;TreeSet有序</li>
<li>不可重复：自动去重，基于equals()和hashCode()</li>
<li>存储类型：单一元素</li>
<li>常见实现：HashSet、LinkedHashSet、TreeSet</li>
</ul>
<p>Map（映射）：</p>
<ul>
<li>无序&#x2F;有序：HashMap无序，LinkedHashMap&#x2F;TreeMap有序</li>
<li>键不可重复：key唯一，value可重复</li>
<li>存储类型：键值对（key-value）</li>
<li>常见实现：HashMap、LinkedHashMap、TreeMap、Hashtable</li>
</ul>
<p>核心区别：List关注顺序和重复，Set关注唯一性，Map关注键值映射关系。选择依据：需要索引用List，需要去重用Set，需要映射关系用Map。</p>
<p><strong>List,Set,Map 在 Java 中分别由哪些对应的实现类？底层的数据结构？</strong></p>
<p>List实现类：</p>
<ul>
<li><p>ArrayList：Object[]数组</p>
</li>
<li><p>Vector：Object[]数组</p>
</li>
<li><p>LinkedList：双向链表</p>
</li>
</ul>
<p>Set实现类：</p>
<ul>
<li><p>HashSet：HashMap（数组+链表+红黑树）</p>
</li>
<li><p>LinkedHashSet：LinkedHashMap（数组+链表+红黑树+双向链表）</p>
</li>
<li><p>TreeSet：TreeMap（红黑树）</p>
</li>
</ul>
<p>Map实现类：</p>
<ul>
<li><p>HashMap：数组+链表+红黑树</p>
</li>
<li><p>LinkedHashMap：数组+链表+红黑树+双向链表</p>
</li>
<li><p>TreeMap：红黑树</p>
</li>
<li><p>Hashtable：数组+链表</p>
</li>
<li><p>ConcurrentHashMap：数组+链表+红黑树（分段锁）</p>
</li>
</ul>
<p><strong>有哪些集合是线程不安全的？怎么解决呢？</strong></p>
<p>线程不安全的集合： ArrayList、LinkedList、HashMap、HashSet、TreeMap、TreeSet等。</p>
<p>解决方案：</p>
<ol>
<li><p>使用Collections.synchronizedXXX()包装</p>
</li>
<li><p>使用线程安全的替代类：Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet</p>
</li>
<li><p>使用synchronized关键字或ReentrantLock手动加锁</p>
</li>
</ol>
<p>ArrayList vs Vector：</p>
<ul>
<li><p>ArrayList：非线程安全，性能更好</p>
</li>
<li><p>Vector：线程安全（synchronized），性能较差</p>
</li>
</ul>
<p>HashMap vs ConcurrentHashMap：</p>
<ul>
<li><p>HashMap：非线程安全，数组+链表+红黑树</p>
</li>
<li><p>ConcurrentHashMap：线程安全，分段锁机制（JDK1.7）或CAS+synchronized（JDK1.8）</p>
</li>
</ul>
<p>ConcurrentHashMap线程安全机制：</p>
<ul>
<li><p>JDK1.7：Segment分段锁，每个Segment独立加锁</p>
</li>
<li><p>JDK1.8：CAS+synchronized，锁粒度更细，性能更好</p>
</li>
</ul>
<p><strong>HashMap 查询，删除的时间复杂度</strong></p>
<p>查询时间复杂度：</p>
<ul>
<li><p>无哈希冲突：O(1)</p>
</li>
<li><p>有哈希冲突（链表）：O(n)</p>
</li>
<li><p>链表转红黑树后：O(log n)</p>
</li>
</ul>
<p>删除时间复杂度：</p>
<ul>
<li><p>无哈希冲突：O(1)</p>
</li>
<li><p>有哈希冲突（链表）：O(n)</p>
</li>
<li><p>链表转红黑树后：O(log n)</p>
</li>
</ul>
<p>关键点：</p>
<ul>
<li><p>链表长度≥8且数组长度≥64时，链表转为红黑树</p>
</li>
<li><p>红黑树节点数≤6时，转回链表</p>
</li>
<li><p>理想情况下（哈希分布均匀）为O(1)，最坏情况为O(n)或O(log n)</p>
</li>
</ul>
<p><strong>HashMap 的底层实现</strong></p>
<p>JDK1.8之前：</p>
<ul>
<li><p>数组 + 链表</p>
</li>
<li><p>哈希冲突时用链表存储</p>
</li>
</ul>
<p>JDK1.8之后：</p>
<ul>
<li><p>数组 + 链表 + 红黑树</p>
</li>
<li><p>链表长度≥8且数组长度≥64时，链表转为红黑树</p>
</li>
<li><p>红黑树节点数≤6时，转回链表</p>
</li>
</ul>
<p>核心机制：</p>
<ul>
<li><p>使用hash()方法计算key的哈希值</p>
</li>
<li><p>通过(n-1)&amp;hash确定数组索引位置</p>
</li>
<li><p>链表解决哈希冲突，红黑树优化查询性能</p>
</li>
<li><p>负载因子0.75，超过阈值进行扩容</p>
</li>
</ul>
<p><strong>HashMap 的长度为什么是 2 的幂次方</strong></p>
<p>提高运算效率：</p>
<ul>
<li><p>使用位运算(n-1)&amp;hash代替取模运算hash%n</p>
</li>
<li><p>位运算比取模运算快很多</p>
</li>
</ul>
<p>具体原理：</p>
<ul>
<li><p>当n为2的幂次方时，n-1的二进制全为1</p>
</li>
<li><p>(n-1)&amp;hash等价于hash%n，但效率更高</p>
</li>
<li><p>例如：n&#x3D;16，n-1&#x3D;15(1111)，任何数与1111相与，结果都在0-15范围内</p>
</li>
</ul>
<p><strong>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</strong></p>
<p>HashSet、LinkedHashSet、TreeSet异同：</p>
<p>相同点：</p>
<ul>
<li><p>都实现Set接口，保证元素唯一</p>
</li>
<li><p>都不是线程安全的</p>
</li>
</ul>
<p>不同点：</p>
<p>HashSet：</p>
<ul>
<li><p>底层：HashMap（数组+链表+红黑树）</p>
</li>
<li><p>无序，插入顺序不保证</p>
</li>
<li><p>性能最好</p>
</li>
</ul>
<p>LinkedHashSet：</p>
<ul>
<li><p>底层：LinkedHashMap（数组+链表+红黑树+双向链表）</p>
</li>
<li><p>有序，保持插入顺序</p>
</li>
<li><p>性能略低于HashSet</p>
</li>
</ul>
<p>TreeSet：</p>
<ul>
<li><p>底层：TreeMap（红黑树）</p>
</li>
<li><p>有序，按自然顺序或自定义比较器排序</p>
</li>
<li><p>性能最差，但支持排序功能</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li><p>HashSet：需要快速查找，不关心顺序</p>
</li>
<li><p>LinkedHashSet：需要保持插入顺序</p>
</li>
<li><p>TreeSet：需要排序功能</p>
</li>
</ul>
<p><strong>HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？</strong></p>
<p>HashMap vs Hashtable：</p>
<ul>
<li><p>线程安全： HashMap非线程安全，Hashtable线程安全（synchronized）</p>
</li>
<li><p>性能： HashMap性能更好，Hashtable性能较差</p>
</li>
<li><p>null值： HashMap允许null键值，Hashtable不允许</p>
</li>
<li><p>继承： HashMap继承AbstractMap，Hashtable继承Dictionary</p>
</li>
</ul>
<p>HashMap vs HashSet：</p>
<ul>
<li><p>数据结构： HashMap存储键值对，HashSet存储单个元素</p>
</li>
<li><p>底层实现： HashSet内部使用HashMap实现，只使用key部分</p>
</li>
<li><p>用途： HashMap用于键值对存储，HashSet用于去重集合</p>
</li>
</ul>
<p>HashMap vs TreeMap：</p>
<ul>
<li><p>有序性： HashMap无序，TreeMap有序（红黑树）</p>
</li>
<li><p>性能： HashMap查询O(1)，TreeMap查询O(log n)</p>
</li>
<li><p>底层： HashMap数组+链表+红黑树，TreeMap红黑树</p>
</li>
<li><p>应用： HashMap快速查找，TreeMap需要排序功能</p>
</li>
</ul>
<p><strong>ConcurrentHashMap 和 Hashtable 的区别？</strong></p>
<p>底层数据结构：</p>
<ul>
<li><p>ConcurrentHashMap： 数组+链表+红黑树（JDK1.8）</p>
</li>
<li><p>Hashtable： 数组+链表</p>
</li>
</ul>
<p>线程安全实现方式：</p>
<ul>
<li><p>ConcurrentHashMap：</p>
</li>
<li><p>JDK1.7：Segment分段锁，每个Segment独立加锁</p>
</li>
<li><p>JDK1.8：CAS+synchronized，锁粒度更细</p>
</li>
<li><p>Hashtable： 全局synchronized锁，性能较差</p>
</li>
</ul>
<p>性能差异：</p>
<ul>
<li><p>ConcurrentHashMap： 并发性能好，支持高并发</p>
</li>
<li><p>Hashtable： 并发性能差，所有操作串行执行</p>
</li>
</ul>
<p>null值处理：</p>
<ul>
<li><p>ConcurrentHashMap： 不允许null键值</p>
</li>
<li><p>Hashtable： 不允许null键值</p>
</li>
</ul>
<p>总结： ConcurrentHashMap通过更细粒度的锁机制实现更好的并发性能，而Hashtable使用全局锁导致性能瓶颈。</p>
<p><strong>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</strong></p>
<p>JDK1.7 - Segment分段锁：</p>
<ul>
<li><p>将数据分成多个Segment段</p>
</li>
<li><p>每个Segment独立加锁，不同Segment可并发访问</p>
</li>
<li><p>默认16个Segment，并发度16</p>
</li>
<li><p>使用ReentrantLock实现分段锁</p>
</li>
</ul>
<p>JDK1.8 - CAS+synchronized：</p>
<ul>
<li><p>取消Segment设计，直接使用Node数组</p>
</li>
<li><p>读操作： 无锁，使用volatile保证可见性</p>
</li>
<li><p>写操作：</p>
</li>
<li><p>插入时使用CAS操作</p>
</li>
<li><p>发生冲突时使用synchronized锁住当前Node</p>
</li>
<li><p>扩容： 多线程协助扩容，提高效率</p>
</li>
</ul>
<p>优势对比：</p>
<ul>
<li><p>JDK1.8锁粒度更细： 只锁冲突的Node，而不是整个Segment</p>
</li>
<li><p>性能更好： 并发度更高，减少锁竞争</p>
</li>
<li><p>实现更简单： 代码结构更清晰</p>
</li>
</ul>
<p>核心思想： 通过减少锁的粒度来提高并发性能。</p>
<h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a><strong>Java并发</strong></h3><p><strong>什么是线程和进程?线程与进程的关系,区别及优缺点？</strong></p>
<p>线程和进程：</p>
<p>进程： 程序的一次执行实例，拥有独立内存空间</p>
<p>线程： 进程内的执行单元，共享进程内存空间</p>
<p>JVM角度：</p>
<ul>
<li><p>一个JVM实例 &#x3D; 一个进程</p>
</li>
<li><p>线程共享堆内存，各自有独立栈空间</p>
</li>
</ul>
<p>关系： 进程包含多个线程，线程是进程的执行单元</p>
<p>区别：</p>
<ul>
<li><p>内存： 进程独立，线程共享</p>
</li>
<li><p>开销： 进程大，线程小</p>
</li>
<li><p>通信： 进程需IPC，线程可直接共享</p>
</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>进程： 稳定但开销大</p>
</li>
<li><p>线程： 高效但需同步机制</p>
</li>
</ul>
<p>**为什么要使用多线程呢? **</p>
<p>计算机角度：</p>
<ul>
<li><p>充分利用多核CPU能力</p>
</li>
<li><p>提高CPU利用率，避免单核浪费</p>
</li>
</ul>
<p>项目角度：</p>
<ul>
<li><p>提升系统性能： 并发处理提高吞吐量</p>
</li>
<li><p>响应性更好： 避免长时间阻塞</p>
</li>
<li><p>资源利用： 充分利用系统资源</p>
</li>
</ul>
<p>具体场景：</p>
<ul>
<li><p>Web服务器： 多线程处理并发请求</p>
</li>
<li><p>数据库连接池： 复用连接提高效率</p>
</li>
<li><p>异步处理： 后台任务不阻塞主流程</p>
</li>
<li><p>并行计算： 大数据处理、图像处理等</p>
</li>
</ul>
<p>核心目的： 提高系统并发能力和响应速度</p>
<p>**说说线程的生命周期和状态? **</p>
<p>线程生命周期和状态：</p>
<p>6种状态：</p>
<ul>
<li><p>NEW： 新建状态，线程被创建但未启动</p>
</li>
<li><p>RUNNABLE： 可运行状态，包括就绪和运行中</p>
</li>
<li><p>BLOCKED： 阻塞状态，等待获取锁</p>
</li>
<li><p>WAITING： 等待状态，无限期等待</p>
</li>
<li><p>TIME_WAITING： 超时等待状态，有限期等待</p>
</li>
<li><p>TERMINATED： 终止状态，线程执行完毕</p>
</li>
</ul>
<p>状态转换：</p>
<ul>
<li><p>NEW → RUNNABLE：调用start()</p>
</li>
<li><p>RUNNABLE → BLOCKED：等待synchronized锁</p>
</li>
<li><p>RUNNABLE → WAITING：调用wait()&#x2F;join()</p>
</li>
<li><p>RUNNABLE → TIME_WAITING：调用sleep()&#x2F;wait(timeout)</p>
</li>
<li><p>各种等待状态 → RUNNABLE：被唤醒或超时</p>
</li>
<li><p>RUNNABLE → TERMINATED：执行完毕</p>
</li>
</ul>
<p>注意： JVM层面只有RUNNABLE，操作系统层面分为READY和RUNNING</p>
<p>**什么是线程死锁?如何避免死锁?如何预防和避免线程死锁? **</p>
<p>线程死锁：</p>
<p>多个线程互相持有对方需要的锁，导致所有线程都无法继续执行</p>
<p>死锁条件：</p>
<ul>
<li><p>互斥条件：资源不能被多个线程同时使用</p>
</li>
<li><p>请求与保持：线程持有资源的同时请求其他资源</p>
</li>
<li><p>不剥夺条件：资源不能被强制剥夺</p>
</li>
<li><p>循环等待：存在循环等待链</p>
</li>
</ul>
<p>避免死锁：</p>
<ul>
<li><p>按固定顺序申请锁</p>
</li>
<li><p>一次性申请所有资源</p>
</li>
<li><p>使用可重入锁</p>
</li>
<li><p>设置锁获取超时时间</p>
</li>
</ul>
<p>预防措施：</p>
<ul>
<li><p>避免嵌套锁</p>
</li>
<li><p>使用锁的层次结构</p>
</li>
<li><p>及时释放锁</p>
</li>
<li><p>使用并发工具类</p>
</li>
</ul>
<p>排查方法：</p>
<ul>
<li><p>jstack查看线程状态</p>
</li>
<li><p>分析线程dump信息</p>
</li>
<li><p>使用JProfiler等工具</p>
</li>
</ul>
<p>**synchronized 关键字 **</p>
<p>作用： 保证线程安全，实现互斥访问</p>
<p>底层原理：</p>
<ul>
<li><p>对象头中的Mark Word存储锁信息</p>
</li>
<li><p>通过monitorenter&#x2F;monitorexit字节码指令实现</p>
</li>
<li><p>每个对象都有monitor锁</p>
</li>
</ul>
<p>锁升级流程：</p>
<ul>
<li><p>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p>
</li>
<li><p>偏向锁：减少CAS操作</p>
</li>
<li><p>轻量级锁：自旋等待</p>
</li>
<li><p>重量级锁：阻塞等待</p>
</li>
</ul>
<p>JDK1.6优化：</p>
<ul>
<li><p>引入偏向锁和轻量级锁</p>
</li>
<li><p>自旋锁优化</p>
</li>
<li><p>锁消除和锁粗化</p>
</li>
</ul>
<p>synchronized vs ReentrantLock：</p>
<ul>
<li><p>synchronized自动释放，ReentrantLock手动释放</p>
</li>
<li><p>ReentrantLock支持公平锁、可中断、超时</p>
</li>
<li><p>synchronized性能更好</p>
</li>
</ul>
<p>synchronized vs volatile：</p>
<ul>
<li><p>synchronized保证原子性、可见性、有序性</p>
</li>
<li><p>volatile只保证可见性和有序性</p>
</li>
<li><p>synchronized可以修饰方法、代码块，volatile只能修饰变量</p>
</li>
</ul>
<p>**并发编程的三个重要特性 ** </p>
<p>原子性：</p>
<ul>
<li><p>操作不可分割，要么全部执行，要么全部不执行</p>
</li>
<li><p>synchronized、ReentrantLock保证原子性</p>
</li>
</ul>
<p>可见性：</p>
<ul>
<li><p>一个线程修改共享变量，其他线程能立即看到</p>
</li>
<li><p>volatile、synchronized保证可见性</p>
</li>
</ul>
<p>有序性：</p>
<ul>
<li><p>程序执行顺序符合代码顺序</p>
</li>
<li><p>volatile、synchronized保证有序性</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li><p>synchronized保证三个特性</p>
</li>
<li><p>volatile只保证可见性和有序性</p>
</li>
<li><p>原子性需要锁机制保证</p>
</li>
</ul>
<p>**JMM（Java Memory Model，Java 内存模型）和 happens-before 原则。 **</p>
<p>JMM（Java内存模型）：</p>
<p>定义了Java虚拟机在计算机内存中的工作方式，保证多线程程序的正确性</p>
<p>happens-before原则：</p>
<ul>
<li><p>程序顺序规则： 同一线程内，前面操作happens-before后面操作</p>
</li>
<li><p>监视器锁规则： unlock操作happens-before后续lock操作</p>
</li>
<li><p>volatile规则： volatile写happens-before后续volatile读</p>
</li>
<li><p>线程启动规则： start()happens-before线程内所有操作</p>
</li>
<li><p>线程终止规则： 线程内所有操作happens-before线程终止</p>
</li>
<li><p>中断规则： interrupt()happens-before检测到中断</p>
</li>
<li><p>终结器规则： 构造函数happens-beforefinalize()</p>
</li>
<li><p>传递性： A happens-before B，B happens-before C，则A happens-before C</p>
</li>
</ul>
<p>作用： 保证多线程程序的正确性，避免重排序导致的问题。</p>
<p>**volatile 关键字 **</p>
<p>作用：</p>
<ul>
<li><p>保证可见性：一个线程修改，其他线程立即看到</p>
</li>
<li><p>保证有序性：禁止指令重排序</p>
</li>
</ul>
<p>底层原理：</p>
<ul>
<li><p>内存屏障：LoadLoad、StoreStore、LoadStore、StoreLoad</p>
</li>
<li><p>强制刷新主内存，禁止重排序</p>
</li>
</ul>
<p>与JMM关系：</p>
<ul>
<li><p>遵循happens-before原则</p>
</li>
<li><p>volatile写happens-before后续volatile读</p>
</li>
<li><p>保证内存可见性</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>单例模式双重检查锁</p>
</li>
<li><p>状态标志位</p>
</li>
<li><p>一次性安全发布</p>
</li>
</ul>
<p>限制：</p>
<ul>
<li><p>不保证原子性</p>
</li>
<li><p>不能替代synchronized</p>
</li>
<li><p>只适用于简单场景</p>
</li>
</ul>
<p>**ThreadLocal 关键字 **</p>
<p>作用： 为每个线程提供独立的变量副本，避免线程间数据竞争</p>
<p>底层原理：</p>
<ul>
<li><p>ThreadLocalMap存储线程私有数据</p>
</li>
<li><p>key是ThreadLocal对象，value是存储的值</p>
</li>
<li><p>每个Thread都有独立的ThreadLocalMap</p>
</li>
</ul>
<p>内存泄露问题：</p>
<ul>
<li><p>ThreadLocalMap的key是弱引用，value是强引用</p>
</li>
<li><p>线程不结束，value不会被回收</p>
</li>
<li><p>解决：使用完调用remove()方法</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>用户信息传递</p>
</li>
<li><p>数据库连接</p>
</li>
<li><p>事务上下文</p>
</li>
<li><p>日志MDC</p>
</li>
</ul>
<p>注意事项：</p>
<ul>
<li><p>及时清理，避免内存泄露</p>
</li>
<li><p>线程池中使用要特别注意</p>
</li>
<li><p>父子线程数据隔离</p>
</li>
</ul>
<p>**线程池 **</p>
<p>核心参数：</p>
<ul>
<li><p>corePoolSize：核心线程数</p>
</li>
<li><p>maximumPoolSize：最大线程数</p>
</li>
<li><p>keepAliveTime：空闲线程存活时间</p>
</li>
<li><p>workQueue：工作队列</p>
</li>
<li><p>threadFactory：线程工厂</p>
</li>
<li><p>handler：拒绝策略</p>
</li>
</ul>
<p>执行流程：</p>
<ol>
<li><p>核心线程数未满，创建新线程</p>
</li>
<li><p>核心线程数已满，任务放入队列</p>
</li>
<li><p>队列已满，创建新线程（不超过最大线程数）</p>
</li>
<li><p>达到最大线程数，执行拒绝策略</p>
</li>
</ol>
<p>拒绝策略：</p>
<ul>
<li><p>AbortPolicy：抛出异常</p>
</li>
<li><p>CallerRunsPolicy：调用者线程执行</p>
</li>
<li><p>DiscardPolicy：丢弃任务</p>
</li>
<li><p>DiscardOldestPolicy：丢弃最旧任务</p>
</li>
</ul>
<p>线程池类型：</p>
<ul>
<li><p>FixedThreadPool：固定线程数</p>
</li>
<li><p>CachedThreadPool：可缓存线程</p>
</li>
<li><p>ScheduledThreadPool：定时任务</p>
</li>
<li><p>SingleThreadExecutor：单线程</p>
</li>
</ul>
<p>线程池大小设置：</p>
<ul>
<li><p>CPU密集型：CPU核数+1</p>
</li>
<li><p>IO密集型：CPU核数<em>2</em></p>
</li>
</ul>
<p>**ReentrantLock 和 AQS **</p>
<p>ReentrantLock特性：</p>
<ul>
<li><p>可重入锁：同一线程可多次获取</p>
</li>
<li><p>支持公平锁和非公平锁</p>
</li>
<li><p>可中断、可超时</p>
</li>
<li><p>手动释放锁</p>
</li>
</ul>
<p>AQS（AbstractQueuedSynchronizer）：</p>
<ul>
<li><p>抽象队列同步器</p>
</li>
<li><p>提供锁的框架实现</p>
</li>
<li><p>维护CLH队列和state状态</p>
</li>
</ul>
<p>ReentrantLock基于AQS实现：</p>
<ul>
<li><p>继承AQS，重写tryAcquire&#x2F;tryRelease</p>
</li>
<li><p>state表示锁状态（0未锁定，&gt;0已锁定）</p>
</li>
<li><p>公平锁按FIFO顺序获取锁</p>
</li>
<li><p>非公平锁直接尝试获取锁</p>
</li>
</ul>
<p>核心机制：</p>
<ul>
<li><p>CAS操作修改state</p>
</li>
<li><p>失败则加入队列等待</p>
</li>
<li><p>自旋+阻塞等待唤醒</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li><p>比synchronized更灵活</p>
</li>
<li><p>支持多种锁特性</p>
</li>
<li><p>性能相当</p>
</li>
</ul>
<p>**乐观锁和悲观锁的区别 **</p>
<p>悲观锁：</p>
<ul>
<li><p>认为冲突会经常发生</p>
</li>
<li><p>先加锁再操作</p>
</li>
<li><p>实现：synchronized、ReentrantLock</p>
</li>
<li><p>适用：写多读少场景</p>
</li>
</ul>
<p>乐观锁：</p>
<ul>
<li><p>认为冲突很少发生</p>
</li>
<li><p>先操作再检查冲突</p>
</li>
<li><p>实现：CAS、版本号</p>
</li>
<li><p>适用：读多写少场景</p>
</li>
</ul>
<p>性能对比：</p>
<ul>
<li><p>悲观锁：开销大，并发度低</p>
</li>
<li><p>乐观锁：开销小，并发度高</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>悲观锁：数据库行锁、文件锁</p>
</li>
<li><p>乐观锁：库存扣减、计数器</p>
</li>
</ul>
<p>总结： 悲观锁适合冲突频繁场景，乐观锁适合冲突较少场景</p>
<p>**CAS 了解么？原理？什么是 ABA 问题？ABA 问题怎么解决？ **</p>
<p>原理：</p>
<ul>
<li><p>比较并交换，原子操作</p>
</li>
<li><p>比较内存值与期望值，相等则更新</p>
</li>
<li><p>失败则重试或放弃</p>
</li>
</ul>
<p>ABA问题：</p>
<ul>
<li><p>A→B→A，值没变但过程变了</p>
</li>
<li><p>可能导致数据不一致</p>
</li>
</ul>
<p>ABA解决方案：</p>
<ul>
<li><p>版本号：每次修改版本号+1</p>
</li>
<li><p>时间戳：记录修改时间</p>
</li>
<li><p>AtomicStampedReference：带版本号的引用</p>
</li>
</ul>
<p>实际应用：</p>
<ul>
<li><p>ConcurrentHashMap：CAS+synchronized</p>
</li>
<li><p>AtomicInteger：volatile+CAS</p>
</li>
<li><p>自旋锁实现</p>
</li>
<li><p>无锁数据结构</p>
</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：无锁，性能好</p>
</li>
<li><p>缺点：自旋消耗CPU，ABA问题</p>
</li>
</ul>
<p>**Atomic 原子类 **</p>
<p>分类：</p>
<ul>
<li><p>基本类型：AtomicInteger、AtomicLong、AtomicBoolean</p>
</li>
<li><p>引用类型：AtomicReference</p>
</li>
<li><p>数组类型：AtomicIntegerArray</p>
</li>
</ul>
<p>原理： volatile+CAS实现，保证原子性和可见性</p>
<p>常用方法：</p>
<ul>
<li><p>get()&#x2F;set()：获取&#x2F;设置</p>
</li>
<li><p>compareAndSet()：CAS操作</p>
</li>
<li><p>incrementAndGet()：自增</p>
</li>
</ul>
<p>使用场景： 计数器、状态标志、并发累加</p>
<p>优势： 比synchronized性能更好，适合简单原子操作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/01/Java/" data-id="cme8cu3520004r8qq916800fh" data-title="Java" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-布隆过滤器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T09:02:07.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="布隆过滤器结构"><a href="#布隆过滤器结构" class="headerlink" title="布隆过滤器结构"></a>布隆过滤器结构</h4><p>布隆过滤器是一个基于数组和哈希函数散列元素的结构，很像HashMap的哈希桶。布隆过滤器可以用于检测一个元素是否在集合中。它的优点是空间效率和查询时间比一般算法要好很多，但也有一定概率的误判性。<em>如HashMap出现哈希碰撞💥</em></p>
<hr>
<h4 id="布隆过滤器实现"><a href="#布隆过滤器实现" class="headerlink" title="布隆过滤器实现"></a>布隆过滤器实现</h4><p>布隆过滤器的实现条件包括可以存放二进制元素的 BitSet 以及多样性的哈希计算函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashGenerator.HashGroup[] GROUPS = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>.HashGroup[]&#123;HashGenerator.HashGroup.G1, HashGenerator.HashGroup.G2, HashGenerator.HashGroup.G3, HashGenerator.HashGroup.G4&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitSet bits;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> HashGenerator[] generators;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的元素存放都经过多样的哈希计算存放到 BitSet 中，这样可以尽可能的分散元素，减少误判性。</p>
<ul>
<li><em><strong>哈希函数</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG1</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">        hash = Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % (seed * size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG2</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">7397</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % seed * (size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG3</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash += c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % (seed * size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG4</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs(seed * (size - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里提供了四种哈希计算的方式，相当于每一个哈希计算都是一次扰动处理。一个元素的存放可以经过四次哈希，尽量让元素值做到散列。</li>
</ul>
<ul>
<li><em><strong>构建容器</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span>[] seeds)</span> &#123;</span><br><span class="line">    bits = <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    generators = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>[seeds.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seeds.length; i++) &#123;</span><br><span class="line">        generators[i] = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>(size, seeds[i], GROUPS[i % GROUPS.length]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数根据所需创建的容器大小和哈希种子来初始化布隆过滤器。</li>
</ul>
<ul>
<li><em><strong>添加元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> generator.doHash(value);</span><br><span class="line">        bits.set(hash, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素时按照元素初始化时的哈希计算种类，获取哈希并存放。</li>
</ul>
<ul>
<li><em><strong>比对元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        ret = ret &amp;&amp; bits.get(generator.doHash(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>比对元素时用的是同一类哈希计算方式，并且把这些哈希值 <code>&amp;&amp;</code> 计算。<em>用N个比特位置记录一个值更准确</em></li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>布隆过滤器的使用场景？</strong></li>
</ul>
<p><strong>布隆过滤器使用场景</strong>：缓存穿透防护（避免查询不存在的数据）、垃圾邮件过滤、网页爬虫URL去重、数据库查询优化（预先判断数据是否存在）、分布式系统中的重复数据检测、黑名单快速判断等需要快速判断元素是否”可能存在”的场景。</p>
<p><strong>核心优势</strong>：空间效率极高，查询速度快，但存在误判（可能存在但实际不存在）。</p>
<ul>
<li><strong>布隆过滤器的实现原理和方式？</strong></li>
</ul>
<p><strong>布隆过滤器实现原理</strong>：使用位数组和多个哈希函数，插入元素时将其通过k个哈希函数映射到位数组的k个位置并置1，查询时检查这k个位置是否都为1。</p>
<p><strong>实现方式</strong>：初始化m位的位数组全为0，选择k个独立哈希函数，插入时设置对应位为1，查询时检查所有对应位。</p>
<p><strong>核心特点</strong>：不存在假阴性（存在的一定返回存在），但有假阳性（可能误判不存在的为存在），无法删除元素。</p>
<ul>
<li><strong>如何提高布隆过滤器的准确性？</strong></li>
</ul>
<p><strong>增加位数组大小</strong>：更大的m值降低哈希冲突概率。<strong>优化哈希函数数量</strong>：选择最优的k值（约为m&#x2F;n*ln2）平衡误判率。<strong>使用高质量哈希函数</strong>：选择分布均匀、冲突少的哈希算法。<strong>控制元素数量</strong>：避免超过设计容量导致误判率急剧上升。</p>
<p><strong>核心公式</strong>：误判率≈(1-e^(-kn&#x2F;m))^k，通过调整m、k、n三个参数优化准确性。</p>
<ul>
<li><strong>有哪些中哈希计算方式？</strong></li>
</ul>
<p><strong>除法散列</strong>：h(k) &#x3D; k mod m，简单但容易聚集。<strong>乘法散列</strong>：h(k) &#x3D; ⌊m(kA mod 1)⌋，A为常数。<strong>平方取中法</strong>：对关键字平方后取中间几位。<strong>折叠法</strong>：将关键字分段相加。</p>
<p><strong>字符串哈希</strong>：djb2、sdbm、FNV等算法。<strong>密码学哈希</strong>：MD5、SHA-1、SHA-256等安全性更高。<strong>现代哈希</strong>：MurmurHash、CityHash等高性能算法。</p>
<p><strong>选择原则</strong>：根据数据特点和性能要求选择合适的哈希函数。</p>
<ul>
<li><strong>都有哪些类型的布隆过滤器实现？<em>Google 开源的 Guava 中自带的布隆过滤器、Redis 中的布隆过滤器</em></strong></li>
</ul>
<p><strong>标准布隆过滤器</strong>：经典实现，不支持删除操作。<strong>计数布隆过滤器</strong>：用计数器替代位数组，支持删除但占用更多空间。<strong>可扩展布隆过滤器</strong>：动态增加容量避免误判率上升。</p>
<p><strong>Guava布隆过滤器</strong>：Google开源，支持自定义误判率和容量，提供便捷API。<strong>Redis布隆过滤器</strong>：通过RedisBloom模块实现，支持分布式场景，提供bf.add和bf.exists命令。</p>
<p><strong>其他实现</strong>：Cassandra、HBase等数据库内置布隆过滤器优化查询性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" data-id="cme8cu35b000ur8qq6l5bb3fc" data-title="布隆过滤器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%9B%BE/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T07:35:44.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%9B%BE/">图</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="图的数据结构"><a href="#图的数据结构" class="headerlink" title="图的数据结构"></a>图的数据结构</h4><p>图（Graph）结构是一种比树结构复杂的非线性的数据结构，图在实际生活中的例子非常多，比如；地铁线路网、微信好友关系链、计算机中的状态执行等，都可以抽象成图的结构。</p>
<p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E) &#x3D; 【G表示图、V表示顶点个数、E表示边的个数】。图的数据结构是多对多关系，就像你的微信好友可能也是我的微信好友，且相互交叉对应。与之对应的是树，树是1对多关系，所以树也是一种特殊的没有闭环的图。</p>
<p>按照图<strong>是否有方向</strong>和<strong>是否有权重</strong>可以分为一下4类组合；</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%9B%BE%E7%A7%8D%E7%B1%BB.png" alt="图种"></p>
<ul>
<li>顶点：图中的任意节点都算作顶点，图中任意两个顶点间都可能存在连接，如果没有顶点间没有连线则称为空图。</li>
<li>无向图：图中任意两个顶点间都没有指向，则称这样的图为无向图。</li>
<li>有向图：图中任意两个顶点间都有指向边，则称这样的图为有向图。</li>
<li>无权重：图中任意两个顶点间的连线，没有权重值，则无权重。</li>
<li>有权重：图中任意两个顶点间的连线，包含权重值，则有权重。</li>
</ul>
<hr>
<h4 id="图的结构实现"><a href="#图的结构实现" class="headerlink" title="图的结构实现"></a>图的结构实现</h4><p>图的结构实现可以基于数组、链表和红黑树实现，也因此将使用数组实现的图称为邻接矩阵，链表和红黑树实现的图称为邻接表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的矩阵【数组】</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"><span class="comment">// 图的矩阵【链表】</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"><span class="comment">// 图的矩阵【红黑树】</span></span><br><span class="line"><span class="keyword">private</span> TreeSet&lt;Integer&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>图的数据存放可以使用 int 数组、LinkedList 链表、TreeSet 红黑树等方式存储。</p>
<ul>
<li><strong>邻接矩阵【数组】</strong></li>
</ul>
<ol>
<li><strong>无向图&amp;无权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x][y] = <span class="number">1</span>;</span><br><span class="line">    table[y][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，对称插入节点。例如：0→1、1→0，两个方向都插入元素。</li>
</ul>
<ol start="2">
<li><strong>有向图&amp;有权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x][y] = weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，插入单向节点，节点值为权重值。例如：0→2，权重值是4。</li>
</ul>
<ul>
<li><em><strong>邻接表【链表】</strong></em></li>
</ul>
<ol>
<li><strong>无向图&amp;无权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y&#125;);</span><br><span class="line">    table[y].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;x&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，无向无权重直接对称插入元素即可。</li>
</ul>
<ol start="2">
<li><strong>有向图&amp;有权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，有方向，有权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y, weight&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，有方向有权重则只插入单个指向，并需要通过数组或者对象的方式记录权重值。</li>
</ul>
<ul>
<li><em><strong>遍历</strong></em></li>
</ul>
<p>图的最终实现是通过 TreeSet 红黑树的方式，这样即节省空间，又能提高元素的索引和遍历效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">private</span> TreeSet&lt;Integer&gt;[] table;</span><br></pre></td></tr></table></figure>

<ol>
<li>深度遍历，不断地向下探测。广度遍历横行探测。</li>
<li>当有权重时候，则深度和广度会按照权重进行选择优先遍历的顺序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        order.add(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                queue.add(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 深度优先，前序遍历</span></span><br><span class="line">    pre.add(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : graph.adj(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先，后序遍历</span></span><br><span class="line">    post.add(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>图的使用场景是什么？</strong></li>
</ul>
<p><strong>图的使用场景</strong>：社交网络（好友关系）、地图导航（最短路径）、网络拓扑（路由算法）、任务调度（依赖关系）、推荐系统（关联分析）、电路设计、生物信息学（基因网络）、搜索引擎（网页链接）、交通规划等需要表示复杂关系和连接的问题。</p>
<p><strong>核心优势</strong>：能够自然表达实体间的多对多关系和复杂网络结构。</p>
<ul>
<li><strong>图有的分类？</strong></li>
</ul>
<p><strong>按边的方向</strong>：有向图（边有方向）、无向图（边无方向）。</p>
<p><strong>按边的权重</strong>：带权图（边有权值）、无权图（边无权值）。</p>
<p><strong>按连通性</strong>：连通图（任意两点可达）、非连通图、强连通图（有向图中任意两点互相可达）。</p>
<ul>
<li><strong>图怎么存放权重值？</strong></li>
</ul>
<p><strong>邻接矩阵</strong>：二维数组matrix[i][j]存储从顶点i到顶点j的边权重，无边时存储无穷大或特殊值。</p>
<p><strong>邻接表</strong>：每个顶点维护一个列表，存储(目标顶点, 权重)的键值对。</p>
<p><strong>边列表</strong>：直接存储所有边的信息，每条边包含(起点, 终点, 权重)三元组。</p>
<p><strong>核心选择</strong>：稠密图用邻接矩阵，稀疏图用邻接表，算法处理用边列表。</p>
<ul>
<li><strong>图的广度遍历</strong></li>
</ul>
<p><strong>图的广度遍历（BFS）</strong>：从起始顶点开始，先访问所有相邻顶点，再逐层向外扩展访问。<strong>实现方式</strong>：使用队列存储待访问顶点，用visited数组标记已访问节点避免重复。<strong>遍历顺序</strong>：按距离起点的层次逐层访问，同层顶点访问顺序取决于邻接表顺序。</p>
<p><strong>核心特点</strong>：能找到最短路径（无权图），时间复杂度O(V+E)。</p>
<ul>
<li><strong>图的深度遍历</strong></li>
</ul>
<p><strong>图的深度遍历（DFS）</strong>：从起始顶点开始，沿着一条路径尽可能深入，直到无法继续时回溯到上一个顶点，继续探索其他路径。<strong>实现方式</strong>：使用栈（或递归）存储待访问顶点，用visited数组标记已访问节点避免重复。<strong>遍历特点</strong>：优先深度探索，能检测环路和连通分量。</p>
<p><strong>核心特点</strong>：适合路径搜索和拓扑排序，时间复杂度O(V+E)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%9B%BE/" data-id="cme8cu358000hr8qqhsxjb8kk" data-title="图" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-并查集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T03:25:50.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="并查集数据结构"><a href="#并查集数据结构" class="headerlink" title="并查集数据结构"></a>并查集数据结构</h5><p>并查集数据结构（也称为联合-查找数据结构或合并-查找集）基于数组实现的一种跟踪元素的数据结构，这些元素被划分为多个不相交（非重叠）的子集。</p>
<p>它提供了近乎恒定的时间操作（以逆阿克曼函数为界）来添加新集合、合并现有集合以及确定元素是否在同一个集合中。除了推荐算法、好友关系链、族谱等，并查集在 <code>Kruskal</code>的算法中扮演着关键角色，用于寻找无向边加权图的最小生成树。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/4.png"></p>
<p>为了尽可能少的检索次数到根元素，在01：粗暴合并的基础上，有了基于数量、排序的合并方式，同时还包括可以压缩路径。这样再索引到根节点的时间复杂度就又降低了。</p>
<hr>
<h4 id="并查集结构实现"><a href="#并查集结构实现" class="headerlink" title="并查集结构实现"></a>并查集结构实现</h4><p>并查集的实现非常巧妙，只基于数组就可以实现出一个树的效果（基于数组实现的还有二叉堆也是树的结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line">	  <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 数量【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] count;</span><br><span class="line">	<span class="comment">// 排序【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集的元素存放在数组中，通过对数组元素的下标索引指向其他元素，构成一棵树。count 数量、rank 排序，是用于对并查集合并元素时的优化处理。</p>
<ul>
<li><em><strong>默认合并 - union(1, 8)</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E9%BB%98%E8%AE%A4%E5%90%88%E5%B9%B6.png" alt="默认合并"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查索引是否越界，抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> items[i];</span><br><span class="line">    <span class="comment">// 返回索引i对应的根节点值（集合标识符）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentVal</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 获取parent节点所属集合的根节点值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childVal</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="comment">// 获取child节点所属集合的根节点值</span></span><br><span class="line">    <span class="keyword">if</span> (parentVal == childVal) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果两个节点已经在同一集合中，直接返回</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i ++)&#123;</span><br><span class="line">        <span class="comment">// 遍历整个数组</span></span><br><span class="line">        <span class="keyword">if</span> (items[i] == childVal)&#123;</span><br><span class="line">            <span class="comment">// 找到所有属于child集合的节点</span></span><br><span class="line">            items[i] = parentVal;</span><br><span class="line">            <span class="comment">// 将它们的根节点值改为parent集合的根节点值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成两个集合的合并操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>union 是合并元素的方法，两个入参意思是把 child 指向的根节点，指向 parent 指向的根节点。后面所有案例中 union 方法属性字段意思相同。</li>
<li>find 找到元素对应的根节点值，之后使用 union 方法对 items 数组内的元素全部遍历，把所有值等于 child 的节点，都替换为 parent 节点值。</li>
<li>每次合并都for循环比较耗时，所以后续做了一些列的优化。</li>
</ul>
<ul>
<li><em><strong>粗暴合并</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E7%B2%97%E6%9A%B4%E5%90%88%E5%B9%B6.png" alt="粗暴合并"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 找到元素的根节点，当i == item[i]，就是自己指向自己，这个节点就是根节点</span></span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 孩子节点值替换为父节点值</span></span><br><span class="line">    items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>find 循环找到置顶节点的最终根节点，例如；8 → 6、6 → 6，那么说明8的根节点是6，因为6自己指向自己了，它就是根节点。</li>
<li>union 将 8 指向的根节点 6，更换为 1 指向的根节点 0。最终替换完就是 6 → 0，那么8的根节点有也是0了。</li>
<li>这样虽然减少了每次 for 循环更新，但粗暴的合并会对节点的索引带来一定的复杂度。所以还需要继续优化。</li>
</ul>
<ul>
<li><em><strong>压缩路径</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8E%8B%E7%BC%A9%E8%B7%AF%E5%BE%84.png" alt="压缩路径"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        items[i] = items[items[i]];</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[parentRootIdx] &gt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[parentRootIdx] &lt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[parentRootIdx] = items[childRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">        rank[parentRootIdx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(8, 1) 在rank合并下，压缩路径长度。</p>
<ul>
<li>这里的 union 方法与<code>4. 排序合并</code>相比并没有变化，变化的地方主要在 find 过程中压缩路径。</li>
<li>find 基于查找根元素时，对当前元素值对应的父节点值，替换给当前元素。减少一级路径，做到压缩路径的目的。</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>并查集叙述？</strong></li>
</ul>
<p><strong>并查集</strong>：用于处理不相交集合的合并和查询问题的数据结构。<strong>核心操作</strong>：find（查找元素所属集合）和union（合并两个集合）。<strong>主要实现</strong>：数组存储每个元素的父节点，通过路径压缩和按秩合并优化性能。<strong>应用场景</strong>：连通性问题、最小生成树算法、动态连通性查询等。<strong>时间复杂度</strong>：优化后接近O(1)。</p>
<ul>
<li><strong>并查集的使用场景？</strong></li>
</ul>
<p><strong>并查集使用场景</strong>：判断图的连通性、检测无向图中的环、最小生成树算法（Kruskal）、社交网络中的朋友圈划分、像素连通区域检测、网络连接状态判断、动态连通性查询等需要快速合并和查找集合关系的问题。</p>
<p><strong>核心特点</strong>：擅长处理”分组”和”连通性”相关的动态问题。</p>
<ul>
<li><strong>并查集怎么合并元素？</strong></li>
</ul>
<p><strong>并查集合并元素</strong>：通过union操作将两个元素所属的集合合并。<strong>具体步骤</strong>：1）找到两个元素各自的根节点；2）如果根节点相同则已在同一集合；3）否则将一个根节点指向另一个根节点，完成合并。<strong>优化策略</strong>：按秩合并（小树挂到大树下）避免树过深，提高后续查找效率。</p>
<ul>
<li><strong>并查集合并元素的优化策略？</strong></li>
</ul>
<p><strong>按秩合并</strong>：将深度小的树挂到深度大的树下，避免树过深影响查找效率。</p>
<p><strong>路径压缩</strong>：在find操作中将路径上所有节点直接指向根节点，减少后续查找深度。</p>
<p><strong>两者结合</strong>：使union和find操作的时间复杂度接近O(1)，大幅提升整体性能。</p>
<ul>
<li><strong>如何压缩路径？</strong></li>
</ul>
<p><strong>路径压缩</strong>：在find操作中，将查找路径上的所有节点直接指向根节点。<strong>实现方式</strong>：递归查找根节点时，在返回过程中将当前节点的父指针直接指向根节点，使树变得扁平化。<strong>效果</strong>：后续对同一路径上节点的查找操作时间复杂度接近O(1)。</p>
<p><strong>代码核心</strong>：<code>parent[x] = find(parent[x])</code>，递归压缩路径。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/" data-id="cme8cu35d0014r8qqelxoggzy" data-title="并查集" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-红黑树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T08:59:18.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="红黑树数据结构"><a href="#红黑树数据结构" class="headerlink" title="红黑树数据结构"></a>红黑树数据结构</h4><p>建立在 BST 二叉搜索树的基础上，AVL、2-3树、红黑树都是自平衡二叉树（统称B-树）。但相比于AVL树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。也正因红黑树在插入和删除时不需要太多的平衡操作，也让它成为；Java中HashMap的元素碰撞后的转换、Linux的CFS进行调度算法、多路复用技术的Epoll等各类底层的数据结构实现。</p>
<p>红黑树的五条定义：</p>
<ol>
<li><strong>每个节点不是红色就是黑色。</strong><ul>
<li>黑色决定平衡，红色不决定平衡。这对应了2-3树中一个节点内可以存放1~2个节点。</li>
</ul>
</li>
<li><strong>根是黑色的。</strong><ul>
<li>这条规则有时会被省略。由于根总是可以从红色变为黑色，但不一定相反，因此该规则对分析几乎没有影响。</li>
</ul>
</li>
<li><strong>所有叶子 (NIL) 都是黑色的。</strong><ul>
<li>这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。</li>
</ul>
</li>
<li><strong>如果一个节点是红色的，那么它的两个子节点都是黑色的。</strong><ul>
<li>通常这条规则也叫不会有连续的红色节点。这体现在2-3树中，一个节点最多临时会有3个节点，中间是黑色节点，左右是红色节点。2-3树中出现这样的情况后，会进行节点迁移，中间节点成为父节点，左右节点成为子节点。</li>
</ul>
</li>
<li><strong>从给定节点到其任何后代 NIL 节点的每条路径都包含相同数量的黑色节点。</strong><ul>
<li>对应2-3树中，每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="红黑树结构实现"><a href="#红黑树结构实现" class="headerlink" title="红黑树结构实现"></a>红黑树结构实现</h4><p>基于 BST 二叉搜索树的基础上，AVL树添加了树高作为计算平衡因子的条件，那么红黑树也需要添加一个新的颜色属性，用于处理平衡操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">// 红黑树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.RED;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>相比于AVL树通过左右旋转平衡树高，红黑树则是在2-3树的基础上，只对黑色节点维护树高，所以它会使用到染色和左右旋来对树高调衡。<em>染色与左右旋相比，减少了平衡操作</em></p>
<ul>
<li><em><strong>左倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="左倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.right;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span> (uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current = grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>右倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="右倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.left;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span>(uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current= grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>左旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次左旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%B7%A6%E6%97%8B.png" alt="一次左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的左侧小图，新增的节点5导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点4提起来，而对应红黑树则需要先进行染色，待操作的节点4为黑色，两个孩子节点为红色。</li>
<li>最后是把节点3进行一次左旋操作，完成树的平衡。对应步骤3中的左侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>右旋+左旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要右旋+左旋的情况，在AVL树中有同样的场景。本身树需要左旋操作，但整体分支树节点偏左，此时需要右旋调整树结构再左旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%2B%E5%B7%A6.png" alt="右左"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏左↙，先右旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.left)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateRight(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点4以后，4↙5 结构偏左，需要先进行右旋调衡树结构，再进行左旋。其实这个时候再进行的左旋就和上面一次左旋操作一致了。</li>
</ul>
<ul>
<li><em><strong>右旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次右旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的右侧小图，新增的节点1导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点2提起来，而对应红黑树则需要先进行染色，待操作的节点2为黑色，两个孩子节点为红色。</li>
<li>最后是把节点2进行一次右旋操作，完成树的平衡。对应步骤3中的右侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>左旋+右旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要左旋+右旋的情况，在AVL树中有同样的场景。本身树需要右旋操作，但整体分支树节点偏右，此时需要左旋调整树结构再右旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%2B%E5%8F%B3.png" alt="左右"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏右↘，先左旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.right)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateLeft(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点2以后，1↘2 结构偏右，需要先进行左旋调衡树结构，再进行右旋。其实这个时候再进行的右旋就和上面一次右旋操作一致了。</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>红黑树都有哪些使用场景？</strong></li>
</ul>
<p><strong>红黑树使用场景</strong>：Java TreeMap&#x2F;TreeSet、C++ STL的map&#x2F;set、Linux内核进程调度、数据库索引结构、编译器符号表、内存管理	器、高性能缓存系统等需要稳定O(log n)性能的场景。</p>
<p><strong>核心优势</strong>：相比AVL树旋转次数少，相比普通BST保证平衡，适合频繁插入删除的应用。</p>
<ul>
<li><strong>相比于BST树，红黑树有什么用途？</strong></li>
</ul>
<p><strong>红黑树相比BST的用途</strong>：解决BST最坏情况退化成链表的问题，通过着色和旋转机制保证树的近似平衡，确保查找、插入、删除操作始终维持O(log n)时间复杂度，避免性能恶化。</p>
<p><strong>关键作用</strong>：防止恶意数据攻击导致的性能退化，提供稳定可预期的性能保证。</p>
<ul>
<li><strong>B-树是什么意思，都包括哪些？</strong></li>
</ul>
<p><strong>B-树定义</strong>：多路平衡搜索树，每个节点可存储多个键值和子节点，所有叶子节点在同一层。</p>
<p><strong>主要类型</strong>：B树（内部节点和叶子节点都存数据）、B+树（只有叶子节点存数据，内部节点只存索引）、B*树（B+树的优化版本，节点利用率更高）。</p>
<p><strong>核心用途</strong>：数据库索引、文件系统，因为减少磁盘I&#x2F;O次数，适合大数据量存储。</p>
<ul>
<li><strong>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</strong></li>
</ul>
<p><strong>染色情况</strong>：父节点和叔叔节点都是红色时，将父节点、叔叔节点染黑，祖父节点染红。</p>
<p><strong>左旋情况</strong>：父节点是红色、叔叔节点是黑色，且新节点是父节点的右子节点时。</p>
<p><strong>左旋+右旋情况</strong>：父节点是红色、叔叔节点是黑色，新节点是父节点的左子节点，但父节点是祖父节点的右子节点时（右-左型不平衡）。</p>
<p><strong>核心原则</strong>：通过染色、旋转保持红黑树的5个性质不被破坏。</p>
<ul>
<li><strong>红黑树的特点是什么？</strong></li>
</ul>
<p><strong>红黑树特点</strong>：节点非红即黑、根节点是黑色、红节点的子节点必须是黑色、从任一节点到叶子节点的路径包含相同数量的黑节点、叶子节点（NIL）是黑色。</p>
<p><strong>核心优势</strong>：自平衡、最坏情况仍保证O(log n)性能、相比AVL树旋转次数少、插入删除效率高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" data-id="cme8cu35e001er8qq2huxa4k4" data-title="红黑树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2-3树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/2-3%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T07:57:52.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/2-3%E6%A0%91/">2-3树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="2-3树数据结构"><a href="#2-3树数据结构" class="headerlink" title="2-3树数据结构"></a>2-3树数据结构</h4><p>2–3树是一种树型数据结构，由约翰·霍普克洛夫特于1970年发明。它通过在一个节点存放1-2个元素来平衡树高。从而也使2-3树存在2叉节点和3叉节点。</p>
<p><img src="https://bugstack.cn/images/article/algorithm/tree-23-01.png?raw=true" alt="img"></p>
<p>这里要提到一点，在BST二叉搜索树可能退化成链表的基础上。引出了自平衡二叉树，也就是包括上一章实现的AVL树和Java API HashMap中用到的红黑树，它们都属于BalancedTree，也统称为B树，平衡的意思。</p>
<p>而本章实现的2-3树也是一种简单的平衡树，其中每个具有子节点（内部节点）的节点要么有两个子节点（2 节点）和一个数据元素，要么有三个子节点（3 节点）和两个数据元素。另外 2-3 树是3阶B 树，2-3-4 树是4阶B树。</p>
<hr>
<h4 id="2-3树结构实现"><a href="#2-3树结构实现" class="headerlink" title="2-3树结构实现"></a>2-3树结构实现</h4><ul>
<li><em><strong>节点定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node_2_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="comment">// 孩子</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3[] children;</span><br><span class="line">    <span class="comment">// 父亲【非必须】</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3 parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node_2_3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">this</span>.number = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="built_in">this</span>.number - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.items[idx] &lt; e) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = <span class="built_in">this</span>.items[idx];</span><br><span class="line">            --idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = e;</span><br><span class="line">        ++<span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2-3树的几点元素需要包括；一个数组的元素集合、元素的序号、孩子元素。因为一个节点最多可临时放入3个元素，那么就会最多有4个孩子元素，所以孩子元素也是一个数组并且在构造函数中按照4个元素进行初始化。</li>
<li>由于本身2-3树插入元素的开始阶段，并不是直接创建一个新的节点，而是在初始化的数组空间中存入元素。所以在节点中提供了一个插入元素的方法 insert 来处理新增元素。</li>
<li>另外2-3树的节点类，还提供了一个方便查询的方法。包括：获取左边元素、中间元素、右边元素，以及最小值、最大值和判断是否有孩子节点。这些内容可以源码。</li>
</ul>
<ul>
<li><em><strong>拆分节点</strong></em></li>
</ul>
<p>当一个节点内有3个元素的时候，就要发起拆分东西，拆分的过程分为；</p>
<ol>
<li>对3个节点的中间节点，插入到父节点上。</li>
<li>剩余2个节点创建出新的节点。</li>
<li>建立父节点和新创建的2个节点间关系。</li>
</ol>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8B%86%E5%88%86%E8%8A%82%E7%82%B9.png" alt="拆分节点"></p>
<ol>
<li>插入父节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">split</span><span class="params">(Node_2_3 node, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    parent.insert(node.getMiddleItem());</span><br><span class="line">    </span><br><span class="line">    Node_2_3[] newNodes = <span class="built_in">this</span>.triangle(node);</span><br><span class="line">    <span class="built_in">this</span>.replaceChild(parent, node, newNodes[<span class="number">0</span>], newNodes[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整个2-3树拆分的过程就是在 split 这个方法里，第一步解决了是否有父节点，没有则创建。</li>
<li>之后将原节点的中间值插入到父节点中。接下来的操作就是拆分新节点和更换孩子节点建立新连接。</li>
</ul>
<ol start="2">
<li>拆分新节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3[] triangle(Node_2_3 node) &#123;</span><br><span class="line">    Node_2_3[] newNodes = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">2</span>];</span><br><span class="line">    newNodes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">0</span>]);</span><br><span class="line">    newNodes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!node.isLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 左孩子</span></span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">0</span>] = node.children[<span class="number">0</span>];</span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">1</span>] = node.children[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 右孩子</span></span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">0</span>] = node.children[<span class="number">2</span>];</span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">1</span>] = node.children[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于传递进来的节点，将节点的左右孩子创建新节点，如果这个孩子节点还有分支节点，则一并更新。</li>
</ul>
<ol start="3">
<li>建立新连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceChild</span><span class="params">(Node_2_3 parent, Node_2_3 oldChild, Node_2_3 child01, Node_2_3 child02)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChild == parent.children[<span class="number">0</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = parent.children[<span class="number">1</span>];</span><br><span class="line">        parent.children[<span class="number">1</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">0</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldChild == parent.children[<span class="number">1</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">1</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">2</span>] = child01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>建立新连接需要判断这个节点 oldChild 是父节点的左、中、右，之后进行依次的更换。</li>
<li>如拆分节点的介绍图中，用到的就是 <code>parent.children[1] = child02;parent.children[0] = child01;</code> 两步操作过程。</li>
</ul>
<ul>
<li><em><strong>新增节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录元素</span></span><br><span class="line">    elementList.add(e);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = insert(e, root);</span><br><span class="line">        <span class="keyword">if</span> (root.number == <span class="number">3</span>) &#123;</span><br><span class="line">            root = split(root, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.isLeaf()) &#123;</span><br><span class="line">        parent.insert(e);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node_2_3</span> <span class="variable">child</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent.number == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; parent.getMiddleItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getRight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.number == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.split(child, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增节点的过程就比较简单了，一种是使用递归找到可以插入的位置，另外一种就是 where 循环。我们再BST、AVL两种数据结构种都是用了 where 循环。</li>
<li>在2-3树中 insert 方法递归到对应的插入位置后，开始插入元素。当插入元素结束后判断这个节点是否已经达到了3个节点，如果是则进行拆分。<em>拆分就调用了上面的步骤</em></li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>2-3树的数据结构描述</strong></li>
</ul>
<p>​	每个节点包含1-2个键值和2-3个子节点指针，2节点存储1个键，3节点存储2个键（按大小排序），所有叶子节点在同一层，满足搜索树性质。</p>
<ul>
<li><strong>2-3树一个节点最多可以存放几个元素</strong></li>
</ul>
<p>​	2-3树一个节点最多存放2个元素（3节点包含2个键值）。</p>
<ul>
<li><strong>2-3树插入节点时间复杂度</strong></li>
</ul>
<p>​	O(log n)，因为树高度为O(log n)且插入时最多向上分裂到根节点。</p>
<ul>
<li><strong>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></strong></li>
</ul>
<p>​	中间元素上移到父节点，左右元素分裂成两个2节点，不需要旋转操作，只需要节点分裂和元素上移。</p>
<ul>
<li><strong>2-3树，你能手写一下吗？</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node23</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];        <span class="comment">// 最多2个键</span></span><br><span class="line">    Node23[] children = <span class="keyword">new</span> <span class="title class_">Node23</span>[<span class="number">3</span>]; <span class="comment">// 最多3个子节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">keyCount</span> <span class="operator">=</span> <span class="number">0</span>;               <span class="comment">// 当前键的数量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> <span class="literal">true</span>;          <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is2Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is3Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/2-3%E6%A0%91/" data-id="cme8cu34v0000r8qq403jhh6a" data-title="2-3树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-平衡二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T02:30:39.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="AVL树数据结构"><a href="#AVL树数据结构" class="headerlink" title="AVL树数据结构"></a>AVL树数据结构</h4><p>AVL 自平衡二叉树的出现，其目的在于解决二叉搜索树退化成链表的问题。当我们向BST二叉搜索树顺序存入<code>1、2、3、4、5、6、7</code>个元素时，它会退化成一条链表，因而失去树查询的时间复杂度，所以我们需要AVL树平衡树高。如图所示</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/AVL%E6%A0%91.png" alt="AVL"></p>
<p>那么AVL树是怎么平衡树高的呢？</p>
<p>当二叉树的左右分支树高差不为1时，需要进行左旋或者右旋，来调衡树高。这有点像开车的时候，如果车头偏左就往右打方向盘，车头偏右就往左打方向盘是一个道理。那这个方向盘(左旋、右旋)是怎么打的呢，主要分以下四种情况；</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/4.png" alt="4"></p>
<ul>
<li>节点树高：以节点4为说明，最长的左右分支节点个数，就是节点4的最大树高。这里节点4左右孩子节点最长路径都为2，所以它的树高为2。同理可计算其他节点树高。</li>
<li>平衡因子：通过当前节点的左右子节点作差计算平衡因子，之后AVL树通过平衡因子，定义了什么时候进行左旋和右旋。</li>
</ul>
<hr>
<h4 id="AVL树代码实现"><a href="#AVL树代码实现" class="headerlink" title="AVL树代码实现"></a>AVL树代码实现</h4><p>对于 AVL 树的实现与 BST 二叉搜索树相比，在树的节点定义上多了一个树高的属性。也有些AVL树使用的是平衡因子的属性，就是通过树高计算后的结果。树节点代码结构如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>图解左旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E6%97%8B.png" alt="左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.right;              <span class="comment">// 保存右子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 右子节点继承原节点的父节点</span></span><br><span class="line">  </span><br><span class="line">    node.right = temp.left;              <span class="comment">// 原节点的右子树变为右子节点的左子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;            <span class="comment">// 如果新的右子树不为空</span></span><br><span class="line">        node.right.parent = node;        <span class="comment">// 设置新右子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    temp.left = node;                    <span class="comment">// 原节点成为右子节点的左子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为右子节点</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>左旋的作用，相当于通过向上迁移树高差大于1的右子节点来降低树高的操作。</li>
<li>通过节点4拿到父节点2和右子节点5，把父节点2和右子节点5建立关联</li>
<li>节点5的左子节点，相当于是大于4的那么一个值，只不过这里不体现。那么这个节点5的左子节点，应该被迁移到节点4的右子节点上。</li>
<li>整理节点5的关系，左子节点为4。左子节点4的父节点为5</li>
<li>如果说迁移上来的节点5无父节点，那么它就是父节点 root &#x3D; temp</li>
<li>迁移上来的节点5，找到原节点4是对应父节点的左子节点还是右子节点，对应的设置节点5的左右位置</li>
</ol>
<h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>图解右旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateRight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;               <span class="comment">// 保存左子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 左子节点继承原节点的父节点</span></span><br><span class="line">    </span><br><span class="line">    node.left = temp.right;              <span class="comment">// 原节点的左子树变为左子节点的右子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;             <span class="comment">// 如果新的左子树不为空</span></span><br><span class="line">        node.left.parent = node;         <span class="comment">// 设置新左子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp.right = node;                   <span class="comment">// 原节点成为左子节点的右子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为左子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="左旋-右旋-右旋-左旋"><a href="#左旋-右旋-右旋-左旋" class="headerlink" title="左旋 + 右旋&#x2F;右旋 + 左旋"></a>左旋 + 右旋&#x2F;右旋 + 左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (factor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node.left);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.left = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (factor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node.right);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.right = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>AVL 树平衡因子怎么计算？</strong></li>
</ul>
<p>​	AVL树平衡因子 &#x3D; 左子树高度 - 右子树高度，取值范围[-1,0,1]，超出范围需旋转调整。</p>
<ul>
<li><strong>AVL 树左旋操作的目的是什么？</strong></li>
</ul>
<p>​	将右偏重的子树通过左旋转换为平衡状态，消除右子树过高导致的不平衡。</p>
<ul>
<li><strong>AVL 树左旋操作的流程是什么？</strong></li>
</ul>
<p>​	将右子节点提升为新根，原根节点下沉为新根的左子节点，原右子节点的左子树转移给原根节点作为右子树，最后重新连接所有父子关	系。</p>
<ul>
<li><strong>AVL 树什么情况下要左旋+右旋？</strong></li>
</ul>
<p>​	当左子树的右子树过高导致左-右型不平衡时，先对左子节点左旋，再对根节点右旋。</p>
<ul>
<li><strong>AVL 树的插入和读取的时间复杂度？</strong></li>
</ul>
<p>​	插入和查找都是O(log n)，因为AVL树通过自平衡保证树高度始终为O(log n)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cme8cu35c0011r8qqcky93wxi" data-title="平衡二叉树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二分搜索树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T08:42:25.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">二分搜索树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="二叉搜索树的数据结构"><a href="#二叉搜索树的数据结构" class="headerlink" title="二叉搜索树的数据结构"></a>二叉搜索树的数据结构</h4><p>二叉搜索树（Binary Search Tree），也称二叉查找树。如果你看见有序二叉树（Ordered Binary tree）、排序二叉树（Sorted Binary Tree）那么说的都是一个东西。</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>二叉搜索树也是一颗没有经过调衡的基础性数据结构，在一定概率上它完成有可能退化成链表，也就是从近似O(logn)的时间复杂度退化到O(n)。关于二叉搜索树的平衡解决方案，包括；AVL树、2-3树、红黑树等。</p>
<hr>
<h4 id="二叉搜索树结构实现"><a href="#二叉搜索树结构实现" class="headerlink" title="二叉搜索树结构实现"></a>二叉搜索树结构实现</h4><p>二叉搜索树是整个树结构中最基本的树，同时也是树这个体系中实现起来最容易的数据结构。但之所以要使用基于二叉搜索树之上的其他树结构，主要是因为使用数据结构就是对数据的存放和读取。那么为了提高吞吐效率，则需要尽可能的平衡元素的排序，体现在树上则需要进行一些列操作，所以会有不同的结构树实现。</p>
<ul>
<li><em><strong>树枝定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer value;</span><br><span class="line"><span class="keyword">public</span> Node parent;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于组成一颗树的节点，则需要包括；值和与之关联的三角结构，一个父节点、两个孩子节点。如果是AVL树还需要树高，红黑树还需要染色标记。</li>
</ul>
<ul>
<li><em><strong>插入节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引出待插入元素位置，也就是插入到哪个父元素下</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">search</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (search != <span class="literal">null</span> &amp;&amp; search.value != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = search;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; search.value) &#123;</span><br><span class="line">            search = search.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            search = search.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (parent.value &gt; newNode.value) &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断插入元素时候是否有树根，没有则会把当前节点创建出一颗树根来。</li>
<li>如果当前树是有树根的，则对插入元素与当前树进行一个节点遍历操作，找到元素可以插入的索引位置 parent（挂到这个父节点下）。也就是 search 搜索过程。</li>
<li>最后就是插入元素，通过给插入值创建一个 Node 节点，并绑定它的父元素，以及把新元素挂到索引到的 parent 节点下。</li>
</ul>
<ul>
<li><em><strong>索引节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.value != <span class="literal">null</span> &amp;&amp; node.value != e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; node.value) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值查找的过程，就是对二叉搜索树的遍历，不断的循环节点，按照节点值的左右匹配，找出最终相当的值节点。</li>
</ul>
<ul>
<li><em><strong>删除节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">delNode</span> <span class="operator">=</span> search(e);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == delNode) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> delete(delNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node delNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (delNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为删除的节点，有2个孩子节点，这个时候找到这条分支下，最左侧做小的节点。用它来替换删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">miniNode</span> <span class="operator">=</span> getMiniNode(delNode.right);</span><br><span class="line">        <span class="keyword">if</span> (miniNode.parent != delNode) &#123;</span><br><span class="line">            <span class="comment">// 交换位置，用miniNode右节点，替换miniNode</span></span><br><span class="line">            transplant(miniNode, miniNode.right);</span><br><span class="line">            <span class="comment">// 把miniNode 提升父节点，设置右子树并进行挂链。替代待删节点</span></span><br><span class="line">            miniNode.right = delNode.right;</span><br><span class="line">            miniNode.right.parent = miniNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置，删除节点和miniNode 可打印测试观察；System.out.println(this);</span></span><br><span class="line">        transplant(delNode, miniNode);</span><br><span class="line">        <span class="comment">// 把miniNode 提升到父节点，设置左子树并挂链</span></span><br><span class="line">        miniNode.left = delNode.left;</span><br><span class="line">        miniNode.left.parent = miniNode;</span><br><span class="line">        result = miniNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">transplant</span><span class="params">(Node delNode, Node addNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除元素是左/右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delNode.parent.left == delNode) &#123;</span><br><span class="line">        delNode.parent.left = addNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delNode.parent.right = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addNode) &#123;</span><br><span class="line">        addNode.parent = delNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有右子树</strong></p>
<ul>
<li>直接用右子树替换删除节点</li>
</ul>
<p><strong>只有左子树</strong></p>
<ul>
<li>直接用左子树替换删除节点</li>
</ul>
<p><strong>有两个子树</strong></p>
<ul>
<li>找到右子树中的最小节点（后继节点）</li>
<li>用后继节点替换删除节点</li>
<li>处理后继节点的原位置</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li>
</ul>
<p>​	基本性质：左子树 &lt; 根节点 &lt; 右子树，中序遍历有序，平均O(log n)操作复杂度。</p>
<p>​	核心操作：查找（比较递归）、插入（找位置插入）、删除（三种情况：0&#x2F;1&#x2F;2个子节点）。</p>
<p>​	主要变体：AVL树（自平衡）、红黑树（着色平衡）、B树（多路）、线索二叉树（利用空指针）。核心目标都是避免退化成链表，保持O(log n)性能。</p>
<ul>
<li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li>
</ul>
<p>​	平均情况：插入、删除、查找都是 O(log n)。最坏情况：当树退化成链表时（如顺序插入），所有操作变成 O(n)。关键：平衡二叉树通过自平衡保证最坏情况也是 O(log n)。</p>
<ul>
<li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li>
</ul>
<p>​	核心思路 ：找到右子树中的最小节点（后继节点）来替换被删除节点。</p>
<p>​	具体步骤：1）找到右子树最左侧的最小节点；2）如果最小节点不是右子树根，先将其右子树移植到原位置；3）用最小节点替换被删除节点，重新连接左右子树和父节点关系。</p>
<p>​	原理：右子树最小节点值刚好大于左子树所有值且小于右子树其余值，替换后仍保持BST性质。</p>
<ul>
<li><strong>二叉搜索树的节点都包括了哪些信息</strong></li>
</ul>
<p>​	基本信息：节点值（key&#x2F;data）、左子节点指针、右子节点指针。可选信息：父节点指针（便于向上遍历和删除操作）。扩展信息：节点颜色（红黑树）、平衡因子（AVL树）、子树大小等附加属性。</p>
<p>​	核心结构：<code>&#123;value, left, right, parent&#125;</code>，其中parent可选但常用。</p>
<ul>
<li><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></li>
</ul>
<p>​	核心问题：普通二叉搜索树在最坏情况下会退化成链表，时间复杂度从O(log n)恶化到O(n)。<strong>红黑树优势</strong>：通过着色和旋转机制保证树的近似平衡，确保最坏情况下仍是O(log n)。<strong>HashMap场景</strong>：哈希冲突时链表过长影响性能，红黑树能稳定保证查找效率，避免恶意构造数据导致性能攻击。</p>
<p>​	简单说：红黑树是自平衡的BST，防止极端情况下性能退化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" data-id="cme8cu357000fr8qq7m27gijq" data-title="二分搜索树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" rel="tag">创建文章</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" style="font-size: 10px;">创建文章</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">工具学习</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E9%87%8D%E7%82%B9/" style="font-size: 16.67px;">重点</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.33px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/12/MySOL/">MySOL</a>
          </li>
        
          <li>
            <a href="/2025/08/04/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/2025/08/01/Java/">Java</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%9B%BE/">图</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>