<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/01/Java/" class="article-date">
  <time class="dt-published" datetime="2025-08-01T06:20:28.000Z" itemprop="datePublished">2025-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/01/Java/">Java</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><strong>Java 中有哪 8 种基本数据类型？它们的默认值和占用的空间大小知道不？ 说说这 8 种基本数据类型对应的包装类型。</strong></p>
<p>Java 8种基本数据类型：byte(1字节,0)、short(2字节,0)、int(4字节,0)、long(8字节,0L)、float(4字节,0.0f)、double(8字节,0.0d)、char(2字节,’\u0000’)、boolean(1字节,false)。对应包装类型：Byte、Short、Integer、Long、Float、Double、Character、Boolean，包装类支持null值并提供工具方法。</p>
<p><strong>包装类型的常量池技术了解么？</strong></p>
<p>包装类型常量池技术：Integer、Byte、Short、Long的-128到127范围内的对象会被缓存在常量池中，使用valueOf()或自动装箱时返回同一个对象实例。Character缓存0-127，Boolean缓存true&#x2F;false两个实例。Float和Double不使用常量池。核心作用：节省内存，提高性能，但要注意&#x3D;&#x3D;比较可能的陷阱。</p>
<p><strong>为什么要有包装类型？</strong></p>
<p>包装类型存在的原因：Java是面向对象语言但基本类型不是对象，包装类型让基本类型具备对象特性。主要用途：支持泛型（如List）、提供工具方法（如Integer.parseInt()）、支持null值、用于集合框架、反射操作、数据库映射等需要对象的场景。核心：弥补基本类型无法作为对象使用的限制。</p>
<p><strong>什么是自动拆装箱？原理？</strong></p>
<p>自动拆装箱定义：Java编译器自动在基本类型和包装类型间转换的语法糖。装箱：基本类型→包装类型，调用valueOf()方法。拆箱：包装类型→基本类型，调用xxxValue()方法。</p>
<p>原理：编译时自动插入转换代码，如<code>Integer i = 5</code>编译成<code>Integer i = Integer.valueOf(5)</code>，<code>int j = i</code>编译成<code>int j = i.intValue()</code>。</p>
<p><strong>遇到过自动拆箱引发的 NPE 问题吗？</strong></p>
<p>自动拆箱NPE问题：当包装类型为null时进行自动拆箱会抛出NullPointerException。常见场景：Integer num &#x3D; null; int value &#x3D; num;（拆箱时NPE）、三元运算符中包装类型和基本类型混用、集合中取出null值直接赋给基本类型、数据库查询结果为null时自动拆箱等。解决方案：使用前先判空或使用包装类型接收。</p>
<p><strong>String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</strong></p>
<p>可变性：String不可变（每次操作创建新对象），StringBuffer和StringBuilder可变（在原对象上修改）。</p>
<p>线程安全性：String不可变天然线程安全，StringBuffer线程安全（方法加synchronized），StringBuilder线程不安全。</p>
<p>性能：String频繁操作性能最差（大量对象创建），StringBuilder性能最好，StringBuffer因同步机制性能居中。</p>
<p>String不可变原因：底层char[]数组被final修饰，类被final修饰不可继承，没有提供修改内部状态的方法，保证了字符串常量池、哈希缓存、线程安全等特性。</p>
<p>使用建议：少量操作用String，大量字符串拼接用StringBuilder，多线程环境用StringBuffer。</p>
<p><strong>重载和重写的区别？</strong></p>
<p>发生范围：重载在同一个类中，重写在父子类之间。</p>
<p>参数列表：重载必须不同（个数、类型、顺序），重写必须相同。</p>
<p>返回值类型：重载可以不同，重写必须相同（或协变返回类型）。</p>
<p>异常：重载无限制，重写不能抛出更宽泛的异常。</p>
<p>访问修饰符：重载无限制，重写不能降低访问权限（可以提高）。</p>
<p>发生阶段：重载在编译期确定（静态绑定），重写在运行期确定（动态绑定）。</p>
<p>核心：重载是同名不同参的多个方法，重写是子类对父类方法的重新实现。</p>
<p><strong>&#x3D;&#x3D; 和 equals() 的区别</strong></p>
<p>&#x3D;&#x3D; 操作符：</p>
<ul>
<li>基本类型：比较值是否相等</li>
<li>引用类型：比较内存地址是否相同（是否为同一对象）</li>
</ul>
<p>equals() 方法：</p>
<ul>
<li>只能用于对象：不能判断基本数据类型</li>
<li>未重写时：等价于&#x3D;&#x3D;，比较对象引用（Object默认实现）</li>
<li>重写后：比较对象内容是否相等（如String、Integer等）</li>
</ul>
<p><strong>Java 反射？反射有什么优点&#x2F;缺点？你是怎么理解反射的（为什么框架需要反射）？</strong></p>
<p>Java反射：运行时动态获取类信息、创建对象、调用方法、访问字段的机制。</p>
<p>优点：动态性强（运行时决定行为）、灵活性高（无需编译时确定类型）、支持框架开发（如Spring的依赖注入）。</p>
<p>缺点：性能开销大、破坏封装性、代码可读性差、编译时无法检查错误。</p>
<p>核心理解：反射让框架能够”看懂”你的代码结构，根据配置或注解自动完成对象创建、方法调用等工作，这就是为什么我们只需要写个@Autowired就能自动注入依赖的原因。</p>
<p>本质：用灵活性换取性能，让代码更加动态和可配置。</p>
<p><strong>谈谈对 Java 注解的理解，解决了什么问题？</strong></p>
<p>Java注解理解：一种元数据机制，为代码提供额外信息而不影响程序执行逻辑。</p>
<p>解决的问题：</p>
<ul>
<li>配置简化：用@Autowired替代复杂的XML配置</li>
<li>代码解耦：业务逻辑与配置信息分离</li>
<li>减少样板代码：@Override、@Data等减少重复编写</li>
<li>声明式编程：@Transactional声明事务，无需手写事务代码</li>
</ul>
<p>工作原理：注解本身只是标记，真正的功能由<strong>反射机制</strong>实现。框架在运行时通过反射读取注解信息，然后执行相应的处理逻辑。</p>
<p><strong>Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？</strong></p>
<p>Java泛型：参数化类型，允许在定义类、接口、方法时使用类型参数</p>
<p>泛型的作用 ：</p>
<ul>
<li>类型安全：编译期检测类型错误，避免ClassCastException</li>
<li>消除强制转换：无需手动类型转换</li>
<li>代码复用：一套代码适用多种类型</li>
<li>可读性提升：明确表达代码意图</li>
</ul>
<p>类型擦除：Java泛型是”伪泛型”，编译后泛型信息被擦除，运行时只保留原始类型（Raw Type）。如<code>List&lt;String&gt;</code>编译后变成<code>List</code>，这是为了向后兼容。</p>
<p>泛型限制：</p>
<ul>
<li>不能用基本类型（如<code>List&lt;int&gt;</code>）</li>
<li>不能创建泛型数组</li>
<li>不能在静态上下文中使用类型参数</li>
<li>不能进行instanceof检查</li>
</ul>
<p>常用通配符：</p>
<ul>
<li>? extends T：上界通配符，只能读取</li>
<li>? super T：下界通配符，只能写入</li>
<li>?：无界通配符，表示任意类型</li>
</ul>
<p>核心：泛型提供编译时类型安全，但运行时类型信息丢失，这是Java泛型的特点和局限。 </p>
<p><strong>内部类了解吗？匿名内部类了解吗？</strong></p>
<p><strong>Java内部类</strong>：定义在类内部的类，可以访问外部类的成员变量和方法。</p>
<p><strong>4种内部类类型</strong>：</p>
<p>成员内部类：定义在外部类成员位置，可访问外部类所有成员，需要外部类实例才能创建。</p>
<p>静态内部类：用static修饰，不依赖外部类实例，只能访问外部类静态成员，可直接通过外部类名创建。</p>
<p>局部内部类：定义在方法内部，只能在该方法中使用，可访问外部类成员和方法的final变量。</p>
<p>匿名内部类：没有类名的内部类，通常用于实现接口或继承类的临时对象，常见于事件处理、回调函数等场景。</p>
<p>匿名内部类特点：</p>
<ul>
<li>只能使用一次，无法重复使用</li>
<li>自动持有外部类引用（可能导致内存泄漏）</li>
<li>只能访问final或effectively final的局部变量</li>
<li>常用于Lambda表达式出现前的函数式编程</li>
</ul>
<p>使用场景：回调接口、事件监听器、线程创建等需要临时实现的场合。</p>
<p><strong>BIO,NIO,AIO 有什么区别?</strong></p>
<p>BIO（Blocking I&#x2F;O）：同步阻塞I&#x2F;O，一个连接一个线程，线程在I&#x2F;O操作时阻塞等待。适合连接数少且稳定的场景。</p>
<p>NIO（Non-blocking I&#x2F;O）：同步非阻塞I&#x2F;O，一个线程处理多个连接，使用选择器（Selector）轮询检查I&#x2F;O事件。线程不阻塞但需要主动查询。</p>
<p> AIO（Asynchronous I&#x2F;O）：异步非阻塞I&#x2F;O，I&#x2F;O操作完成后通过回调函数通知，线程无需等待或轮询。</p>
<p>核心区别 ：</p>
<ul>
<li>BIO：阻塞等待，资源消耗大</li>
<li>NIO：非阻塞轮询，适合高并发</li>
<li>AIO：异步回调，真正的异步处理</li>
</ul>
<p>使用场景：BIO适合连接少的传统应用，NIO适合高并发服务器（如Netty），AIO适合连接数多且连接时间长的应用。</p>
<h3 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h3><p><strong>说说 List,Set,Map 三者的区别？</strong></p>
<p>List（列表）：</p>
<ul>
<li>有序：按插入顺序存储，支持索引访问</li>
<li>可重复：允许存储重复元素</li>
<li>存储类型：单一元素</li>
<li>常见实现：ArrayList、LinkedList、Vector</li>
</ul>
<p>Set（集合）：</p>
<ul>
<li>无序&#x2F;有序：HashSet无序，LinkedHashSet&#x2F;TreeSet有序</li>
<li>不可重复：自动去重，基于equals()和hashCode()</li>
<li>存储类型：单一元素</li>
<li>常见实现：HashSet、LinkedHashSet、TreeSet</li>
</ul>
<p>Map（映射）：</p>
<ul>
<li>无序&#x2F;有序：HashMap无序，LinkedHashMap&#x2F;TreeMap有序</li>
<li>键不可重复：key唯一，value可重复</li>
<li>存储类型：键值对（key-value）</li>
<li>常见实现：HashMap、LinkedHashMap、TreeMap、Hashtable</li>
</ul>
<p>核心区别：List关注顺序和重复，Set关注唯一性，Map关注键值映射关系。选择依据：需要索引用List，需要去重用Set，需要映射关系用Map。</p>
<p><strong>List,Set,Map 在 Java 中分别由哪些对应的实现类？底层的数据结构？</strong></p>
<p>List实现类：</p>
<ul>
<li><p>ArrayList：Object[]数组</p>
</li>
<li><p>Vector：Object[]数组</p>
</li>
<li><p>LinkedList：双向链表</p>
</li>
</ul>
<p>Set实现类：</p>
<ul>
<li><p>HashSet：HashMap（数组+链表+红黑树）</p>
</li>
<li><p>LinkedHashSet：LinkedHashMap（数组+链表+红黑树+双向链表）</p>
</li>
<li><p>TreeSet：TreeMap（红黑树）</p>
</li>
</ul>
<p>Map实现类：</p>
<ul>
<li><p>HashMap：数组+链表+红黑树</p>
</li>
<li><p>LinkedHashMap：数组+链表+红黑树+双向链表</p>
</li>
<li><p>TreeMap：红黑树</p>
</li>
<li><p>Hashtable：数组+链表</p>
</li>
<li><p>ConcurrentHashMap：数组+链表+红黑树（分段锁）</p>
</li>
</ul>
<p><strong>有哪些集合是线程不安全的？怎么解决呢？</strong></p>
<p>线程不安全的集合： ArrayList、LinkedList、HashMap、HashSet、TreeMap、TreeSet等。</p>
<p>解决方案：</p>
<ol>
<li><p>使用Collections.synchronizedXXX()包装</p>
</li>
<li><p>使用线程安全的替代类：Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet</p>
</li>
<li><p>使用synchronized关键字或ReentrantLock手动加锁</p>
</li>
</ol>
<p>ArrayList vs Vector：</p>
<ul>
<li><p>ArrayList：非线程安全，性能更好</p>
</li>
<li><p>Vector：线程安全（synchronized），性能较差</p>
</li>
</ul>
<p>HashMap vs ConcurrentHashMap：</p>
<ul>
<li><p>HashMap：非线程安全，数组+链表+红黑树</p>
</li>
<li><p>ConcurrentHashMap：线程安全，分段锁机制（JDK1.7）或CAS+synchronized（JDK1.8）</p>
</li>
</ul>
<p>ConcurrentHashMap线程安全机制：</p>
<ul>
<li><p>JDK1.7：Segment分段锁，每个Segment独立加锁</p>
</li>
<li><p>JDK1.8：CAS+synchronized，锁粒度更细，性能更好</p>
</li>
</ul>
<p><strong>HashMap 查询，删除的时间复杂度</strong></p>
<p>查询时间复杂度：</p>
<ul>
<li><p>无哈希冲突：O(1)</p>
</li>
<li><p>有哈希冲突（链表）：O(n)</p>
</li>
<li><p>链表转红黑树后：O(log n)</p>
</li>
</ul>
<p>删除时间复杂度：</p>
<ul>
<li><p>无哈希冲突：O(1)</p>
</li>
<li><p>有哈希冲突（链表）：O(n)</p>
</li>
<li><p>链表转红黑树后：O(log n)</p>
</li>
</ul>
<p>关键点：</p>
<ul>
<li><p>链表长度≥8且数组长度≥64时，链表转为红黑树</p>
</li>
<li><p>红黑树节点数≤6时，转回链表</p>
</li>
<li><p>理想情况下（哈希分布均匀）为O(1)，最坏情况为O(n)或O(log n)</p>
</li>
</ul>
<p><strong>HashMap 的底层实现</strong></p>
<p>JDK1.8之前：</p>
<ul>
<li><p>数组 + 链表</p>
</li>
<li><p>哈希冲突时用链表存储</p>
</li>
</ul>
<p>JDK1.8之后：</p>
<ul>
<li><p>数组 + 链表 + 红黑树</p>
</li>
<li><p>链表长度≥8且数组长度≥64时，链表转为红黑树</p>
</li>
<li><p>红黑树节点数≤6时，转回链表</p>
</li>
</ul>
<p>核心机制：</p>
<ul>
<li><p>使用hash()方法计算key的哈希值</p>
</li>
<li><p>通过(n-1)&amp;hash确定数组索引位置</p>
</li>
<li><p>链表解决哈希冲突，红黑树优化查询性能</p>
</li>
<li><p>负载因子0.75，超过阈值进行扩容</p>
</li>
</ul>
<p><strong>HashMap 的长度为什么是 2 的幂次方</strong></p>
<p>提高运算效率：</p>
<ul>
<li><p>使用位运算(n-1)&amp;hash代替取模运算hash%n</p>
</li>
<li><p>位运算比取模运算快很多</p>
</li>
</ul>
<p>具体原理：</p>
<ul>
<li><p>当n为2的幂次方时，n-1的二进制全为1</p>
</li>
<li><p>(n-1)&amp;hash等价于hash%n，但效率更高</p>
</li>
<li><p>例如：n&#x3D;16，n-1&#x3D;15(1111)，任何数与1111相与，结果都在0-15范围内</p>
</li>
</ul>
<p><strong>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</strong></p>
<p>HashSet、LinkedHashSet、TreeSet异同：</p>
<p>相同点：</p>
<ul>
<li><p>都实现Set接口，保证元素唯一</p>
</li>
<li><p>都不是线程安全的</p>
</li>
</ul>
<p>不同点：</p>
<p>HashSet：</p>
<ul>
<li><p>底层：HashMap（数组+链表+红黑树）</p>
</li>
<li><p>无序，插入顺序不保证</p>
</li>
<li><p>性能最好</p>
</li>
</ul>
<p>LinkedHashSet：</p>
<ul>
<li><p>底层：LinkedHashMap（数组+链表+红黑树+双向链表）</p>
</li>
<li><p>有序，保持插入顺序</p>
</li>
<li><p>性能略低于HashSet</p>
</li>
</ul>
<p>TreeSet：</p>
<ul>
<li><p>底层：TreeMap（红黑树）</p>
</li>
<li><p>有序，按自然顺序或自定义比较器排序</p>
</li>
<li><p>性能最差，但支持排序功能</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li><p>HashSet：需要快速查找，不关心顺序</p>
</li>
<li><p>LinkedHashSet：需要保持插入顺序</p>
</li>
<li><p>TreeSet：需要排序功能</p>
</li>
</ul>
<p><strong>HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？</strong></p>
<p>HashMap vs Hashtable：</p>
<ul>
<li><p>线程安全： HashMap非线程安全，Hashtable线程安全（synchronized）</p>
</li>
<li><p>性能： HashMap性能更好，Hashtable性能较差</p>
</li>
<li><p>null值： HashMap允许null键值，Hashtable不允许</p>
</li>
<li><p>继承： HashMap继承AbstractMap，Hashtable继承Dictionary</p>
</li>
</ul>
<p>HashMap vs HashSet：</p>
<ul>
<li><p>数据结构： HashMap存储键值对，HashSet存储单个元素</p>
</li>
<li><p>底层实现： HashSet内部使用HashMap实现，只使用key部分</p>
</li>
<li><p>用途： HashMap用于键值对存储，HashSet用于去重集合</p>
</li>
</ul>
<p>HashMap vs TreeMap：</p>
<ul>
<li><p>有序性： HashMap无序，TreeMap有序（红黑树）</p>
</li>
<li><p>性能： HashMap查询O(1)，TreeMap查询O(log n)</p>
</li>
<li><p>底层： HashMap数组+链表+红黑树，TreeMap红黑树</p>
</li>
<li><p>应用： HashMap快速查找，TreeMap需要排序功能</p>
</li>
</ul>
<p><strong>ConcurrentHashMap 和 Hashtable 的区别？</strong></p>
<p>底层数据结构：</p>
<ul>
<li><p>ConcurrentHashMap： 数组+链表+红黑树（JDK1.8）</p>
</li>
<li><p>Hashtable： 数组+链表</p>
</li>
</ul>
<p>线程安全实现方式：</p>
<ul>
<li><p>ConcurrentHashMap：</p>
</li>
<li><p>JDK1.7：Segment分段锁，每个Segment独立加锁</p>
</li>
<li><p>JDK1.8：CAS+synchronized，锁粒度更细</p>
</li>
<li><p>Hashtable： 全局synchronized锁，性能较差</p>
</li>
</ul>
<p>性能差异：</p>
<ul>
<li><p>ConcurrentHashMap： 并发性能好，支持高并发</p>
</li>
<li><p>Hashtable： 并发性能差，所有操作串行执行</p>
</li>
</ul>
<p>null值处理：</p>
<ul>
<li><p>ConcurrentHashMap： 不允许null键值</p>
</li>
<li><p>Hashtable： 不允许null键值</p>
</li>
</ul>
<p>总结： ConcurrentHashMap通过更细粒度的锁机制实现更好的并发性能，而Hashtable使用全局锁导致性能瓶颈。</p>
<p><strong>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</strong></p>
<p>JDK1.7 - Segment分段锁：</p>
<ul>
<li><p>将数据分成多个Segment段</p>
</li>
<li><p>每个Segment独立加锁，不同Segment可并发访问</p>
</li>
<li><p>默认16个Segment，并发度16</p>
</li>
<li><p>使用ReentrantLock实现分段锁</p>
</li>
</ul>
<p>JDK1.8 - CAS+synchronized：</p>
<ul>
<li><p>取消Segment设计，直接使用Node数组</p>
</li>
<li><p>读操作： 无锁，使用volatile保证可见性</p>
</li>
<li><p>写操作：</p>
</li>
<li><p>插入时使用CAS操作</p>
</li>
<li><p>发生冲突时使用synchronized锁住当前Node</p>
</li>
<li><p>扩容： 多线程协助扩容，提高效率</p>
</li>
</ul>
<p>优势对比：</p>
<ul>
<li><p>JDK1.8锁粒度更细： 只锁冲突的Node，而不是整个Segment</p>
</li>
<li><p>性能更好： 并发度更高，减少锁竞争</p>
</li>
<li><p>实现更简单： 代码结构更清晰</p>
</li>
</ul>
<p>核心思想： 通过减少锁的粒度来提高并发性能。</p>
<h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a><strong>Java并发</strong></h3><p><strong>什么是线程和进程?线程与进程的关系,区别及优缺点？</strong></p>
<p>线程和进程：</p>
<p>进程： 程序的一次执行实例，拥有独立内存空间</p>
<p>线程： 进程内的执行单元，共享进程内存空间</p>
<p>JVM角度：</p>
<ul>
<li><p>一个JVM实例 &#x3D; 一个进程</p>
</li>
<li><p>线程共享堆内存，各自有独立栈空间</p>
</li>
</ul>
<p>关系： 进程包含多个线程，线程是进程的执行单元</p>
<p>区别：</p>
<ul>
<li><p>内存： 进程独立，线程共享</p>
</li>
<li><p>开销： 进程大，线程小</p>
</li>
<li><p>通信： 进程需IPC，线程可直接共享</p>
</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>进程： 稳定但开销大</p>
</li>
<li><p>线程： 高效但需同步机制</p>
</li>
</ul>
<p>**为什么要使用多线程呢? **</p>
<p>计算机角度：</p>
<ul>
<li><p>充分利用多核CPU能力</p>
</li>
<li><p>提高CPU利用率，避免单核浪费</p>
</li>
</ul>
<p>项目角度：</p>
<ul>
<li><p>提升系统性能： 并发处理提高吞吐量</p>
</li>
<li><p>响应性更好： 避免长时间阻塞</p>
</li>
<li><p>资源利用： 充分利用系统资源</p>
</li>
</ul>
<p>具体场景：</p>
<ul>
<li><p>Web服务器： 多线程处理并发请求</p>
</li>
<li><p>数据库连接池： 复用连接提高效率</p>
</li>
<li><p>异步处理： 后台任务不阻塞主流程</p>
</li>
<li><p>并行计算： 大数据处理、图像处理等</p>
</li>
</ul>
<p>核心目的： 提高系统并发能力和响应速度</p>
<p>**说说线程的生命周期和状态? **</p>
<p>线程生命周期和状态：</p>
<p>6种状态：</p>
<ul>
<li><p>NEW： 新建状态，线程被创建但未启动</p>
</li>
<li><p>RUNNABLE： 可运行状态，包括就绪和运行中</p>
</li>
<li><p>BLOCKED： 阻塞状态，等待获取锁</p>
</li>
<li><p>WAITING： 等待状态，无限期等待</p>
</li>
<li><p>TIME_WAITING： 超时等待状态，有限期等待</p>
</li>
<li><p>TERMINATED： 终止状态，线程执行完毕</p>
</li>
</ul>
<p>状态转换：</p>
<ul>
<li><p>NEW → RUNNABLE：调用start()</p>
</li>
<li><p>RUNNABLE → BLOCKED：等待synchronized锁</p>
</li>
<li><p>RUNNABLE → WAITING：调用wait()&#x2F;join()</p>
</li>
<li><p>RUNNABLE → TIME_WAITING：调用sleep()&#x2F;wait(timeout)</p>
</li>
<li><p>各种等待状态 → RUNNABLE：被唤醒或超时</p>
</li>
<li><p>RUNNABLE → TERMINATED：执行完毕</p>
</li>
</ul>
<p>注意： JVM层面只有RUNNABLE，操作系统层面分为READY和RUNNING</p>
<p>**什么是线程死锁?如何避免死锁?如何预防和避免线程死锁? **</p>
<p>线程死锁：</p>
<p>多个线程互相持有对方需要的锁，导致所有线程都无法继续执行</p>
<p>死锁条件：</p>
<ul>
<li><p>互斥条件：资源不能被多个线程同时使用</p>
</li>
<li><p>请求与保持：线程持有资源的同时请求其他资源</p>
</li>
<li><p>不剥夺条件：资源不能被强制剥夺</p>
</li>
<li><p>循环等待：存在循环等待链</p>
</li>
</ul>
<p>避免死锁：</p>
<ul>
<li><p>按固定顺序申请锁</p>
</li>
<li><p>一次性申请所有资源</p>
</li>
<li><p>使用可重入锁</p>
</li>
<li><p>设置锁获取超时时间</p>
</li>
</ul>
<p>预防措施：</p>
<ul>
<li><p>避免嵌套锁</p>
</li>
<li><p>使用锁的层次结构</p>
</li>
<li><p>及时释放锁</p>
</li>
<li><p>使用并发工具类</p>
</li>
</ul>
<p>排查方法：</p>
<ul>
<li><p>jstack查看线程状态</p>
</li>
<li><p>分析线程dump信息</p>
</li>
<li><p>使用JProfiler等工具</p>
</li>
</ul>
<p>**synchronized 关键字 **</p>
<p>作用： 保证线程安全，实现互斥访问</p>
<p>底层原理：</p>
<ul>
<li><p>对象头中的Mark Word存储锁信息</p>
</li>
<li><p>通过monitorenter&#x2F;monitorexit字节码指令实现</p>
</li>
<li><p>每个对象都有monitor锁</p>
</li>
</ul>
<p>锁升级流程：</p>
<ul>
<li><p>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p>
</li>
<li><p>偏向锁：减少CAS操作</p>
</li>
<li><p>轻量级锁：自旋等待</p>
</li>
<li><p>重量级锁：阻塞等待</p>
</li>
</ul>
<p>JDK1.6优化：</p>
<ul>
<li><p>引入偏向锁和轻量级锁</p>
</li>
<li><p>自旋锁优化</p>
</li>
<li><p>锁消除和锁粗化</p>
</li>
</ul>
<p>synchronized vs ReentrantLock：</p>
<ul>
<li><p>synchronized自动释放，ReentrantLock手动释放</p>
</li>
<li><p>ReentrantLock支持公平锁、可中断、超时</p>
</li>
<li><p>synchronized性能更好</p>
</li>
</ul>
<p>synchronized vs volatile：</p>
<ul>
<li><p>synchronized保证原子性、可见性、有序性</p>
</li>
<li><p>volatile只保证可见性和有序性</p>
</li>
<li><p>synchronized可以修饰方法、代码块，volatile只能修饰变量</p>
</li>
</ul>
<p>**并发编程的三个重要特性 ** </p>
<p>原子性：</p>
<ul>
<li><p>操作不可分割，要么全部执行，要么全部不执行</p>
</li>
<li><p>synchronized、ReentrantLock保证原子性</p>
</li>
</ul>
<p>可见性：</p>
<ul>
<li><p>一个线程修改共享变量，其他线程能立即看到</p>
</li>
<li><p>volatile、synchronized保证可见性</p>
</li>
</ul>
<p>有序性：</p>
<ul>
<li><p>程序执行顺序符合代码顺序</p>
</li>
<li><p>volatile、synchronized保证有序性</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li><p>synchronized保证三个特性</p>
</li>
<li><p>volatile只保证可见性和有序性</p>
</li>
<li><p>原子性需要锁机制保证</p>
</li>
</ul>
<p>**JMM（Java Memory Model，Java 内存模型）和 happens-before 原则。 **</p>
<p>JMM（Java内存模型）：</p>
<p>定义了Java虚拟机在计算机内存中的工作方式，保证多线程程序的正确性</p>
<p>happens-before原则：</p>
<ul>
<li><p>程序顺序规则： 同一线程内，前面操作happens-before后面操作</p>
</li>
<li><p>监视器锁规则： unlock操作happens-before后续lock操作</p>
</li>
<li><p>volatile规则： volatile写happens-before后续volatile读</p>
</li>
<li><p>线程启动规则： start()happens-before线程内所有操作</p>
</li>
<li><p>线程终止规则： 线程内所有操作happens-before线程终止</p>
</li>
<li><p>中断规则： interrupt()happens-before检测到中断</p>
</li>
<li><p>终结器规则： 构造函数happens-beforefinalize()</p>
</li>
<li><p>传递性： A happens-before B，B happens-before C，则A happens-before C</p>
</li>
</ul>
<p>作用： 保证多线程程序的正确性，避免重排序导致的问题。</p>
<p>**volatile 关键字 **</p>
<p>作用：</p>
<ul>
<li><p>保证可见性：一个线程修改，其他线程立即看到</p>
</li>
<li><p>保证有序性：禁止指令重排序</p>
</li>
</ul>
<p>底层原理：</p>
<ul>
<li><p>内存屏障：LoadLoad、StoreStore、LoadStore、StoreLoad</p>
</li>
<li><p>强制刷新主内存，禁止重排序</p>
</li>
</ul>
<p>与JMM关系：</p>
<ul>
<li><p>遵循happens-before原则</p>
</li>
<li><p>volatile写happens-before后续volatile读</p>
</li>
<li><p>保证内存可见性</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>单例模式双重检查锁</p>
</li>
<li><p>状态标志位</p>
</li>
<li><p>一次性安全发布</p>
</li>
</ul>
<p>限制：</p>
<ul>
<li><p>不保证原子性</p>
</li>
<li><p>不能替代synchronized</p>
</li>
<li><p>只适用于简单场景</p>
</li>
</ul>
<p>**ThreadLocal 关键字 **</p>
<p>作用： 为每个线程提供独立的变量副本，避免线程间数据竞争</p>
<p>底层原理：</p>
<ul>
<li><p>ThreadLocalMap存储线程私有数据</p>
</li>
<li><p>key是ThreadLocal对象，value是存储的值</p>
</li>
<li><p>每个Thread都有独立的ThreadLocalMap</p>
</li>
</ul>
<p>内存泄露问题：</p>
<ul>
<li><p>ThreadLocalMap的key是弱引用，value是强引用</p>
</li>
<li><p>线程不结束，value不会被回收</p>
</li>
<li><p>解决：使用完调用remove()方法</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>用户信息传递</p>
</li>
<li><p>数据库连接</p>
</li>
<li><p>事务上下文</p>
</li>
<li><p>日志MDC</p>
</li>
</ul>
<p>注意事项：</p>
<ul>
<li><p>及时清理，避免内存泄露</p>
</li>
<li><p>线程池中使用要特别注意</p>
</li>
<li><p>父子线程数据隔离</p>
</li>
</ul>
<p>**线程池 **</p>
<p>核心参数：</p>
<ul>
<li><p>corePoolSize：核心线程数</p>
</li>
<li><p>maximumPoolSize：最大线程数</p>
</li>
<li><p>keepAliveTime：空闲线程存活时间</p>
</li>
<li><p>workQueue：工作队列</p>
</li>
<li><p>threadFactory：线程工厂</p>
</li>
<li><p>handler：拒绝策略</p>
</li>
</ul>
<p>执行流程：</p>
<ol>
<li><p>核心线程数未满，创建新线程</p>
</li>
<li><p>核心线程数已满，任务放入队列</p>
</li>
<li><p>队列已满，创建新线程（不超过最大线程数）</p>
</li>
<li><p>达到最大线程数，执行拒绝策略</p>
</li>
</ol>
<p>拒绝策略：</p>
<ul>
<li><p>AbortPolicy：抛出异常</p>
</li>
<li><p>CallerRunsPolicy：调用者线程执行</p>
</li>
<li><p>DiscardPolicy：丢弃任务</p>
</li>
<li><p>DiscardOldestPolicy：丢弃最旧任务</p>
</li>
</ul>
<p>线程池类型：</p>
<ul>
<li><p>FixedThreadPool：固定线程数</p>
</li>
<li><p>CachedThreadPool：可缓存线程</p>
</li>
<li><p>ScheduledThreadPool：定时任务</p>
</li>
<li><p>SingleThreadExecutor：单线程</p>
</li>
</ul>
<p>线程池大小设置：</p>
<ul>
<li><p>CPU密集型：CPU核数+1</p>
</li>
<li><p>IO密集型：CPU核数<em>2</em></p>
</li>
</ul>
<p>**ReentrantLock 和 AQS **</p>
<p>ReentrantLock特性：</p>
<ul>
<li><p>可重入锁：同一线程可多次获取</p>
</li>
<li><p>支持公平锁和非公平锁</p>
</li>
<li><p>可中断、可超时</p>
</li>
<li><p>手动释放锁</p>
</li>
</ul>
<p>AQS（AbstractQueuedSynchronizer）：</p>
<ul>
<li><p>抽象队列同步器</p>
</li>
<li><p>提供锁的框架实现</p>
</li>
<li><p>维护CLH队列和state状态</p>
</li>
</ul>
<p>ReentrantLock基于AQS实现：</p>
<ul>
<li><p>继承AQS，重写tryAcquire&#x2F;tryRelease</p>
</li>
<li><p>state表示锁状态（0未锁定，&gt;0已锁定）</p>
</li>
<li><p>公平锁按FIFO顺序获取锁</p>
</li>
<li><p>非公平锁直接尝试获取锁</p>
</li>
</ul>
<p>核心机制：</p>
<ul>
<li><p>CAS操作修改state</p>
</li>
<li><p>失败则加入队列等待</p>
</li>
<li><p>自旋+阻塞等待唤醒</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li><p>比synchronized更灵活</p>
</li>
<li><p>支持多种锁特性</p>
</li>
<li><p>性能相当</p>
</li>
</ul>
<p>**乐观锁和悲观锁的区别 **</p>
<p>悲观锁：</p>
<ul>
<li><p>认为冲突会经常发生</p>
</li>
<li><p>先加锁再操作</p>
</li>
<li><p>实现：synchronized、ReentrantLock</p>
</li>
<li><p>适用：写多读少场景</p>
</li>
</ul>
<p>乐观锁：</p>
<ul>
<li><p>认为冲突很少发生</p>
</li>
<li><p>先操作再检查冲突</p>
</li>
<li><p>实现：CAS、版本号</p>
</li>
<li><p>适用：读多写少场景</p>
</li>
</ul>
<p>性能对比：</p>
<ul>
<li><p>悲观锁：开销大，并发度低</p>
</li>
<li><p>乐观锁：开销小，并发度高</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>悲观锁：数据库行锁、文件锁</p>
</li>
<li><p>乐观锁：库存扣减、计数器</p>
</li>
</ul>
<p>总结： 悲观锁适合冲突频繁场景，乐观锁适合冲突较少场景</p>
<p>**CAS 了解么？原理？什么是 ABA 问题？ABA 问题怎么解决？ **</p>
<p>原理：</p>
<ul>
<li><p>比较并交换，原子操作</p>
</li>
<li><p>比较内存值与期望值，相等则更新</p>
</li>
<li><p>失败则重试或放弃</p>
</li>
</ul>
<p>ABA问题：</p>
<ul>
<li><p>A→B→A，值没变但过程变了</p>
</li>
<li><p>可能导致数据不一致</p>
</li>
</ul>
<p>ABA解决方案：</p>
<ul>
<li><p>版本号：每次修改版本号+1</p>
</li>
<li><p>时间戳：记录修改时间</p>
</li>
<li><p>AtomicStampedReference：带版本号的引用</p>
</li>
</ul>
<p>实际应用：</p>
<ul>
<li><p>ConcurrentHashMap：CAS+synchronized</p>
</li>
<li><p>AtomicInteger：volatile+CAS</p>
</li>
<li><p>自旋锁实现</p>
</li>
<li><p>无锁数据结构</p>
</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：无锁，性能好</p>
</li>
<li><p>缺点：自旋消耗CPU，ABA问题</p>
</li>
</ul>
<p>**Atomic 原子类 **</p>
<p>分类：</p>
<ul>
<li><p>基本类型：AtomicInteger、AtomicLong、AtomicBoolean</p>
</li>
<li><p>引用类型：AtomicReference</p>
</li>
<li><p>数组类型：AtomicIntegerArray</p>
</li>
</ul>
<p>原理： volatile+CAS实现，保证原子性和可见性</p>
<p>常用方法：</p>
<ul>
<li><p>get()&#x2F;set()：获取&#x2F;设置</p>
</li>
<li><p>compareAndSet()：CAS操作</p>
</li>
<li><p>incrementAndGet()：自增</p>
</li>
</ul>
<p>使用场景： 计数器、状态标志、并发累加</p>
<p>优势： 比synchronized性能更好，适合简单原子操作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/01/Java/" data-id="cmdwr17wt000178qqh89geq5m" data-title="Java" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-布隆过滤器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T09:02:07.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="布隆过滤器结构"><a href="#布隆过滤器结构" class="headerlink" title="布隆过滤器结构"></a>布隆过滤器结构</h4><p>布隆过滤器是一个基于数组和哈希函数散列元素的结构，很像HashMap的哈希桶。布隆过滤器可以用于检测一个元素是否在集合中。它的优点是空间效率和查询时间比一般算法要好很多，但也有一定概率的误判性。<em>如HashMap出现哈希碰撞💥</em></p>
<hr>
<h4 id="布隆过滤器实现"><a href="#布隆过滤器实现" class="headerlink" title="布隆过滤器实现"></a>布隆过滤器实现</h4><p>布隆过滤器的实现条件包括可以存放二进制元素的 BitSet 以及多样性的哈希计算函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashGenerator.HashGroup[] GROUPS = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>.HashGroup[]&#123;HashGenerator.HashGroup.G1, HashGenerator.HashGroup.G2, HashGenerator.HashGroup.G3, HashGenerator.HashGroup.G4&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitSet bits;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> HashGenerator[] generators;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的元素存放都经过多样的哈希计算存放到 BitSet 中，这样可以尽可能的分散元素，减少误判性。</p>
<ul>
<li><em><strong>哈希函数</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG1</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">        hash = Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % (seed * size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG2</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">7397</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % seed * (size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG3</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash += c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % (seed * size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG4</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs(seed * (size - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里提供了四种哈希计算的方式，相当于每一个哈希计算都是一次扰动处理。一个元素的存放可以经过四次哈希，尽量让元素值做到散列。</li>
</ul>
<ul>
<li><em><strong>构建容器</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span>[] seeds)</span> &#123;</span><br><span class="line">    bits = <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    generators = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>[seeds.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seeds.length; i++) &#123;</span><br><span class="line">        generators[i] = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>(size, seeds[i], GROUPS[i % GROUPS.length]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数根据所需创建的容器大小和哈希种子来初始化布隆过滤器。</li>
</ul>
<ul>
<li><em><strong>添加元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> generator.doHash(value);</span><br><span class="line">        bits.set(hash, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素时按照元素初始化时的哈希计算种类，获取哈希并存放。</li>
</ul>
<ul>
<li><em><strong>比对元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        ret = ret &amp;&amp; bits.get(generator.doHash(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>比对元素时用的是同一类哈希计算方式，并且把这些哈希值 <code>&amp;&amp;</code> 计算。<em>用N个比特位置记录一个值更准确</em></li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>布隆过滤器的使用场景？</strong></li>
</ul>
<p><strong>布隆过滤器使用场景</strong>：缓存穿透防护（避免查询不存在的数据）、垃圾邮件过滤、网页爬虫URL去重、数据库查询优化（预先判断数据是否存在）、分布式系统中的重复数据检测、黑名单快速判断等需要快速判断元素是否”可能存在”的场景。</p>
<p><strong>核心优势</strong>：空间效率极高，查询速度快，但存在误判（可能存在但实际不存在）。</p>
<ul>
<li><strong>布隆过滤器的实现原理和方式？</strong></li>
</ul>
<p><strong>布隆过滤器实现原理</strong>：使用位数组和多个哈希函数，插入元素时将其通过k个哈希函数映射到位数组的k个位置并置1，查询时检查这k个位置是否都为1。</p>
<p><strong>实现方式</strong>：初始化m位的位数组全为0，选择k个独立哈希函数，插入时设置对应位为1，查询时检查所有对应位。</p>
<p><strong>核心特点</strong>：不存在假阴性（存在的一定返回存在），但有假阳性（可能误判不存在的为存在），无法删除元素。</p>
<ul>
<li><strong>如何提高布隆过滤器的准确性？</strong></li>
</ul>
<p><strong>增加位数组大小</strong>：更大的m值降低哈希冲突概率。<strong>优化哈希函数数量</strong>：选择最优的k值（约为m&#x2F;n*ln2）平衡误判率。<strong>使用高质量哈希函数</strong>：选择分布均匀、冲突少的哈希算法。<strong>控制元素数量</strong>：避免超过设计容量导致误判率急剧上升。</p>
<p><strong>核心公式</strong>：误判率≈(1-e^(-kn&#x2F;m))^k，通过调整m、k、n三个参数优化准确性。</p>
<ul>
<li><strong>有哪些中哈希计算方式？</strong></li>
</ul>
<p><strong>除法散列</strong>：h(k) &#x3D; k mod m，简单但容易聚集。<strong>乘法散列</strong>：h(k) &#x3D; ⌊m(kA mod 1)⌋，A为常数。<strong>平方取中法</strong>：对关键字平方后取中间几位。<strong>折叠法</strong>：将关键字分段相加。</p>
<p><strong>字符串哈希</strong>：djb2、sdbm、FNV等算法。<strong>密码学哈希</strong>：MD5、SHA-1、SHA-256等安全性更高。<strong>现代哈希</strong>：MurmurHash、CityHash等高性能算法。</p>
<p><strong>选择原则</strong>：根据数据特点和性能要求选择合适的哈希函数。</p>
<ul>
<li><strong>都有哪些类型的布隆过滤器实现？<em>Google 开源的 Guava 中自带的布隆过滤器、Redis 中的布隆过滤器</em></strong></li>
</ul>
<p><strong>标准布隆过滤器</strong>：经典实现，不支持删除操作。<strong>计数布隆过滤器</strong>：用计数器替代位数组，支持删除但占用更多空间。<strong>可扩展布隆过滤器</strong>：动态增加容量避免误判率上升。</p>
<p><strong>Guava布隆过滤器</strong>：Google开源，支持自定义误判率和容量，提供便捷API。<strong>Redis布隆过滤器</strong>：通过RedisBloom模块实现，支持分布式场景，提供bf.add和bf.exists命令。</p>
<p><strong>其他实现</strong>：Cassandra、HBase等数据库内置布隆过滤器优化查询性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" data-id="cmdwr17x2000q78qqe1k76z60" data-title="布隆过滤器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%9B%BE/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T07:35:44.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%9B%BE/">图</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="图的数据结构"><a href="#图的数据结构" class="headerlink" title="图的数据结构"></a>图的数据结构</h4><p>图（Graph）结构是一种比树结构复杂的非线性的数据结构，图在实际生活中的例子非常多，比如；地铁线路网、微信好友关系链、计算机中的状态执行等，都可以抽象成图的结构。</p>
<p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E) &#x3D; 【G表示图、V表示顶点个数、E表示边的个数】。图的数据结构是多对多关系，就像你的微信好友可能也是我的微信好友，且相互交叉对应。与之对应的是树，树是1对多关系，所以树也是一种特殊的没有闭环的图。</p>
<p>按照图<strong>是否有方向</strong>和<strong>是否有权重</strong>可以分为一下4类组合；</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%9B%BE%E7%A7%8D%E7%B1%BB.png" alt="图种"></p>
<ul>
<li>顶点：图中的任意节点都算作顶点，图中任意两个顶点间都可能存在连接，如果没有顶点间没有连线则称为空图。</li>
<li>无向图：图中任意两个顶点间都没有指向，则称这样的图为无向图。</li>
<li>有向图：图中任意两个顶点间都有指向边，则称这样的图为有向图。</li>
<li>无权重：图中任意两个顶点间的连线，没有权重值，则无权重。</li>
<li>有权重：图中任意两个顶点间的连线，包含权重值，则有权重。</li>
</ul>
<hr>
<h4 id="图的结构实现"><a href="#图的结构实现" class="headerlink" title="图的结构实现"></a>图的结构实现</h4><p>图的结构实现可以基于数组、链表和红黑树实现，也因此将使用数组实现的图称为邻接矩阵，链表和红黑树实现的图称为邻接表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的矩阵【数组】</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"><span class="comment">// 图的矩阵【链表】</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"><span class="comment">// 图的矩阵【红黑树】</span></span><br><span class="line"><span class="keyword">private</span> TreeSet&lt;Integer&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>图的数据存放可以使用 int 数组、LinkedList 链表、TreeSet 红黑树等方式存储。</p>
<ul>
<li><strong>邻接矩阵【数组】</strong></li>
</ul>
<ol>
<li><strong>无向图&amp;无权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x][y] = <span class="number">1</span>;</span><br><span class="line">    table[y][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，对称插入节点。例如：0→1、1→0，两个方向都插入元素。</li>
</ul>
<ol start="2">
<li><strong>有向图&amp;有权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x][y] = weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，插入单向节点，节点值为权重值。例如：0→2，权重值是4。</li>
</ul>
<ul>
<li><em><strong>邻接表【链表】</strong></em></li>
</ul>
<ol>
<li><strong>无向图&amp;无权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y&#125;);</span><br><span class="line">    table[y].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;x&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，无向无权重直接对称插入元素即可。</li>
</ul>
<ol start="2">
<li><strong>有向图&amp;有权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，有方向，有权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y, weight&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，有方向有权重则只插入单个指向，并需要通过数组或者对象的方式记录权重值。</li>
</ul>
<ul>
<li><em><strong>遍历</strong></em></li>
</ul>
<p>图的最终实现是通过 TreeSet 红黑树的方式，这样即节省空间，又能提高元素的索引和遍历效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">private</span> TreeSet&lt;Integer&gt;[] table;</span><br></pre></td></tr></table></figure>

<ol>
<li>深度遍历，不断地向下探测。广度遍历横行探测。</li>
<li>当有权重时候，则深度和广度会按照权重进行选择优先遍历的顺序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        order.add(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                queue.add(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 深度优先，前序遍历</span></span><br><span class="line">    pre.add(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : graph.adj(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先，后序遍历</span></span><br><span class="line">    post.add(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>图的使用场景是什么？</strong></li>
</ul>
<p><strong>图的使用场景</strong>：社交网络（好友关系）、地图导航（最短路径）、网络拓扑（路由算法）、任务调度（依赖关系）、推荐系统（关联分析）、电路设计、生物信息学（基因网络）、搜索引擎（网页链接）、交通规划等需要表示复杂关系和连接的问题。</p>
<p><strong>核心优势</strong>：能够自然表达实体间的多对多关系和复杂网络结构。</p>
<ul>
<li><strong>图有的分类？</strong></li>
</ul>
<p><strong>按边的方向</strong>：有向图（边有方向）、无向图（边无方向）。</p>
<p><strong>按边的权重</strong>：带权图（边有权值）、无权图（边无权值）。</p>
<p><strong>按连通性</strong>：连通图（任意两点可达）、非连通图、强连通图（有向图中任意两点互相可达）。</p>
<ul>
<li><strong>图怎么存放权重值？</strong></li>
</ul>
<p><strong>邻接矩阵</strong>：二维数组matrix[i][j]存储从顶点i到顶点j的边权重，无边时存储无穷大或特殊值。</p>
<p><strong>邻接表</strong>：每个顶点维护一个列表，存储(目标顶点, 权重)的键值对。</p>
<p><strong>边列表</strong>：直接存储所有边的信息，每条边包含(起点, 终点, 权重)三元组。</p>
<p><strong>核心选择</strong>：稠密图用邻接矩阵，稀疏图用邻接表，算法处理用边列表。</p>
<ul>
<li><strong>图的广度遍历</strong></li>
</ul>
<p><strong>图的广度遍历（BFS）</strong>：从起始顶点开始，先访问所有相邻顶点，再逐层向外扩展访问。<strong>实现方式</strong>：使用队列存储待访问顶点，用visited数组标记已访问节点避免重复。<strong>遍历顺序</strong>：按距离起点的层次逐层访问，同层顶点访问顺序取决于邻接表顺序。</p>
<p><strong>核心特点</strong>：能找到最短路径（无权图），时间复杂度O(V+E)。</p>
<ul>
<li><strong>图的深度遍历</strong></li>
</ul>
<p><strong>图的深度遍历（DFS）</strong>：从起始顶点开始，沿着一条路径尽可能深入，直到无法继续时回溯到上一个顶点，继续探索其他路径。<strong>实现方式</strong>：使用栈（或递归）存储待访问顶点，用visited数组标记已访问节点避免重复。<strong>遍历特点</strong>：优先深度探索，能检测环路和连通分量。</p>
<p><strong>核心特点</strong>：适合路径搜索和拓扑排序，时间复杂度O(V+E)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%9B%BE/" data-id="cmdwr17wz000c78qq97cvhd7e" data-title="图" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-并查集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T03:25:50.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="并查集数据结构"><a href="#并查集数据结构" class="headerlink" title="并查集数据结构"></a>并查集数据结构</h5><p>并查集数据结构（也称为联合-查找数据结构或合并-查找集）基于数组实现的一种跟踪元素的数据结构，这些元素被划分为多个不相交（非重叠）的子集。</p>
<p>它提供了近乎恒定的时间操作（以逆阿克曼函数为界）来添加新集合、合并现有集合以及确定元素是否在同一个集合中。除了推荐算法、好友关系链、族谱等，并查集在 <code>Kruskal</code>的算法中扮演着关键角色，用于寻找无向边加权图的最小生成树。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/4.png"></p>
<p>为了尽可能少的检索次数到根元素，在01：粗暴合并的基础上，有了基于数量、排序的合并方式，同时还包括可以压缩路径。这样再索引到根节点的时间复杂度就又降低了。</p>
<hr>
<h4 id="并查集结构实现"><a href="#并查集结构实现" class="headerlink" title="并查集结构实现"></a>并查集结构实现</h4><p>并查集的实现非常巧妙，只基于数组就可以实现出一个树的效果（基于数组实现的还有二叉堆也是树的结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line">	  <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 数量【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] count;</span><br><span class="line">	<span class="comment">// 排序【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集的元素存放在数组中，通过对数组元素的下标索引指向其他元素，构成一棵树。count 数量、rank 排序，是用于对并查集合并元素时的优化处理。</p>
<ul>
<li><em><strong>默认合并 - union(1, 8)</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E9%BB%98%E8%AE%A4%E5%90%88%E5%B9%B6.png" alt="默认合并"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查索引是否越界，抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> items[i];</span><br><span class="line">    <span class="comment">// 返回索引i对应的根节点值（集合标识符）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentVal</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 获取parent节点所属集合的根节点值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childVal</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="comment">// 获取child节点所属集合的根节点值</span></span><br><span class="line">    <span class="keyword">if</span> (parentVal == childVal) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果两个节点已经在同一集合中，直接返回</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i ++)&#123;</span><br><span class="line">        <span class="comment">// 遍历整个数组</span></span><br><span class="line">        <span class="keyword">if</span> (items[i] == childVal)&#123;</span><br><span class="line">            <span class="comment">// 找到所有属于child集合的节点</span></span><br><span class="line">            items[i] = parentVal;</span><br><span class="line">            <span class="comment">// 将它们的根节点值改为parent集合的根节点值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成两个集合的合并操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>union 是合并元素的方法，两个入参意思是把 child 指向的根节点，指向 parent 指向的根节点。后面所有案例中 union 方法属性字段意思相同。</li>
<li>find 找到元素对应的根节点值，之后使用 union 方法对 items 数组内的元素全部遍历，把所有值等于 child 的节点，都替换为 parent 节点值。</li>
<li>每次合并都for循环比较耗时，所以后续做了一些列的优化。</li>
</ul>
<ul>
<li><em><strong>粗暴合并</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E7%B2%97%E6%9A%B4%E5%90%88%E5%B9%B6.png" alt="粗暴合并"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 找到元素的根节点，当i == item[i]，就是自己指向自己，这个节点就是根节点</span></span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 孩子节点值替换为父节点值</span></span><br><span class="line">    items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>find 循环找到置顶节点的最终根节点，例如；8 → 6、6 → 6，那么说明8的根节点是6，因为6自己指向自己了，它就是根节点。</li>
<li>union 将 8 指向的根节点 6，更换为 1 指向的根节点 0。最终替换完就是 6 → 0，那么8的根节点有也是0了。</li>
<li>这样虽然减少了每次 for 循环更新，但粗暴的合并会对节点的索引带来一定的复杂度。所以还需要继续优化。</li>
</ul>
<ul>
<li><em><strong>压缩路径</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8E%8B%E7%BC%A9%E8%B7%AF%E5%BE%84.png" alt="压缩路径"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        items[i] = items[items[i]];</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[parentRootIdx] &gt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[parentRootIdx] &lt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[parentRootIdx] = items[childRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">        rank[parentRootIdx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(8, 1) 在rank合并下，压缩路径长度。</p>
<ul>
<li>这里的 union 方法与<code>4. 排序合并</code>相比并没有变化，变化的地方主要在 find 过程中压缩路径。</li>
<li>find 基于查找根元素时，对当前元素值对应的父节点值，替换给当前元素。减少一级路径，做到压缩路径的目的。</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>并查集叙述？</strong></li>
</ul>
<p><strong>并查集</strong>：用于处理不相交集合的合并和查询问题的数据结构。<strong>核心操作</strong>：find（查找元素所属集合）和union（合并两个集合）。<strong>主要实现</strong>：数组存储每个元素的父节点，通过路径压缩和按秩合并优化性能。<strong>应用场景</strong>：连通性问题、最小生成树算法、动态连通性查询等。<strong>时间复杂度</strong>：优化后接近O(1)。</p>
<ul>
<li><strong>并查集的使用场景？</strong></li>
</ul>
<p><strong>并查集使用场景</strong>：判断图的连通性、检测无向图中的环、最小生成树算法（Kruskal）、社交网络中的朋友圈划分、像素连通区域检测、网络连接状态判断、动态连通性查询等需要快速合并和查找集合关系的问题。</p>
<p><strong>核心特点</strong>：擅长处理”分组”和”连通性”相关的动态问题。</p>
<ul>
<li><strong>并查集怎么合并元素？</strong></li>
</ul>
<p><strong>并查集合并元素</strong>：通过union操作将两个元素所属的集合合并。<strong>具体步骤</strong>：1）找到两个元素各自的根节点；2）如果根节点相同则已在同一集合；3）否则将一个根节点指向另一个根节点，完成合并。<strong>优化策略</strong>：按秩合并（小树挂到大树下）避免树过深，提高后续查找效率。</p>
<ul>
<li><strong>并查集合并元素的优化策略？</strong></li>
</ul>
<p><strong>按秩合并</strong>：将深度小的树挂到深度大的树下，避免树过深影响查找效率。</p>
<p><strong>路径压缩</strong>：在find操作中将路径上所有节点直接指向根节点，减少后续查找深度。</p>
<p><strong>两者结合</strong>：使union和find操作的时间复杂度接近O(1)，大幅提升整体性能。</p>
<ul>
<li><strong>如何压缩路径？</strong></li>
</ul>
<p><strong>路径压缩</strong>：在find操作中，将查找路径上的所有节点直接指向根节点。<strong>实现方式</strong>：递归查找根节点时，在返回过程中将当前节点的父指针直接指向根节点，使树变得扁平化。<strong>效果</strong>：后续对同一路径上节点的查找操作时间复杂度接近O(1)。</p>
<p><strong>代码核心</strong>：<code>parent[x] = find(parent[x])</code>，递归压缩路径。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/" data-id="cmdwr17x4000w78qqh6py52hr" data-title="并查集" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-红黑树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T08:59:18.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="红黑树数据结构"><a href="#红黑树数据结构" class="headerlink" title="红黑树数据结构"></a>红黑树数据结构</h4><p>建立在 BST 二叉搜索树的基础上，AVL、2-3树、红黑树都是自平衡二叉树（统称B-树）。但相比于AVL树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。也正因红黑树在插入和删除时不需要太多的平衡操作，也让它成为；Java中HashMap的元素碰撞后的转换、Linux的CFS进行调度算法、多路复用技术的Epoll等各类底层的数据结构实现。</p>
<p>红黑树的五条定义：</p>
<ol>
<li><strong>每个节点不是红色就是黑色。</strong><ul>
<li>黑色决定平衡，红色不决定平衡。这对应了2-3树中一个节点内可以存放1~2个节点。</li>
</ul>
</li>
<li><strong>根是黑色的。</strong><ul>
<li>这条规则有时会被省略。由于根总是可以从红色变为黑色，但不一定相反，因此该规则对分析几乎没有影响。</li>
</ul>
</li>
<li><strong>所有叶子 (NIL) 都是黑色的。</strong><ul>
<li>这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。</li>
</ul>
</li>
<li><strong>如果一个节点是红色的，那么它的两个子节点都是黑色的。</strong><ul>
<li>通常这条规则也叫不会有连续的红色节点。这体现在2-3树中，一个节点最多临时会有3个节点，中间是黑色节点，左右是红色节点。2-3树中出现这样的情况后，会进行节点迁移，中间节点成为父节点，左右节点成为子节点。</li>
</ul>
</li>
<li><strong>从给定节点到其任何后代 NIL 节点的每条路径都包含相同数量的黑色节点。</strong><ul>
<li>对应2-3树中，每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="红黑树结构实现"><a href="#红黑树结构实现" class="headerlink" title="红黑树结构实现"></a>红黑树结构实现</h4><p>基于 BST 二叉搜索树的基础上，AVL树添加了树高作为计算平衡因子的条件，那么红黑树也需要添加一个新的颜色属性，用于处理平衡操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">// 红黑树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.RED;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>相比于AVL树通过左右旋转平衡树高，红黑树则是在2-3树的基础上，只对黑色节点维护树高，所以它会使用到染色和左右旋来对树高调衡。<em>染色与左右旋相比，减少了平衡操作</em></p>
<ul>
<li><em><strong>左倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="左倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.right;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span> (uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current = grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>右倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="右倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.left;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span>(uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current= grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>左旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次左旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%B7%A6%E6%97%8B.png" alt="一次左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的左侧小图，新增的节点5导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点4提起来，而对应红黑树则需要先进行染色，待操作的节点4为黑色，两个孩子节点为红色。</li>
<li>最后是把节点3进行一次左旋操作，完成树的平衡。对应步骤3中的左侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>右旋+左旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要右旋+左旋的情况，在AVL树中有同样的场景。本身树需要左旋操作，但整体分支树节点偏左，此时需要右旋调整树结构再左旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%2B%E5%B7%A6.png" alt="右左"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏左↙，先右旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.left)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateRight(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点4以后，4↙5 结构偏左，需要先进行右旋调衡树结构，再进行左旋。其实这个时候再进行的左旋就和上面一次左旋操作一致了。</li>
</ul>
<ul>
<li><em><strong>右旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次右旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的右侧小图，新增的节点1导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点2提起来，而对应红黑树则需要先进行染色，待操作的节点2为黑色，两个孩子节点为红色。</li>
<li>最后是把节点2进行一次右旋操作，完成树的平衡。对应步骤3中的右侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>左旋+右旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要左旋+右旋的情况，在AVL树中有同样的场景。本身树需要右旋操作，但整体分支树节点偏右，此时需要左旋调整树结构再右旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%2B%E5%8F%B3.png" alt="左右"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏右↘，先左旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.right)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateLeft(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点2以后，1↘2 结构偏右，需要先进行左旋调衡树结构，再进行右旋。其实这个时候再进行的右旋就和上面一次右旋操作一致了。</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>红黑树都有哪些使用场景？</strong></li>
</ul>
<p><strong>红黑树使用场景</strong>：Java TreeMap&#x2F;TreeSet、C++ STL的map&#x2F;set、Linux内核进程调度、数据库索引结构、编译器符号表、内存管理	器、高性能缓存系统等需要稳定O(log n)性能的场景。</p>
<p><strong>核心优势</strong>：相比AVL树旋转次数少，相比普通BST保证平衡，适合频繁插入删除的应用。</p>
<ul>
<li><strong>相比于BST树，红黑树有什么用途？</strong></li>
</ul>
<p><strong>红黑树相比BST的用途</strong>：解决BST最坏情况退化成链表的问题，通过着色和旋转机制保证树的近似平衡，确保查找、插入、删除操作始终维持O(log n)时间复杂度，避免性能恶化。</p>
<p><strong>关键作用</strong>：防止恶意数据攻击导致的性能退化，提供稳定可预期的性能保证。</p>
<ul>
<li><strong>B-树是什么意思，都包括哪些？</strong></li>
</ul>
<p><strong>B-树定义</strong>：多路平衡搜索树，每个节点可存储多个键值和子节点，所有叶子节点在同一层。</p>
<p><strong>主要类型</strong>：B树（内部节点和叶子节点都存数据）、B+树（只有叶子节点存数据，内部节点只存索引）、B*树（B+树的优化版本，节点利用率更高）。</p>
<p><strong>核心用途</strong>：数据库索引、文件系统，因为减少磁盘I&#x2F;O次数，适合大数据量存储。</p>
<ul>
<li><strong>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</strong></li>
</ul>
<p><strong>染色情况</strong>：父节点和叔叔节点都是红色时，将父节点、叔叔节点染黑，祖父节点染红。</p>
<p><strong>左旋情况</strong>：父节点是红色、叔叔节点是黑色，且新节点是父节点的右子节点时。</p>
<p><strong>左旋+右旋情况</strong>：父节点是红色、叔叔节点是黑色，新节点是父节点的左子节点，但父节点是祖父节点的右子节点时（右-左型不平衡）。</p>
<p><strong>核心原则</strong>：通过染色、旋转保持红黑树的5个性质不被破坏。</p>
<ul>
<li><strong>红黑树的特点是什么？</strong></li>
</ul>
<p><strong>红黑树特点</strong>：节点非红即黑、根节点是黑色、红节点的子节点必须是黑色、从任一节点到叶子节点的路径包含相同数量的黑节点、叶子节点（NIL）是黑色。</p>
<p><strong>核心优势</strong>：自平衡、最坏情况仍保证O(log n)性能、相比AVL树旋转次数少、插入删除效率高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" data-id="cmdwr17x6001578qq2snvhahy" data-title="红黑树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2-3树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/2-3%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T07:57:52.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/2-3%E6%A0%91/">2-3树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="2-3树数据结构"><a href="#2-3树数据结构" class="headerlink" title="2-3树数据结构"></a>2-3树数据结构</h4><p>2–3树是一种树型数据结构，由约翰·霍普克洛夫特于1970年发明。它通过在一个节点存放1-2个元素来平衡树高。从而也使2-3树存在2叉节点和3叉节点。</p>
<p><img src="https://bugstack.cn/images/article/algorithm/tree-23-01.png?raw=true" alt="img"></p>
<p>这里要提到一点，在BST二叉搜索树可能退化成链表的基础上。引出了自平衡二叉树，也就是包括上一章实现的AVL树和Java API HashMap中用到的红黑树，它们都属于BalancedTree，也统称为B树，平衡的意思。</p>
<p>而本章实现的2-3树也是一种简单的平衡树，其中每个具有子节点（内部节点）的节点要么有两个子节点（2 节点）和一个数据元素，要么有三个子节点（3 节点）和两个数据元素。另外 2-3 树是3阶B 树，2-3-4 树是4阶B树。</p>
<hr>
<h4 id="2-3树结构实现"><a href="#2-3树结构实现" class="headerlink" title="2-3树结构实现"></a>2-3树结构实现</h4><ul>
<li><em><strong>节点定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node_2_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="comment">// 孩子</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3[] children;</span><br><span class="line">    <span class="comment">// 父亲【非必须】</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3 parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node_2_3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">this</span>.number = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="built_in">this</span>.number - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.items[idx] &lt; e) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = <span class="built_in">this</span>.items[idx];</span><br><span class="line">            --idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = e;</span><br><span class="line">        ++<span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2-3树的几点元素需要包括；一个数组的元素集合、元素的序号、孩子元素。因为一个节点最多可临时放入3个元素，那么就会最多有4个孩子元素，所以孩子元素也是一个数组并且在构造函数中按照4个元素进行初始化。</li>
<li>由于本身2-3树插入元素的开始阶段，并不是直接创建一个新的节点，而是在初始化的数组空间中存入元素。所以在节点中提供了一个插入元素的方法 insert 来处理新增元素。</li>
<li>另外2-3树的节点类，还提供了一个方便查询的方法。包括：获取左边元素、中间元素、右边元素，以及最小值、最大值和判断是否有孩子节点。这些内容可以源码。</li>
</ul>
<ul>
<li><em><strong>拆分节点</strong></em></li>
</ul>
<p>当一个节点内有3个元素的时候，就要发起拆分东西，拆分的过程分为；</p>
<ol>
<li>对3个节点的中间节点，插入到父节点上。</li>
<li>剩余2个节点创建出新的节点。</li>
<li>建立父节点和新创建的2个节点间关系。</li>
</ol>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8B%86%E5%88%86%E8%8A%82%E7%82%B9.png" alt="拆分节点"></p>
<ol>
<li>插入父节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">split</span><span class="params">(Node_2_3 node, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    parent.insert(node.getMiddleItem());</span><br><span class="line">    </span><br><span class="line">    Node_2_3[] newNodes = <span class="built_in">this</span>.triangle(node);</span><br><span class="line">    <span class="built_in">this</span>.replaceChild(parent, node, newNodes[<span class="number">0</span>], newNodes[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整个2-3树拆分的过程就是在 split 这个方法里，第一步解决了是否有父节点，没有则创建。</li>
<li>之后将原节点的中间值插入到父节点中。接下来的操作就是拆分新节点和更换孩子节点建立新连接。</li>
</ul>
<ol start="2">
<li>拆分新节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3[] triangle(Node_2_3 node) &#123;</span><br><span class="line">    Node_2_3[] newNodes = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">2</span>];</span><br><span class="line">    newNodes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">0</span>]);</span><br><span class="line">    newNodes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!node.isLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 左孩子</span></span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">0</span>] = node.children[<span class="number">0</span>];</span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">1</span>] = node.children[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 右孩子</span></span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">0</span>] = node.children[<span class="number">2</span>];</span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">1</span>] = node.children[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于传递进来的节点，将节点的左右孩子创建新节点，如果这个孩子节点还有分支节点，则一并更新。</li>
</ul>
<ol start="3">
<li>建立新连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceChild</span><span class="params">(Node_2_3 parent, Node_2_3 oldChild, Node_2_3 child01, Node_2_3 child02)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChild == parent.children[<span class="number">0</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = parent.children[<span class="number">1</span>];</span><br><span class="line">        parent.children[<span class="number">1</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">0</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldChild == parent.children[<span class="number">1</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">1</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">2</span>] = child01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>建立新连接需要判断这个节点 oldChild 是父节点的左、中、右，之后进行依次的更换。</li>
<li>如拆分节点的介绍图中，用到的就是 <code>parent.children[1] = child02;parent.children[0] = child01;</code> 两步操作过程。</li>
</ul>
<ul>
<li><em><strong>新增节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录元素</span></span><br><span class="line">    elementList.add(e);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = insert(e, root);</span><br><span class="line">        <span class="keyword">if</span> (root.number == <span class="number">3</span>) &#123;</span><br><span class="line">            root = split(root, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.isLeaf()) &#123;</span><br><span class="line">        parent.insert(e);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node_2_3</span> <span class="variable">child</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent.number == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; parent.getMiddleItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getRight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.number == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.split(child, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增节点的过程就比较简单了，一种是使用递归找到可以插入的位置，另外一种就是 where 循环。我们再BST、AVL两种数据结构种都是用了 where 循环。</li>
<li>在2-3树中 insert 方法递归到对应的插入位置后，开始插入元素。当插入元素结束后判断这个节点是否已经达到了3个节点，如果是则进行拆分。<em>拆分就调用了上面的步骤</em></li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>2-3树的数据结构描述</strong></li>
</ul>
<p>​	每个节点包含1-2个键值和2-3个子节点指针，2节点存储1个键，3节点存储2个键（按大小排序），所有叶子节点在同一层，满足搜索树性质。</p>
<ul>
<li><strong>2-3树一个节点最多可以存放几个元素</strong></li>
</ul>
<p>​	2-3树一个节点最多存放2个元素（3节点包含2个键值）。</p>
<ul>
<li><strong>2-3树插入节点时间复杂度</strong></li>
</ul>
<p>​	O(log n)，因为树高度为O(log n)且插入时最多向上分裂到根节点。</p>
<ul>
<li><strong>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></strong></li>
</ul>
<p>​	中间元素上移到父节点，左右元素分裂成两个2节点，不需要旋转操作，只需要节点分裂和元素上移。</p>
<ul>
<li><strong>2-3树，你能手写一下吗？</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node23</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];        <span class="comment">// 最多2个键</span></span><br><span class="line">    Node23[] children = <span class="keyword">new</span> <span class="title class_">Node23</span>[<span class="number">3</span>]; <span class="comment">// 最多3个子节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">keyCount</span> <span class="operator">=</span> <span class="number">0</span>;               <span class="comment">// 当前键的数量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> <span class="literal">true</span>;          <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is2Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is3Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/2-3%E6%A0%91/" data-id="cmdwr17wp000078qqgnnd6ql5" data-title="2-3树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-平衡二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T02:30:39.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="AVL树数据结构"><a href="#AVL树数据结构" class="headerlink" title="AVL树数据结构"></a>AVL树数据结构</h4><p>AVL 自平衡二叉树的出现，其目的在于解决二叉搜索树退化成链表的问题。当我们向BST二叉搜索树顺序存入<code>1、2、3、4、5、6、7</code>个元素时，它会退化成一条链表，因而失去树查询的时间复杂度，所以我们需要AVL树平衡树高。如图所示</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/AVL%E6%A0%91.png" alt="AVL"></p>
<p>那么AVL树是怎么平衡树高的呢？</p>
<p>当二叉树的左右分支树高差不为1时，需要进行左旋或者右旋，来调衡树高。这有点像开车的时候，如果车头偏左就往右打方向盘，车头偏右就往左打方向盘是一个道理。那这个方向盘(左旋、右旋)是怎么打的呢，主要分以下四种情况；</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/4.png" alt="4"></p>
<ul>
<li>节点树高：以节点4为说明，最长的左右分支节点个数，就是节点4的最大树高。这里节点4左右孩子节点最长路径都为2，所以它的树高为2。同理可计算其他节点树高。</li>
<li>平衡因子：通过当前节点的左右子节点作差计算平衡因子，之后AVL树通过平衡因子，定义了什么时候进行左旋和右旋。</li>
</ul>
<hr>
<h4 id="AVL树代码实现"><a href="#AVL树代码实现" class="headerlink" title="AVL树代码实现"></a>AVL树代码实现</h4><p>对于 AVL 树的实现与 BST 二叉搜索树相比，在树的节点定义上多了一个树高的属性。也有些AVL树使用的是平衡因子的属性，就是通过树高计算后的结果。树节点代码结构如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>图解左旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E6%97%8B.png" alt="左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.right;              <span class="comment">// 保存右子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 右子节点继承原节点的父节点</span></span><br><span class="line">  </span><br><span class="line">    node.right = temp.left;              <span class="comment">// 原节点的右子树变为右子节点的左子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;            <span class="comment">// 如果新的右子树不为空</span></span><br><span class="line">        node.right.parent = node;        <span class="comment">// 设置新右子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    temp.left = node;                    <span class="comment">// 原节点成为右子节点的左子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为右子节点</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>左旋的作用，相当于通过向上迁移树高差大于1的右子节点来降低树高的操作。</li>
<li>通过节点4拿到父节点2和右子节点5，把父节点2和右子节点5建立关联</li>
<li>节点5的左子节点，相当于是大于4的那么一个值，只不过这里不体现。那么这个节点5的左子节点，应该被迁移到节点4的右子节点上。</li>
<li>整理节点5的关系，左子节点为4。左子节点4的父节点为5</li>
<li>如果说迁移上来的节点5无父节点，那么它就是父节点 root &#x3D; temp</li>
<li>迁移上来的节点5，找到原节点4是对应父节点的左子节点还是右子节点，对应的设置节点5的左右位置</li>
</ol>
<h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>图解右旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateRight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;               <span class="comment">// 保存左子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 左子节点继承原节点的父节点</span></span><br><span class="line">    </span><br><span class="line">    node.left = temp.right;              <span class="comment">// 原节点的左子树变为左子节点的右子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;             <span class="comment">// 如果新的左子树不为空</span></span><br><span class="line">        node.left.parent = node;         <span class="comment">// 设置新左子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp.right = node;                   <span class="comment">// 原节点成为左子节点的右子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为左子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="左旋-右旋-右旋-左旋"><a href="#左旋-右旋-右旋-左旋" class="headerlink" title="左旋 + 右旋&#x2F;右旋 + 左旋"></a>左旋 + 右旋&#x2F;右旋 + 左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (factor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node.left);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.left = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (factor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node.right);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.right = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>AVL 树平衡因子怎么计算？</strong></li>
</ul>
<p>​	AVL树平衡因子 &#x3D; 左子树高度 - 右子树高度，取值范围[-1,0,1]，超出范围需旋转调整。</p>
<ul>
<li><strong>AVL 树左旋操作的目的是什么？</strong></li>
</ul>
<p>​	将右偏重的子树通过左旋转换为平衡状态，消除右子树过高导致的不平衡。</p>
<ul>
<li><strong>AVL 树左旋操作的流程是什么？</strong></li>
</ul>
<p>​	将右子节点提升为新根，原根节点下沉为新根的左子节点，原右子节点的左子树转移给原根节点作为右子树，最后重新连接所有父子关	系。</p>
<ul>
<li><strong>AVL 树什么情况下要左旋+右旋？</strong></li>
</ul>
<p>​	当左子树的右子树过高导致左-右型不平衡时，先对左子节点左旋，再对根节点右旋。</p>
<ul>
<li><strong>AVL 树的插入和读取的时间复杂度？</strong></li>
</ul>
<p>​	插入和查找都是O(log n)，因为AVL树通过自平衡保证树高度始终为O(log n)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cmdwr17x3000t78qq94q020ts" data-title="平衡二叉树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二分搜索树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T08:42:25.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">二分搜索树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="二叉搜索树的数据结构"><a href="#二叉搜索树的数据结构" class="headerlink" title="二叉搜索树的数据结构"></a>二叉搜索树的数据结构</h4><p>二叉搜索树（Binary Search Tree），也称二叉查找树。如果你看见有序二叉树（Ordered Binary tree）、排序二叉树（Sorted Binary Tree）那么说的都是一个东西。</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>二叉搜索树也是一颗没有经过调衡的基础性数据结构，在一定概率上它完成有可能退化成链表，也就是从近似O(logn)的时间复杂度退化到O(n)。关于二叉搜索树的平衡解决方案，包括；AVL树、2-3树、红黑树等。</p>
<hr>
<h4 id="二叉搜索树结构实现"><a href="#二叉搜索树结构实现" class="headerlink" title="二叉搜索树结构实现"></a>二叉搜索树结构实现</h4><p>二叉搜索树是整个树结构中最基本的树，同时也是树这个体系中实现起来最容易的数据结构。但之所以要使用基于二叉搜索树之上的其他树结构，主要是因为使用数据结构就是对数据的存放和读取。那么为了提高吞吐效率，则需要尽可能的平衡元素的排序，体现在树上则需要进行一些列操作，所以会有不同的结构树实现。</p>
<ul>
<li><em><strong>树枝定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer value;</span><br><span class="line"><span class="keyword">public</span> Node parent;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于组成一颗树的节点，则需要包括；值和与之关联的三角结构，一个父节点、两个孩子节点。如果是AVL树还需要树高，红黑树还需要染色标记。</li>
</ul>
<ul>
<li><em><strong>插入节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引出待插入元素位置，也就是插入到哪个父元素下</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">search</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (search != <span class="literal">null</span> &amp;&amp; search.value != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = search;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; search.value) &#123;</span><br><span class="line">            search = search.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            search = search.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (parent.value &gt; newNode.value) &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断插入元素时候是否有树根，没有则会把当前节点创建出一颗树根来。</li>
<li>如果当前树是有树根的，则对插入元素与当前树进行一个节点遍历操作，找到元素可以插入的索引位置 parent（挂到这个父节点下）。也就是 search 搜索过程。</li>
<li>最后就是插入元素，通过给插入值创建一个 Node 节点，并绑定它的父元素，以及把新元素挂到索引到的 parent 节点下。</li>
</ul>
<ul>
<li><em><strong>索引节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.value != <span class="literal">null</span> &amp;&amp; node.value != e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; node.value) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值查找的过程，就是对二叉搜索树的遍历，不断的循环节点，按照节点值的左右匹配，找出最终相当的值节点。</li>
</ul>
<ul>
<li><em><strong>删除节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">delNode</span> <span class="operator">=</span> search(e);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == delNode) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> delete(delNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node delNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (delNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为删除的节点，有2个孩子节点，这个时候找到这条分支下，最左侧做小的节点。用它来替换删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">miniNode</span> <span class="operator">=</span> getMiniNode(delNode.right);</span><br><span class="line">        <span class="keyword">if</span> (miniNode.parent != delNode) &#123;</span><br><span class="line">            <span class="comment">// 交换位置，用miniNode右节点，替换miniNode</span></span><br><span class="line">            transplant(miniNode, miniNode.right);</span><br><span class="line">            <span class="comment">// 把miniNode 提升父节点，设置右子树并进行挂链。替代待删节点</span></span><br><span class="line">            miniNode.right = delNode.right;</span><br><span class="line">            miniNode.right.parent = miniNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置，删除节点和miniNode 可打印测试观察；System.out.println(this);</span></span><br><span class="line">        transplant(delNode, miniNode);</span><br><span class="line">        <span class="comment">// 把miniNode 提升到父节点，设置左子树并挂链</span></span><br><span class="line">        miniNode.left = delNode.left;</span><br><span class="line">        miniNode.left.parent = miniNode;</span><br><span class="line">        result = miniNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">transplant</span><span class="params">(Node delNode, Node addNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除元素是左/右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delNode.parent.left == delNode) &#123;</span><br><span class="line">        delNode.parent.left = addNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delNode.parent.right = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addNode) &#123;</span><br><span class="line">        addNode.parent = delNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有右子树</strong></p>
<ul>
<li>直接用右子树替换删除节点</li>
</ul>
<p><strong>只有左子树</strong></p>
<ul>
<li>直接用左子树替换删除节点</li>
</ul>
<p><strong>有两个子树</strong></p>
<ul>
<li>找到右子树中的最小节点（后继节点）</li>
<li>用后继节点替换删除节点</li>
<li>处理后继节点的原位置</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li>
</ul>
<p>​	基本性质：左子树 &lt; 根节点 &lt; 右子树，中序遍历有序，平均O(log n)操作复杂度。</p>
<p>​	核心操作：查找（比较递归）、插入（找位置插入）、删除（三种情况：0&#x2F;1&#x2F;2个子节点）。</p>
<p>​	主要变体：AVL树（自平衡）、红黑树（着色平衡）、B树（多路）、线索二叉树（利用空指针）。核心目标都是避免退化成链表，保持O(log n)性能。</p>
<ul>
<li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li>
</ul>
<p>​	平均情况：插入、删除、查找都是 O(log n)。最坏情况：当树退化成链表时（如顺序插入），所有操作变成 O(n)。关键：平衡二叉树通过自平衡保证最坏情况也是 O(log n)。</p>
<ul>
<li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li>
</ul>
<p>​	核心思路 ：找到右子树中的最小节点（后继节点）来替换被删除节点。</p>
<p>​	具体步骤：1）找到右子树最左侧的最小节点；2）如果最小节点不是右子树根，先将其右子树移植到原位置；3）用最小节点替换被删除节点，重新连接左右子树和父节点关系。</p>
<p>​	原理：右子树最小节点值刚好大于左子树所有值且小于右子树其余值，替换后仍保持BST性质。</p>
<ul>
<li><strong>二叉搜索树的节点都包括了哪些信息</strong></li>
</ul>
<p>​	基本信息：节点值（key&#x2F;data）、左子节点指针、右子节点指针。可选信息：父节点指针（便于向上遍历和删除操作）。扩展信息：节点颜色（红黑树）、平衡因子（AVL树）、子树大小等附加属性。</p>
<p>​	核心结构：<code>&#123;value, left, right, parent&#125;</code>，其中parent可选但常用。</p>
<ul>
<li><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></li>
</ul>
<p>​	核心问题：普通二叉搜索树在最坏情况下会退化成链表，时间复杂度从O(log n)恶化到O(n)。<strong>红黑树优势</strong>：通过着色和旋转机制保证树的近似平衡，确保最坏情况下仍是O(log n)。<strong>HashMap场景</strong>：哈希冲突时链表过长影响性能，红黑树能稳定保证查找效率，避免恶意构造数据导致性能攻击。</p>
<p>​	简单说：红黑树是自平衡的BST，防止极端情况下性能退化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" data-id="cmdwr17wx000678qq0kn8dsg2" data-title="二分搜索树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字典树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T03:05:39.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/">字典树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="字典树数据结构"><a href="#字典树数据结构" class="headerlink" title="字典树数据结构"></a>字典树数据结构</h4><p>在计算机科学中，字典树(Trie)也被称为”单词查找树“或”数字树“，有时候也被称为基数树或前缀树（因为可以通过前缀的方式进行索引）。—— 它是一种搜索树，一种已排序的数据结构，通常用于存储动态集或键为字符串的关联数组。</p>
<p>与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<hr>
<h4 id="字典树结构实现"><a href="#字典树结构实现" class="headerlink" title="字典树结构实现"></a>字典树结构实现</h4><p>字典树字母的存放有26个，也就是说在实现的过程中，每一个节点的分支都有26个槽位用来存放可能出现的字母组合。同理如果是数字树的话就是10个数字的组合，每个字典树上的节点对应的分支则有10个操作存放可能出现组合的数字。</p>
<ul>
<li><em><strong>树枝节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 形成一个链 */</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] slot = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字母 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：数量 &gt; 0 表示一个单词 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前缀 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：具体的一个单词字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String word;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解释：单词的注释说明 */</span></span><br><span class="line">    <span class="keyword">public</span> String explain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字典的树的节点需要包括此节点内嵌的关联节点，之后是节点的字母、到此字母是否为单词、单词的前缀、单词字符串和当前单词的非必要注释。</li>
</ul>
<ul>
<li><em><strong>插入元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String words, String explain)</span> &#123; <span class="comment">// 插入单词及其解释到字典树</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = words.toCharArray(); <span class="comment">// 将单词转为字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算字符在 slot 数组中的下标（假设都是小写字母）</span></span><br><span class="line">        <span class="keyword">if</span> (root.slot[idx] == <span class="literal">null</span>) &#123; <span class="comment">// 如果对应子节点不存在</span></span><br><span class="line">            root.slot[idx] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>(); <span class="comment">// 创建新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        root.c = c; <span class="comment">// 记录当前字符</span></span><br><span class="line">        root.prefix++; <span class="comment">// 前缀计数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    root.explain = explain; <span class="comment">// 存储单词的解释说明</span></span><br><span class="line">    root.isWord = <span class="literal">true</span>;     <span class="comment">// 标记该节点为单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png" alt="插入元素"></p>
<ul>
<li>insert 方法接收单词和注释信息，并对一个单词按照 char 进行拆分，拆分后则计算出索引位置并以此存放。存放完成后标记单词和附属上单词的注释信息。</li>
</ul>
<ul>
<li><em><strong>索引元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123; <span class="comment">// 查找所有以 prefix 为前缀的单词</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = prefix.toCharArray(); <span class="comment">// 将前缀转为字符数组</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 用于缓存已匹配的前缀</span></span><br><span class="line">    <span class="comment">// 精准匹配：根据前缀逐步查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历前缀的每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算下标</span></span><br><span class="line">        <span class="comment">// 匹配为空，前缀不存在</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; root.slot.length || idx &lt; <span class="number">0</span> || root.slot[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// 没有匹配，返回空列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        cache.append(c); <span class="comment">// 缓存当前字符</span></span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模糊匹配：递归查找所有以 prefix 开头的单词</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">if</span> (root.prefix != <span class="number">0</span>) &#123; <span class="comment">// 如果有以该前缀开头的单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.slot.length; i++) &#123; <span class="comment">// 遍历所有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 计算字符</span></span><br><span class="line">                collect(root.slot[i], String.valueOf(cache) + c, list, <span class="number">15</span>); <span class="comment">// 递归收集单词，最多15个</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt;= <span class="number">15</span>) &#123; <span class="comment">// 达到上限提前返回</span></span><br><span class="line">                    <span class="keyword">return</span> list;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(TrieNode trieNode, String pre, List&lt;String&gt; queue, <span class="type">int</span> resultLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到单词</span></span><br><span class="line">    <span class="keyword">if</span> (trieNode.isWord) &#123; <span class="comment">// 当前节点是单词结尾</span></span><br><span class="line">        trieNode.word = pre; <span class="comment">// 记录完整单词</span></span><br><span class="line">        <span class="comment">// 保存检索到的单词和解释到 queue</span></span><br><span class="line">        queue.add(trieNode.word + <span class="string">&quot; -&gt; &quot;</span> + trieNode.explain);</span><br><span class="line">        <span class="keyword">if</span> (queue.size() &gt;= resultLimit) &#123; <span class="comment">// 达到结果上限</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用，查找所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trieNode.slot.length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i); <span class="comment">// 计算字符</span></span><br><span class="line">        <span class="keyword">if</span> (trieNode.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">            collect(trieNode.slot[i], pre + c, queue, resultLimit); <span class="comment">// 递归收集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E7%B4%A2%E5%BC%95.png" alt="索引"></p>
<ul>
<li>从字典树从检索元素的过程分为2部分，第1部分是根据提供的索引前缀精准匹配到单词信息，第2部分是根据索引前缀的最后一个单词开始，循环递归遍历从当前位置所能关联到的字母直至判断为是单词标记为结束，通过这样的方式把所有匹配动的单词索引出来。</li>
<li>list.size() &gt;&#x3D; 15 是判定索引的最大长度，超过这个数量就停止索引了，毕竟这是一种O(n)时间复杂度的操作，如果加载数十万单词进行匹配，执行速度还是比较耗时的。</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>简述字典树的数据结构</strong></li>
</ul>
<p>​	本质： 树形结构存储字符串，共享公共前缀</p>
<p>​	结构：</p>
<ul>
<li>节点存储字符</li>
<li>路径 &#x3D; 字符串</li>
<li>标记单词结尾</li>
</ul>
<p>​	复杂度： O(字符串长度)</p>
<p>​	用途： 自动补全、前缀匹配、拼写检查</p>
<p>​	优势： 前缀查询快，节省空间</p>
<ul>
<li><strong>叙述你怎么来实现一个字典树</strong></li>
</ul>
<p>​	子节点数组（26个字母）</p>
<p>​	布尔标记（是否单词结尾）</p>
<p>​	插入： 逐字符遍历，不存在就创建节点，最后标记结尾</p>
<p>​	查找：*逐字符遍历，检查路径是否存在且标记为单词</p>
<p>​	前缀查询： 遍历到前缀末尾即可</p>
<p>​	关键点： 字符映射到数组索引，路径即字符串</p>
<ul>
<li><strong>字典树的实际业务场景举例【排序、全文搜索、网络搜索引擎、生物信息】</strong></li>
</ul>
<p>​	字符串字典序排序\关键词索引构建\查询补全\DNA序列匹配</p>
<p>​	<strong>核心优势：</strong> 前缀匹配效率高，特别适合大规模字符串集合的快速检索场景。</p>
<ul>
<li><strong>字典树的存入和检索的时间复杂度</strong></li>
</ul>
<p>​	存入（Insert）：O(m)</p>
<p>​	检索（Search）：O(m)</p>
<p>​	前缀查找：O(p)</p>
<p>​	其中 m 是字符串长度，p 是前缀长度(字典树是典型的<strong>空间换时间</strong>的数据结构，特别适合字符串查找和前缀匹配场景。)</p>
<ul>
<li><strong>还有哪些字典树的实现方式</strong></li>
</ul>
<ol>
<li><p>数组实现</p>
<p>固定大小数组存储子节点</p>
<ul>
<li>优点：O(1)访问速度</li>
<li>缺点：空间浪费</li>
</ul>
</li>
<li><p>哈希表实现</p>
<p>HashMap存储子节点</p>
<ul>
<li>优点：空间高效，支持任意字符集</li>
<li>缺点：哈希冲突影响性能</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" data-id="cmdwr17x2000n78qq3m1eajlp" data-title="字典树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%A0%86/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T01:44:53.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%A0%86/">堆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h4><p>在计算机科学中，<strong>堆(heap)</strong> 的实现是一种基于树的特殊的数据结构，它可以在数组上构建出树的结构体，并满足堆的属性；</p>
<ul>
<li><p>最小堆：如果<code>P</code> 是 <code>C</code> 的一个父级节点， 那么 <code>P</code> 的key(或value)应小于或等于 <code>C</code> 的对应值。</p>
</li>
<li><p>最大堆：与最小堆的定义正好相反，最大堆(max heap) , <code>P</code> 的key(或value)大于 <code>C</code> 的对应值。</p>
</li>
</ul>
<hr>
<h4 id="堆的代码实现"><a href="#堆的代码实现" class="headerlink" title="堆的代码实现"></a>堆的代码实现</h4><ul>
<li><em><strong>实现介绍</strong></em></li>
</ul>
<p>堆的实现在 Java API 中主要体现在延迟队列的实现二叉堆上，这里小傅哥单独把这部分代码拆分出来，了解下关于小堆和大堆的实现。</p>
<p>从对堆的数据结构介绍上可以看到，小堆和大堆的唯一区别仅是对元素的排序方式不同。所以也就是说在存放和获取元素的时候对元素的填充和摘除时，排序方式不同而已。</p>
<ul>
<li><em><strong>入堆实现</strong></em></li>
</ul>
<p>堆的在存放元素时，以遵循它的特点，会在存放过程中，通过队尾元素向上比对迁移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】元素：&#123;&#125; 当前队列：&#123;&#125;&quot;</span>, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点Idx，相当于除以2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        logger.info(<span class="string">&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;</span>, k, parent);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="comment">// 如果当前位置元素，大于父节点元素，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;</span>, JSON.toJSONString(e), JSON.toJSONString(x));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相反父节点位置大于当前位置元素，则进行替换</span></span><br><span class="line">        logger.info(<span class="string">&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;</span>, JSON.toJSONString(e), k);</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \r\n当前队列：&#123;&#125; \r\n&quot;</span>, k, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>入堆的实现 add 方法最终会调用到 siftUpComparable 方法，进行排序的方式进行处理。而这个排序 compareTo 方法是由具体的 MinHeap、MaxHeap 来做实现。</li>
<li>以入堆元素2举例，如图所示入堆过程。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%85%A5%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="入堆实现"></p>
<ul>
<li>首先将元素2挂到队列尾部，之后通过 (k - 1) &gt;&gt;&gt; 1 计算父节点位置，与对应元素进行比对和判断交换。</li>
<li>交换过程包括 2-&gt;6、2-&gt;5，以此交换结束后元素保存完毕。</li>
</ul>
<ul>
<li><em><strong>出堆实现</strong></em></li>
</ul>
<p>元素的出堆其实很简单，只要把根元素直接删除弹出即可。但剩余接下里的步骤才是复杂的，因为需要在根元素迁移走后，寻找另外的最小元素迁移到对头。这个过程与入堆正好相反，这是一个不断向下迁移的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="comment">// 先找出中间件节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 找到左子节点和右子节点，两个节点进行比较，找出最大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子节点与右子节点比较，取最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; compareTo((E) c, (E) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;</span>, JSON.toJSONString(c), JSON.toJSONString(queue[right]));</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) c) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值小于c值，位置替换，继续比较</span></span><br><span class="line">        logger.info(<span class="string">&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;</span>, JSON.toJSONString(queue[k]), JSON.toJSONString(c));</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把目标值放到对应位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;</span>, k, JSON.toJSONString(x));</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不断地向下迁移元素。这个过程会比对左右子节点的值，找到最小的。所以整个过程会比入堆麻烦一些。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%87%BA%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="出堆实现"></p>
<p>这里以弹出元素1举例，之后将堆尾元素替换到相应的位置。整个过程分为6张图表述。</p>
<ol>
<li>图1到图2，找出根元素弹出。</li>
<li>图3到图4，将根元素向下迁移，与子元素比对，并替换位置。如果这个位置与8相比，小于8则继续向下迁移。</li>
<li>图4到图5，继续迁移，在原节点4的位置对应的两个子元素，都比8大，这个时候就可以停下来了。</li>
<li>图5到图6，更换元素位置，把队尾的元素替换到对应元素1向下迁移检测的位置。</li>
</ol>
<ul>
<li><em><strong>最小堆（MinHeap）和最大堆（MaxHeap）</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstElement.compareTo(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> secondElement.compareTo(firstElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用：实现最小堆。</p>
<ul>
<li><p>原理：compareTo 返回 firstElement.compareTo(secondElement)，即：</p>
</li>
<li><p>如果 firstElement &lt; secondElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最小的元素。</p>
</li>
</ul>
</li>
<li><p>作用：实现最大堆。</p>
<ul>
<li><p>原理：compareTo 返回 secondElement.compareTo(firstElement)，即：</p>
</li>
<li><p>如果 secondElement &lt; firstElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最大的元素。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>堆的数据结构是什么样？</strong></li>
</ul>
<p>​	堆是一种完全二叉树结构，通常用数组实现。</p>
<ul>
<li><p>最大堆：每个节点的值都大于等于其子节点（堆顶是最大值）。</p>
</li>
<li><p>最小堆：每个节点的值都小于等于其子节点（堆顶是最小值）。</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li><p>父子节点通过数组下标可以快速定位（如父节点下标为 i，左子为 2i+1，右子为 2i+2）。</p>
</li>
<li><p>结构紧凑，没有“空洞”。</p>
</li>
<li><p><strong>堆的数据结构使用场景？</strong></p>
</li>
</ul>
<p>​	堆常用于优先队列（如任务调度）、排序算法（堆排序）、动态获取最大&#x2F;最小值（如实时统计Top K）、图算法（如Dijkstra最短路径）等需要频繁取最大&#x2F;最小元素的场景。</p>
<ul>
<li><strong>堆的数据结构实现方式有哪些？</strong></li>
</ul>
<ol>
<li>数组实现（最常用）</li>
</ol>
<p>​		利用完全二叉树的性质，父子节点通过下标计算关联，结构紧凑，效率高。</p>
<ol start="2">
<li>链式二叉树实现</li>
</ol>
<p>​		用指针（引用）连接父子节点，结构灵活，但空间利用率和访问效率不如数组。</p>
<ol start="3">
<li>多路堆（如d叉堆）</li>
</ol>
<p>​		可以用数组或链表实现，每个节点有 d 个子节点，适合特殊场景（如堆优化的优先队列）。</p>
<ul>
<li><strong>最小堆和最大堆的区别是什么？</strong></li>
</ul>
<p>​	最小堆和最大堆的区别在于堆顶元素的大小关系：</p>
<ul>
<li><p>最小堆：每个节点的值都小于等于其子节点，堆顶是最小值。</p>
</li>
<li><p>最大堆：每个节点的值都大于等于其子节点，堆顶是最大值。</p>
</li>
</ul>
<p>用途不同：</p>
<ul>
<li><p>最小堆适合快速获取最小元素。</p>
</li>
<li><p>最大堆适合快速获取最大元素。</p>
</li>
<li><p><strong>有了解斐波那契堆吗？</strong></p>
</li>
</ul>
<p>​	斐波那契堆（Fibonacci Heap）是一种<strong>高级堆数据</strong>结构，支持更快的合并（合并两个堆）、插入和减少键值等操作，适用于<strong>需要大量合并和减少最小值操作</strong>的场景（如Dijkstra最短路径算法）。它的结构比普通二叉堆复杂，操作的<strong>摊还时间复杂度更低</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%A0%86/" data-id="cmdwr17x0000g78qqc5fp7gk1" data-title="堆" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" rel="tag">创建文章</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" style="font-size: 10px;">创建文章</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">工具学习</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E9%87%8D%E7%82%B9/" style="font-size: 15px;">重点</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/01/Java/">Java</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%9B%BE/">图</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>
          </li>
        
          <li>
            <a href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>