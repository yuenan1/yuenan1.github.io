<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-红黑树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T08:59:18.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="红黑树数据结构"><a href="#红黑树数据结构" class="headerlink" title="红黑树数据结构"></a>红黑树数据结构</h4><p>建立在 BST 二叉搜索树的基础上，AVL、2-3树、红黑树都是自平衡二叉树（统称B-树）。但相比于AVL树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。也正因红黑树在插入和删除时不需要太多的平衡操作，也让它成为；Java中HashMap的元素碰撞后的转换、Linux的CFS进行调度算法、多路复用技术的Epoll等各类底层的数据结构实现。</p>
<p>红黑树的五条定义：</p>
<ol>
<li><strong>每个节点不是红色就是黑色。</strong><ul>
<li>黑色决定平衡，红色不决定平衡。这对应了2-3树中一个节点内可以存放1~2个节点。</li>
</ul>
</li>
<li><strong>根是黑色的。</strong><ul>
<li>这条规则有时会被省略。由于根总是可以从红色变为黑色，但不一定相反，因此该规则对分析几乎没有影响。</li>
</ul>
</li>
<li><strong>所有叶子 (NIL) 都是黑色的。</strong><ul>
<li>这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。</li>
</ul>
</li>
<li><strong>如果一个节点是红色的，那么它的两个子节点都是黑色的。</strong><ul>
<li>通常这条规则也叫不会有连续的红色节点。这体现在2-3树中，一个节点最多临时会有3个节点，中间是黑色节点，左右是红色节点。2-3树中出现这样的情况后，会进行节点迁移，中间节点成为父节点，左右节点成为子节点。</li>
</ul>
</li>
<li><strong>从给定节点到其任何后代 NIL 节点的每条路径都包含相同数量的黑色节点。</strong><ul>
<li>对应2-3树中，每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="红黑树结构实现"><a href="#红黑树结构实现" class="headerlink" title="红黑树结构实现"></a>红黑树结构实现</h4><p>基于 BST 二叉搜索树的基础上，AVL树添加了树高作为计算平衡因子的条件，那么红黑树也需要添加一个新的颜色属性，用于处理平衡操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">// 红黑树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.RED;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>相比于AVL树通过左右旋转平衡树高，红黑树则是在2-3树的基础上，只对黑色节点维护树高，所以它会使用到染色和左右旋来对树高调衡。<em>染色与左右旋相比，减少了平衡操作</em></p>
<ul>
<li><em><strong>左倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="左倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.right;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span> (uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current = grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>右倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="右倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.left;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span>(uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current= grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>左旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次左旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%B7%A6%E6%97%8B.png" alt="一次左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的左侧小图，新增的节点5导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点4提起来，而对应红黑树则需要先进行染色，待操作的节点4为黑色，两个孩子节点为红色。</li>
<li>最后是把节点3进行一次左旋操作，完成树的平衡。对应步骤3中的左侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>右旋+左旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要右旋+左旋的情况，在AVL树中有同样的场景。本身树需要左旋操作，但整体分支树节点偏左，此时需要右旋调整树结构再左旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%2B%E5%B7%A6.png" alt="右左"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏左↙，先右旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.left)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateRight(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点4以后，4↙5 结构偏左，需要先进行右旋调衡树结构，再进行左旋。其实这个时候再进行的左旋就和上面一次左旋操作一致了。</li>
</ul>
<ul>
<li><em><strong>右旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次右旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的右侧小图，新增的节点1导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点2提起来，而对应红黑树则需要先进行染色，待操作的节点2为黑色，两个孩子节点为红色。</li>
<li>最后是把节点2进行一次右旋操作，完成树的平衡。对应步骤3中的右侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>左旋+右旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要左旋+右旋的情况，在AVL树中有同样的场景。本身树需要右旋操作，但整体分支树节点偏右，此时需要左旋调整树结构再右旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%2B%E5%8F%B3.png" alt="左右"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏右↘，先左旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.right)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateLeft(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点2以后，1↘2 结构偏右，需要先进行左旋调衡树结构，再进行右旋。其实这个时候再进行的右旋就和上面一次右旋操作一致了。</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>红黑树都有哪些使用场景？</strong></li>
</ul>
<p><strong>红黑树使用场景</strong>：Java TreeMap&#x2F;TreeSet、C++ STL的map&#x2F;set、Linux内核进程调度、数据库索引结构、编译器符号表、内存管理	器、高性能缓存系统等需要稳定O(log n)性能的场景。</p>
<p><strong>核心优势</strong>：相比AVL树旋转次数少，相比普通BST保证平衡，适合频繁插入删除的应用。</p>
<ul>
<li><strong>相比于BST树，红黑树有什么用途？</strong></li>
</ul>
<p><strong>红黑树相比BST的用途</strong>：解决BST最坏情况退化成链表的问题，通过着色和旋转机制保证树的近似平衡，确保查找、插入、删除操作始终维持O(log n)时间复杂度，避免性能恶化。</p>
<p><strong>关键作用</strong>：防止恶意数据攻击导致的性能退化，提供稳定可预期的性能保证。</p>
<ul>
<li><strong>B-树是什么意思，都包括哪些？</strong></li>
</ul>
<p><strong>B-树定义</strong>：多路平衡搜索树，每个节点可存储多个键值和子节点，所有叶子节点在同一层。</p>
<p><strong>主要类型</strong>：B树（内部节点和叶子节点都存数据）、B+树（只有叶子节点存数据，内部节点只存索引）、B*树（B+树的优化版本，节点利用率更高）。</p>
<p><strong>核心用途</strong>：数据库索引、文件系统，因为减少磁盘I&#x2F;O次数，适合大数据量存储。</p>
<ul>
<li><strong>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</strong></li>
</ul>
<p><strong>染色情况</strong>：父节点和叔叔节点都是红色时，将父节点、叔叔节点染黑，祖父节点染红。</p>
<p><strong>左旋情况</strong>：父节点是红色、叔叔节点是黑色，且新节点是父节点的右子节点时。</p>
<p><strong>左旋+右旋情况</strong>：父节点是红色、叔叔节点是黑色，新节点是父节点的左子节点，但父节点是祖父节点的右子节点时（右-左型不平衡）。</p>
<p><strong>核心原则</strong>：通过染色、旋转保持红黑树的5个性质不被破坏。</p>
<ul>
<li><strong>红黑树的特点是什么？</strong></li>
</ul>
<p><strong>红黑树特点</strong>：节点非红即黑、根节点是黑色、红节点的子节点必须是黑色、从任一节点到叶子节点的路径包含相同数量的黑节点、叶子节点（NIL）是黑色。</p>
<p><strong>核心优势</strong>：自平衡、最坏情况仍保证O(log n)性能、相比AVL树旋转次数少、插入删除效率高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" data-id="cmdnybnxy000w0kqq154x1hdj" data-title="红黑树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2-3树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/2-3%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T07:57:52.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/2-3%E6%A0%91/">2-3树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="2-3树数据结构"><a href="#2-3树数据结构" class="headerlink" title="2-3树数据结构"></a>2-3树数据结构</h4><p>2–3树是一种树型数据结构，由约翰·霍普克洛夫特于1970年发明。它通过在一个节点存放1-2个元素来平衡树高。从而也使2-3树存在2叉节点和3叉节点。</p>
<p><img src="https://bugstack.cn/images/article/algorithm/tree-23-01.png?raw=true" alt="img"></p>
<p>这里要提到一点，在BST二叉搜索树可能退化成链表的基础上。引出了自平衡二叉树，也就是包括上一章实现的AVL树和Java API HashMap中用到的红黑树，它们都属于BalancedTree，也统称为B树，平衡的意思。</p>
<p>而本章实现的2-3树也是一种简单的平衡树，其中每个具有子节点（内部节点）的节点要么有两个子节点（2 节点）和一个数据元素，要么有三个子节点（3 节点）和两个数据元素。另外 2-3 树是3阶B 树，2-3-4 树是4阶B树。</p>
<hr>
<h4 id="2-3树结构实现"><a href="#2-3树结构实现" class="headerlink" title="2-3树结构实现"></a>2-3树结构实现</h4><ul>
<li><em><strong>节点定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node_2_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="comment">// 孩子</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3[] children;</span><br><span class="line">    <span class="comment">// 父亲【非必须】</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3 parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node_2_3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">this</span>.number = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="built_in">this</span>.number - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.items[idx] &lt; e) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = <span class="built_in">this</span>.items[idx];</span><br><span class="line">            --idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = e;</span><br><span class="line">        ++<span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2-3树的几点元素需要包括；一个数组的元素集合、元素的序号、孩子元素。因为一个节点最多可临时放入3个元素，那么就会最多有4个孩子元素，所以孩子元素也是一个数组并且在构造函数中按照4个元素进行初始化。</li>
<li>由于本身2-3树插入元素的开始阶段，并不是直接创建一个新的节点，而是在初始化的数组空间中存入元素。所以在节点中提供了一个插入元素的方法 insert 来处理新增元素。</li>
<li>另外2-3树的节点类，还提供了一个方便查询的方法。包括：获取左边元素、中间元素、右边元素，以及最小值、最大值和判断是否有孩子节点。这些内容可以源码。</li>
</ul>
<ul>
<li><em><strong>拆分节点</strong></em></li>
</ul>
<p>当一个节点内有3个元素的时候，就要发起拆分东西，拆分的过程分为；</p>
<ol>
<li>对3个节点的中间节点，插入到父节点上。</li>
<li>剩余2个节点创建出新的节点。</li>
<li>建立父节点和新创建的2个节点间关系。</li>
</ol>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8B%86%E5%88%86%E8%8A%82%E7%82%B9.png" alt="拆分节点"></p>
<ol>
<li>插入父节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">split</span><span class="params">(Node_2_3 node, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    parent.insert(node.getMiddleItem());</span><br><span class="line">    </span><br><span class="line">    Node_2_3[] newNodes = <span class="built_in">this</span>.triangle(node);</span><br><span class="line">    <span class="built_in">this</span>.replaceChild(parent, node, newNodes[<span class="number">0</span>], newNodes[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整个2-3树拆分的过程就是在 split 这个方法里，第一步解决了是否有父节点，没有则创建。</li>
<li>之后将原节点的中间值插入到父节点中。接下来的操作就是拆分新节点和更换孩子节点建立新连接。</li>
</ul>
<ol start="2">
<li>拆分新节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3[] triangle(Node_2_3 node) &#123;</span><br><span class="line">    Node_2_3[] newNodes = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">2</span>];</span><br><span class="line">    newNodes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">0</span>]);</span><br><span class="line">    newNodes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!node.isLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 左孩子</span></span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">0</span>] = node.children[<span class="number">0</span>];</span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">1</span>] = node.children[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 右孩子</span></span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">0</span>] = node.children[<span class="number">2</span>];</span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">1</span>] = node.children[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于传递进来的节点，将节点的左右孩子创建新节点，如果这个孩子节点还有分支节点，则一并更新。</li>
</ul>
<ol start="3">
<li>建立新连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceChild</span><span class="params">(Node_2_3 parent, Node_2_3 oldChild, Node_2_3 child01, Node_2_3 child02)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChild == parent.children[<span class="number">0</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = parent.children[<span class="number">1</span>];</span><br><span class="line">        parent.children[<span class="number">1</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">0</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldChild == parent.children[<span class="number">1</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">1</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">2</span>] = child01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>建立新连接需要判断这个节点 oldChild 是父节点的左、中、右，之后进行依次的更换。</li>
<li>如拆分节点的介绍图中，用到的就是 <code>parent.children[1] = child02;parent.children[0] = child01;</code> 两步操作过程。</li>
</ul>
<ul>
<li><em><strong>新增节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录元素</span></span><br><span class="line">    elementList.add(e);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = insert(e, root);</span><br><span class="line">        <span class="keyword">if</span> (root.number == <span class="number">3</span>) &#123;</span><br><span class="line">            root = split(root, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.isLeaf()) &#123;</span><br><span class="line">        parent.insert(e);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node_2_3</span> <span class="variable">child</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent.number == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; parent.getMiddleItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getRight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.number == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.split(child, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增节点的过程就比较简单了，一种是使用递归找到可以插入的位置，另外一种就是 where 循环。我们再BST、AVL两种数据结构种都是用了 where 循环。</li>
<li>在2-3树中 insert 方法递归到对应的插入位置后，开始插入元素。当插入元素结束后判断这个节点是否已经达到了3个节点，如果是则进行拆分。<em>拆分就调用了上面的步骤</em></li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>2-3树的数据结构描述</strong></li>
</ul>
<p>​	每个节点包含1-2个键值和2-3个子节点指针，2节点存储1个键，3节点存储2个键（按大小排序），所有叶子节点在同一层，满足搜索树性质。</p>
<ul>
<li><strong>2-3树一个节点最多可以存放几个元素</strong></li>
</ul>
<p>​	2-3树一个节点最多存放2个元素（3节点包含2个键值）。</p>
<ul>
<li><strong>2-3树插入节点时间复杂度</strong></li>
</ul>
<p>​	O(log n)，因为树高度为O(log n)且插入时最多向上分裂到根节点。</p>
<ul>
<li><strong>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></strong></li>
</ul>
<p>​	中间元素上移到父节点，左右元素分裂成两个2节点，不需要旋转操作，只需要节点分裂和元素上移。</p>
<ul>
<li><strong>2-3树，你能手写一下吗？</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node23</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];        <span class="comment">// 最多2个键</span></span><br><span class="line">    Node23[] children = <span class="keyword">new</span> <span class="title class_">Node23</span>[<span class="number">3</span>]; <span class="comment">// 最多3个子节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">keyCount</span> <span class="operator">=</span> <span class="number">0</span>;               <span class="comment">// 当前键的数量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> <span class="literal">true</span>;          <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is2Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is3Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/2-3%E6%A0%91/" data-id="cmdnybnxj00000kqq5t0i9cwx" data-title="2-3树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-平衡二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T02:30:39.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="AVL树数据结构"><a href="#AVL树数据结构" class="headerlink" title="AVL树数据结构"></a>AVL树数据结构</h4><p>AVL 自平衡二叉树的出现，其目的在于解决二叉搜索树退化成链表的问题。当我们向BST二叉搜索树顺序存入<code>1、2、3、4、5、6、7</code>个元素时，它会退化成一条链表，因而失去树查询的时间复杂度，所以我们需要AVL树平衡树高。如图所示</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/AVL%E6%A0%91.png" alt="AVL"></p>
<p>那么AVL树是怎么平衡树高的呢？</p>
<p>当二叉树的左右分支树高差不为1时，需要进行左旋或者右旋，来调衡树高。这有点像开车的时候，如果车头偏左就往右打方向盘，车头偏右就往左打方向盘是一个道理。那这个方向盘(左旋、右旋)是怎么打的呢，主要分以下四种情况；</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/4.png" alt="4"></p>
<ul>
<li>节点树高：以节点4为说明，最长的左右分支节点个数，就是节点4的最大树高。这里节点4左右孩子节点最长路径都为2，所以它的树高为2。同理可计算其他节点树高。</li>
<li>平衡因子：通过当前节点的左右子节点作差计算平衡因子，之后AVL树通过平衡因子，定义了什么时候进行左旋和右旋。</li>
</ul>
<hr>
<h4 id="AVL树代码实现"><a href="#AVL树代码实现" class="headerlink" title="AVL树代码实现"></a>AVL树代码实现</h4><p>对于 AVL 树的实现与 BST 二叉搜索树相比，在树的节点定义上多了一个树高的属性。也有些AVL树使用的是平衡因子的属性，就是通过树高计算后的结果。树节点代码结构如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>图解左旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E6%97%8B.png" alt="左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.right;              <span class="comment">// 保存右子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 右子节点继承原节点的父节点</span></span><br><span class="line">  </span><br><span class="line">    node.right = temp.left;              <span class="comment">// 原节点的右子树变为右子节点的左子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;            <span class="comment">// 如果新的右子树不为空</span></span><br><span class="line">        node.right.parent = node;        <span class="comment">// 设置新右子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    temp.left = node;                    <span class="comment">// 原节点成为右子节点的左子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为右子节点</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>左旋的作用，相当于通过向上迁移树高差大于1的右子节点来降低树高的操作。</li>
<li>通过节点4拿到父节点2和右子节点5，把父节点2和右子节点5建立关联</li>
<li>节点5的左子节点，相当于是大于4的那么一个值，只不过这里不体现。那么这个节点5的左子节点，应该被迁移到节点4的右子节点上。</li>
<li>整理节点5的关系，左子节点为4。左子节点4的父节点为5</li>
<li>如果说迁移上来的节点5无父节点，那么它就是父节点 root &#x3D; temp</li>
<li>迁移上来的节点5，找到原节点4是对应父节点的左子节点还是右子节点，对应的设置节点5的左右位置</li>
</ol>
<h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>图解右旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateRight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;               <span class="comment">// 保存左子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 左子节点继承原节点的父节点</span></span><br><span class="line">    </span><br><span class="line">    node.left = temp.right;              <span class="comment">// 原节点的左子树变为左子节点的右子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;             <span class="comment">// 如果新的左子树不为空</span></span><br><span class="line">        node.left.parent = node;         <span class="comment">// 设置新左子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp.right = node;                   <span class="comment">// 原节点成为左子节点的右子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为左子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="左旋-右旋-右旋-左旋"><a href="#左旋-右旋-右旋-左旋" class="headerlink" title="左旋 + 右旋&#x2F;右旋 + 左旋"></a>左旋 + 右旋&#x2F;右旋 + 左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (factor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node.left);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.left = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (factor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node.right);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.right = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>AVL 树平衡因子怎么计算？</strong></li>
</ul>
<p>​	AVL树平衡因子 &#x3D; 左子树高度 - 右子树高度，取值范围[-1,0,1]，超出范围需旋转调整。</p>
<ul>
<li><strong>AVL 树左旋操作的目的是什么？</strong></li>
</ul>
<p>​	将右偏重的子树通过左旋转换为平衡状态，消除右子树过高导致的不平衡。</p>
<ul>
<li><strong>AVL 树左旋操作的流程是什么？</strong></li>
</ul>
<p>​	将右子节点提升为新根，原根节点下沉为新根的左子节点，原右子节点的左子树转移给原根节点作为右子树，最后重新连接所有父子关	系。</p>
<ul>
<li><strong>AVL 树什么情况下要左旋+右旋？</strong></li>
</ul>
<p>​	当左子树的右子树过高导致左-右型不平衡时，先对左子节点左旋，再对根节点右旋。</p>
<ul>
<li><strong>AVL 树的插入和读取的时间复杂度？</strong></li>
</ul>
<p>​	插入和查找都是O(log n)，因为AVL树通过自平衡保证树高度始终为O(log n)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cmdnybnxv000g0kqq5eff51fu" data-title="平衡二叉树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二分搜索树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T08:42:25.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">二分搜索树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="二叉搜索树的数据结构"><a href="#二叉搜索树的数据结构" class="headerlink" title="二叉搜索树的数据结构"></a>二叉搜索树的数据结构</h4><p>二叉搜索树（Binary Search Tree），也称二叉查找树。如果你看见有序二叉树（Ordered Binary tree）、排序二叉树（Sorted Binary Tree）那么说的都是一个东西。</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>二叉搜索树也是一颗没有经过调衡的基础性数据结构，在一定概率上它完成有可能退化成链表，也就是从近似O(logn)的时间复杂度退化到O(n)。关于二叉搜索树的平衡解决方案，包括；AVL树、2-3树、红黑树等。</p>
<hr>
<h4 id="二叉搜索树结构实现"><a href="#二叉搜索树结构实现" class="headerlink" title="二叉搜索树结构实现"></a>二叉搜索树结构实现</h4><p>二叉搜索树是整个树结构中最基本的树，同时也是树这个体系中实现起来最容易的数据结构。但之所以要使用基于二叉搜索树之上的其他树结构，主要是因为使用数据结构就是对数据的存放和读取。那么为了提高吞吐效率，则需要尽可能的平衡元素的排序，体现在树上则需要进行一些列操作，所以会有不同的结构树实现。</p>
<ul>
<li><em><strong>树枝定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer value;</span><br><span class="line"><span class="keyword">public</span> Node parent;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于组成一颗树的节点，则需要包括；值和与之关联的三角结构，一个父节点、两个孩子节点。如果是AVL树还需要树高，红黑树还需要染色标记。</li>
</ul>
<ul>
<li><em><strong>插入节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引出待插入元素位置，也就是插入到哪个父元素下</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">search</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (search != <span class="literal">null</span> &amp;&amp; search.value != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = search;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; search.value) &#123;</span><br><span class="line">            search = search.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            search = search.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (parent.value &gt; newNode.value) &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断插入元素时候是否有树根，没有则会把当前节点创建出一颗树根来。</li>
<li>如果当前树是有树根的，则对插入元素与当前树进行一个节点遍历操作，找到元素可以插入的索引位置 parent（挂到这个父节点下）。也就是 search 搜索过程。</li>
<li>最后就是插入元素，通过给插入值创建一个 Node 节点，并绑定它的父元素，以及把新元素挂到索引到的 parent 节点下。</li>
</ul>
<ul>
<li><em><strong>索引节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.value != <span class="literal">null</span> &amp;&amp; node.value != e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; node.value) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值查找的过程，就是对二叉搜索树的遍历，不断的循环节点，按照节点值的左右匹配，找出最终相当的值节点。</li>
</ul>
<ul>
<li><em><strong>删除节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">delNode</span> <span class="operator">=</span> search(e);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == delNode) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> delete(delNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node delNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (delNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为删除的节点，有2个孩子节点，这个时候找到这条分支下，最左侧做小的节点。用它来替换删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">miniNode</span> <span class="operator">=</span> getMiniNode(delNode.right);</span><br><span class="line">        <span class="keyword">if</span> (miniNode.parent != delNode) &#123;</span><br><span class="line">            <span class="comment">// 交换位置，用miniNode右节点，替换miniNode</span></span><br><span class="line">            transplant(miniNode, miniNode.right);</span><br><span class="line">            <span class="comment">// 把miniNode 提升父节点，设置右子树并进行挂链。替代待删节点</span></span><br><span class="line">            miniNode.right = delNode.right;</span><br><span class="line">            miniNode.right.parent = miniNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置，删除节点和miniNode 可打印测试观察；System.out.println(this);</span></span><br><span class="line">        transplant(delNode, miniNode);</span><br><span class="line">        <span class="comment">// 把miniNode 提升到父节点，设置左子树并挂链</span></span><br><span class="line">        miniNode.left = delNode.left;</span><br><span class="line">        miniNode.left.parent = miniNode;</span><br><span class="line">        result = miniNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">transplant</span><span class="params">(Node delNode, Node addNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除元素是左/右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delNode.parent.left == delNode) &#123;</span><br><span class="line">        delNode.parent.left = addNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delNode.parent.right = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addNode) &#123;</span><br><span class="line">        addNode.parent = delNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有右子树</strong></p>
<ul>
<li>直接用右子树替换删除节点</li>
</ul>
<p><strong>只有左子树</strong></p>
<ul>
<li>直接用左子树替换删除节点</li>
</ul>
<p><strong>有两个子树</strong></p>
<ul>
<li>找到右子树中的最小节点（后继节点）</li>
<li>用后继节点替换删除节点</li>
<li>处理后继节点的原位置</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li>
</ul>
<p>​	基本性质：左子树 &lt; 根节点 &lt; 右子树，中序遍历有序，平均O(log n)操作复杂度。</p>
<p>​	核心操作：查找（比较递归）、插入（找位置插入）、删除（三种情况：0&#x2F;1&#x2F;2个子节点）。</p>
<p>​	主要变体：AVL树（自平衡）、红黑树（着色平衡）、B树（多路）、线索二叉树（利用空指针）。核心目标都是避免退化成链表，保持O(log n)性能。</p>
<ul>
<li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li>
</ul>
<p>​	平均情况：插入、删除、查找都是 O(log n)。最坏情况：当树退化成链表时（如顺序插入），所有操作变成 O(n)。关键：平衡二叉树通过自平衡保证最坏情况也是 O(log n)。</p>
<ul>
<li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li>
</ul>
<p>​	核心思路 ：找到右子树中的最小节点（后继节点）来替换被删除节点。</p>
<p>​	具体步骤：1）找到右子树最左侧的最小节点；2）如果最小节点不是右子树根，先将其右子树移植到原位置；3）用最小节点替换被删除节点，重新连接左右子树和父节点关系。</p>
<p>​	原理：右子树最小节点值刚好大于左子树所有值且小于右子树其余值，替换后仍保持BST性质。</p>
<ul>
<li><strong>二叉搜索树的节点都包括了哪些信息</strong></li>
</ul>
<p>​	基本信息：节点值（key&#x2F;data）、左子节点指针、右子节点指针。可选信息：父节点指针（便于向上遍历和删除操作）。扩展信息：节点颜色（红黑树）、平衡因子（AVL树）、子树大小等附加属性。</p>
<p>​	核心结构：<code>&#123;value, left, right, parent&#125;</code>，其中parent可选但常用。</p>
<ul>
<li><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></li>
</ul>
<p>​	核心问题：普通二叉搜索树在最坏情况下会退化成链表，时间复杂度从O(log n)恶化到O(n)。<strong>红黑树优势</strong>：通过着色和旋转机制保证树的近似平衡，确保最坏情况下仍是O(log n)。<strong>HashMap场景</strong>：哈希冲突时链表过长影响性能，红黑树能稳定保证查找效率，避免恶意构造数据导致性能攻击。</p>
<p>​	简单说：红黑树是自平衡的BST，防止极端情况下性能退化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" data-id="cmdnybnxr00050kqq8oi96r5i" data-title="二分搜索树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字典树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T03:05:39.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/">字典树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="字典树数据结构"><a href="#字典树数据结构" class="headerlink" title="字典树数据结构"></a>字典树数据结构</h4><p>在计算机科学中，字典树(Trie)也被称为”单词查找树“或”数字树“，有时候也被称为基数树或前缀树（因为可以通过前缀的方式进行索引）。—— 它是一种搜索树，一种已排序的数据结构，通常用于存储动态集或键为字符串的关联数组。</p>
<p>与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<hr>
<h4 id="字典树结构实现"><a href="#字典树结构实现" class="headerlink" title="字典树结构实现"></a>字典树结构实现</h4><p>字典树字母的存放有26个，也就是说在实现的过程中，每一个节点的分支都有26个槽位用来存放可能出现的字母组合。同理如果是数字树的话就是10个数字的组合，每个字典树上的节点对应的分支则有10个操作存放可能出现组合的数字。</p>
<ul>
<li><em><strong>树枝节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 形成一个链 */</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] slot = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字母 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：数量 &gt; 0 表示一个单词 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前缀 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：具体的一个单词字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String word;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解释：单词的注释说明 */</span></span><br><span class="line">    <span class="keyword">public</span> String explain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字典的树的节点需要包括此节点内嵌的关联节点，之后是节点的字母、到此字母是否为单词、单词的前缀、单词字符串和当前单词的非必要注释。</li>
</ul>
<ul>
<li><em><strong>插入元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String words, String explain)</span> &#123; <span class="comment">// 插入单词及其解释到字典树</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = words.toCharArray(); <span class="comment">// 将单词转为字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算字符在 slot 数组中的下标（假设都是小写字母）</span></span><br><span class="line">        <span class="keyword">if</span> (root.slot[idx] == <span class="literal">null</span>) &#123; <span class="comment">// 如果对应子节点不存在</span></span><br><span class="line">            root.slot[idx] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>(); <span class="comment">// 创建新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        root.c = c; <span class="comment">// 记录当前字符</span></span><br><span class="line">        root.prefix++; <span class="comment">// 前缀计数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    root.explain = explain; <span class="comment">// 存储单词的解释说明</span></span><br><span class="line">    root.isWord = <span class="literal">true</span>;     <span class="comment">// 标记该节点为单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png" alt="插入元素"></p>
<ul>
<li>insert 方法接收单词和注释信息，并对一个单词按照 char 进行拆分，拆分后则计算出索引位置并以此存放。存放完成后标记单词和附属上单词的注释信息。</li>
</ul>
<ul>
<li><em><strong>索引元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123; <span class="comment">// 查找所有以 prefix 为前缀的单词</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = prefix.toCharArray(); <span class="comment">// 将前缀转为字符数组</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 用于缓存已匹配的前缀</span></span><br><span class="line">    <span class="comment">// 精准匹配：根据前缀逐步查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历前缀的每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算下标</span></span><br><span class="line">        <span class="comment">// 匹配为空，前缀不存在</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; root.slot.length || idx &lt; <span class="number">0</span> || root.slot[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// 没有匹配，返回空列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        cache.append(c); <span class="comment">// 缓存当前字符</span></span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模糊匹配：递归查找所有以 prefix 开头的单词</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">if</span> (root.prefix != <span class="number">0</span>) &#123; <span class="comment">// 如果有以该前缀开头的单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.slot.length; i++) &#123; <span class="comment">// 遍历所有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 计算字符</span></span><br><span class="line">                collect(root.slot[i], String.valueOf(cache) + c, list, <span class="number">15</span>); <span class="comment">// 递归收集单词，最多15个</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt;= <span class="number">15</span>) &#123; <span class="comment">// 达到上限提前返回</span></span><br><span class="line">                    <span class="keyword">return</span> list;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(TrieNode trieNode, String pre, List&lt;String&gt; queue, <span class="type">int</span> resultLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到单词</span></span><br><span class="line">    <span class="keyword">if</span> (trieNode.isWord) &#123; <span class="comment">// 当前节点是单词结尾</span></span><br><span class="line">        trieNode.word = pre; <span class="comment">// 记录完整单词</span></span><br><span class="line">        <span class="comment">// 保存检索到的单词和解释到 queue</span></span><br><span class="line">        queue.add(trieNode.word + <span class="string">&quot; -&gt; &quot;</span> + trieNode.explain);</span><br><span class="line">        <span class="keyword">if</span> (queue.size() &gt;= resultLimit) &#123; <span class="comment">// 达到结果上限</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用，查找所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trieNode.slot.length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i); <span class="comment">// 计算字符</span></span><br><span class="line">        <span class="keyword">if</span> (trieNode.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">            collect(trieNode.slot[i], pre + c, queue, resultLimit); <span class="comment">// 递归收集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E7%B4%A2%E5%BC%95.png" alt="索引"></p>
<ul>
<li>从字典树从检索元素的过程分为2部分，第1部分是根据提供的索引前缀精准匹配到单词信息，第2部分是根据索引前缀的最后一个单词开始，循环递归遍历从当前位置所能关联到的字母直至判断为是单词标记为结束，通过这样的方式把所有匹配动的单词索引出来。</li>
<li>list.size() &gt;&#x3D; 15 是判定索引的最大长度，超过这个数量就停止索引了，毕竟这是一种O(n)时间复杂度的操作，如果加载数十万单词进行匹配，执行速度还是比较耗时的。</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>简述字典树的数据结构</strong></li>
</ul>
<p>​	本质： 树形结构存储字符串，共享公共前缀</p>
<p>​	结构：</p>
<ul>
<li>节点存储字符</li>
<li>路径 &#x3D; 字符串</li>
<li>标记单词结尾</li>
</ul>
<p>​	复杂度： O(字符串长度)</p>
<p>​	用途： 自动补全、前缀匹配、拼写检查</p>
<p>​	优势： 前缀查询快，节省空间</p>
<ul>
<li><strong>叙述你怎么来实现一个字典树</strong></li>
</ul>
<p>​	子节点数组（26个字母）</p>
<p>​	布尔标记（是否单词结尾）</p>
<p>​	插入： 逐字符遍历，不存在就创建节点，最后标记结尾</p>
<p>​	查找：*逐字符遍历，检查路径是否存在且标记为单词</p>
<p>​	前缀查询： 遍历到前缀末尾即可</p>
<p>​	关键点： 字符映射到数组索引，路径即字符串</p>
<ul>
<li><strong>字典树的实际业务场景举例【排序、全文搜索、网络搜索引擎、生物信息】</strong></li>
</ul>
<p>​	字符串字典序排序\关键词索引构建\查询补全\DNA序列匹配</p>
<p>​	<strong>核心优势：</strong> 前缀匹配效率高，特别适合大规模字符串集合的快速检索场景。</p>
<ul>
<li><strong>字典树的存入和检索的时间复杂度</strong></li>
</ul>
<p>​	存入（Insert）：O(m)</p>
<p>​	检索（Search）：O(m)</p>
<p>​	前缀查找：O(p)</p>
<p>​	其中 m 是字符串长度，p 是前缀长度(字典树是典型的<strong>空间换时间</strong>的数据结构，特别适合字符串查找和前缀匹配场景。)</p>
<ul>
<li><strong>还有哪些字典树的实现方式</strong></li>
</ul>
<ol>
<li><p>数组实现</p>
<p>固定大小数组存储子节点</p>
<ul>
<li>优点：O(1)访问速度</li>
<li>缺点：空间浪费</li>
</ul>
</li>
<li><p>哈希表实现</p>
<p>HashMap存储子节点</p>
<ul>
<li>优点：空间高效，支持任意字符集</li>
<li>缺点：哈希冲突影响性能</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" data-id="cmdnybnxv000j0kqq5ptrel84" data-title="字典树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%A0%86/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T01:44:53.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%A0%86/">堆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h4><p>在计算机科学中，<strong>堆(heap)</strong> 的实现是一种基于树的特殊的数据结构，它可以在数组上构建出树的结构体，并满足堆的属性；</p>
<ul>
<li><p>最小堆：如果<code>P</code> 是 <code>C</code> 的一个父级节点， 那么 <code>P</code> 的key(或value)应小于或等于 <code>C</code> 的对应值。</p>
</li>
<li><p>最大堆：与最小堆的定义正好相反，最大堆(max heap) , <code>P</code> 的key(或value)大于 <code>C</code> 的对应值。</p>
</li>
</ul>
<hr>
<h4 id="堆的代码实现"><a href="#堆的代码实现" class="headerlink" title="堆的代码实现"></a>堆的代码实现</h4><ul>
<li><em><strong>实现介绍</strong></em></li>
</ul>
<p>堆的实现在 Java API 中主要体现在延迟队列的实现二叉堆上，这里小傅哥单独把这部分代码拆分出来，了解下关于小堆和大堆的实现。</p>
<p>从对堆的数据结构介绍上可以看到，小堆和大堆的唯一区别仅是对元素的排序方式不同。所以也就是说在存放和获取元素的时候对元素的填充和摘除时，排序方式不同而已。</p>
<ul>
<li><em><strong>入堆实现</strong></em></li>
</ul>
<p>堆的在存放元素时，以遵循它的特点，会在存放过程中，通过队尾元素向上比对迁移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】元素：&#123;&#125; 当前队列：&#123;&#125;&quot;</span>, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点Idx，相当于除以2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        logger.info(<span class="string">&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;</span>, k, parent);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="comment">// 如果当前位置元素，大于父节点元素，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;</span>, JSON.toJSONString(e), JSON.toJSONString(x));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相反父节点位置大于当前位置元素，则进行替换</span></span><br><span class="line">        logger.info(<span class="string">&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;</span>, JSON.toJSONString(e), k);</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \r\n当前队列：&#123;&#125; \r\n&quot;</span>, k, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>入堆的实现 add 方法最终会调用到 siftUpComparable 方法，进行排序的方式进行处理。而这个排序 compareTo 方法是由具体的 MinHeap、MaxHeap 来做实现。</li>
<li>以入堆元素2举例，如图所示入堆过程。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%85%A5%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="入堆实现"></p>
<ul>
<li>首先将元素2挂到队列尾部，之后通过 (k - 1) &gt;&gt;&gt; 1 计算父节点位置，与对应元素进行比对和判断交换。</li>
<li>交换过程包括 2-&gt;6、2-&gt;5，以此交换结束后元素保存完毕。</li>
</ul>
<ul>
<li><em><strong>出堆实现</strong></em></li>
</ul>
<p>元素的出堆其实很简单，只要把根元素直接删除弹出即可。但剩余接下里的步骤才是复杂的，因为需要在根元素迁移走后，寻找另外的最小元素迁移到对头。这个过程与入堆正好相反，这是一个不断向下迁移的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="comment">// 先找出中间件节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 找到左子节点和右子节点，两个节点进行比较，找出最大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子节点与右子节点比较，取最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; compareTo((E) c, (E) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;</span>, JSON.toJSONString(c), JSON.toJSONString(queue[right]));</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) c) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值小于c值，位置替换，继续比较</span></span><br><span class="line">        logger.info(<span class="string">&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;</span>, JSON.toJSONString(queue[k]), JSON.toJSONString(c));</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把目标值放到对应位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;</span>, k, JSON.toJSONString(x));</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不断地向下迁移元素。这个过程会比对左右子节点的值，找到最小的。所以整个过程会比入堆麻烦一些。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%87%BA%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="出堆实现"></p>
<p>这里以弹出元素1举例，之后将堆尾元素替换到相应的位置。整个过程分为6张图表述。</p>
<ol>
<li>图1到图2，找出根元素弹出。</li>
<li>图3到图4，将根元素向下迁移，与子元素比对，并替换位置。如果这个位置与8相比，小于8则继续向下迁移。</li>
<li>图4到图5，继续迁移，在原节点4的位置对应的两个子元素，都比8大，这个时候就可以停下来了。</li>
<li>图5到图6，更换元素位置，把队尾的元素替换到对应元素1向下迁移检测的位置。</li>
</ol>
<ul>
<li><em><strong>最小堆（MinHeap）和最大堆（MaxHeap）</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstElement.compareTo(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> secondElement.compareTo(firstElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用：实现最小堆。</p>
<ul>
<li><p>原理：compareTo 返回 firstElement.compareTo(secondElement)，即：</p>
</li>
<li><p>如果 firstElement &lt; secondElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最小的元素。</p>
</li>
</ul>
</li>
<li><p>作用：实现最大堆。</p>
<ul>
<li><p>原理：compareTo 返回 secondElement.compareTo(firstElement)，即：</p>
</li>
<li><p>如果 secondElement &lt; firstElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最大的元素。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>堆的数据结构是什么样？</strong></li>
</ul>
<p>​	堆是一种完全二叉树结构，通常用数组实现。</p>
<ul>
<li><p>最大堆：每个节点的值都大于等于其子节点（堆顶是最大值）。</p>
</li>
<li><p>最小堆：每个节点的值都小于等于其子节点（堆顶是最小值）。</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li><p>父子节点通过数组下标可以快速定位（如父节点下标为 i，左子为 2i+1，右子为 2i+2）。</p>
</li>
<li><p>结构紧凑，没有“空洞”。</p>
</li>
<li><p><strong>堆的数据结构使用场景？</strong></p>
</li>
</ul>
<p>​	堆常用于优先队列（如任务调度）、排序算法（堆排序）、动态获取最大&#x2F;最小值（如实时统计Top K）、图算法（如Dijkstra最短路径）等需要频繁取最大&#x2F;最小元素的场景。</p>
<ul>
<li><strong>堆的数据结构实现方式有哪些？</strong></li>
</ul>
<ol>
<li>数组实现（最常用）</li>
</ol>
<p>​		利用完全二叉树的性质，父子节点通过下标计算关联，结构紧凑，效率高。</p>
<ol start="2">
<li>链式二叉树实现</li>
</ol>
<p>​		用指针（引用）连接父子节点，结构灵活，但空间利用率和访问效率不如数组。</p>
<ol start="3">
<li>多路堆（如d叉堆）</li>
</ol>
<p>​		可以用数组或链表实现，每个节点有 d 个子节点，适合特殊场景（如堆优化的优先队列）。</p>
<ul>
<li><strong>最小堆和最大堆的区别是什么？</strong></li>
</ul>
<p>​	最小堆和最大堆的区别在于堆顶元素的大小关系：</p>
<ul>
<li><p>最小堆：每个节点的值都小于等于其子节点，堆顶是最小值。</p>
</li>
<li><p>最大堆：每个节点的值都大于等于其子节点，堆顶是最大值。</p>
</li>
</ul>
<p>用途不同：</p>
<ul>
<li><p>最小堆适合快速获取最小元素。</p>
</li>
<li><p>最大堆适合快速获取最大元素。</p>
</li>
<li><p><strong>有了解斐波那契堆吗？</strong></p>
</li>
</ul>
<p>​	斐波那契堆（Fibonacci Heap）是一种<strong>高级堆数据</strong>结构，支持更快的合并（合并两个堆）、插入和减少键值等操作，适用于<strong>需要大量合并和减少最小值操作</strong>的场景（如Dijkstra最短路径算法）。它的结构比普通二叉堆复杂，操作的<strong>摊还时间复杂度更低</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%A0%86/" data-id="cmdnybnxt000a0kqqfbdnd0lv" data-title="堆" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-哈希表-散列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T07:48:47.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/">哈希表(散列)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="哈希数据结构"><a href="#哈希数据结构" class="headerlink" title="哈希数据结构"></a>哈希数据结构</h4><p>哈希表的存在是为了解决能通过O(1)时间复杂度直接索引到指定元素。</p>
<p>HashMap 中的拉链寻址 + 红黑树、扰动函数、负载因子、合并散列、杜鹃散列、跳房子哈希、罗宾汉哈希等各类数据结构设计。让元素在发生哈希冲突时，也可以存放到新的槽位，并尽可能保证索引的时间复杂度小于O(n)</p>
<hr>
<h4 id="实现哈希散列"><a href="#实现哈希散列" class="headerlink" title="实现哈希散列"></a>实现哈希散列</h4><p>哈希散列是一个非常常见的数据结构，无论是我们使用的 HashMap、ThreaLocal 还是你在刷题中位了提升索引效率，都会用到哈希散列。</p>
<p>只要哈希桶的长度由负载因子控制的合理，每次查找元素的平均时间复杂度与桶中存储的元素数量无关。另外许多哈希表设计还允许对键值对的任意插入和删除，每次操作的摊销固定平均成本。</p>
<ul>
<li><em><strong>哈希碰撞</strong></em></li>
</ul>
<p><strong>说明</strong>：通过模拟简单 HashMap 实现，去掉拉链寻址等设计，验证元素哈希索引位置碰撞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap01</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] tab = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        tab[idx] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (V) tab[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap01 的实现只是通过哈希计算出的下标，散列存放到固定的数组内。那么这样当发生元素下标碰撞时，原有的元素就会被新的元素替换掉。</li>
</ul>
<ul>
<li><em><strong>拉链寻址</strong></em></li>
</ul>
<p><strong>说明</strong>：既然我们没法控制元素不碰撞，但我们可以对碰撞后的元素进行管理。比如像 HashMap 中拉链法一样，把碰撞的元素存放到链表上。这里我们就来简化实现一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap02BySeparateChaining</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Node&lt;K, V&gt;&gt;[] tab = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果该位置还没有链表，就新建一个链表并添加节点。</span></span><br><span class="line"><span class="comment">			如果已经有链表，直接把新节点加到链表末尾。</span></span><br><span class="line"><span class="comment">			注意：这里没有去重（同一个 key 会重复插入）。*/</span></span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*计算 key 的哈希值，找到对应链表。</span></span><br><span class="line"><span class="comment">		遍历链表，找到 key 相等的节点，返回其 value。</span></span><br><span class="line"><span class="comment">		如果没找到，返回 null。*/</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt; kvNode : tab[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(kvNode.getKey())) &#123;</span><br><span class="line">                <span class="keyword">return</span> kvNode.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为元素在存放到哈希桶上时，可能发生下标索引膨胀，所以这里我们把每一个元素都设定成一个 Node 节点，这些节点通过 LinkedList 链表关联，当然你也可以通过 Node 节点构建出链表 next 元素即可。</li>
<li>那么这时候在发生元素碰撞，相同位置的元素就都被存放到链表上了，获取的时候需要对存放多个元素的链表进行遍历获取。</li>
</ul>
<ul>
<li><em><strong>开放寻址</strong></em></li>
</ul>
<p><strong>说明</strong>：除了对哈希桶上碰撞的索引元素进行拉链存放，还有不引入新的额外的数据结构，只是在哈希桶上存放碰撞元素的方式。它叫开放寻址，也就是 ThreaLocal 中运用斐波那契散列+开放寻址的处理方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap03ByOpenAddressing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果该位置已被占用（哈希冲突），则向后线性探查，找到下一个空位插入。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tab[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i ++)&#123;</span><br><span class="line">            <span class="comment">//从 idx 开始向后线性查找，遇到 key 相等的节点就返回 value。</span></span><br><span class="line">            <span class="keyword">if</span> (tab[idx] != <span class="literal">null</span> &amp;&amp; tab[idx].key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>开放寻址的设计会对碰撞的元素，寻找哈希桶上新的位置，这个位置从当前碰撞位置开始向后寻找，直到找到空的位置存放。</li>
<li>在 ThreadLocal 的实现中会使用斐波那契散列、索引计算累加、启发式清理、探测式清理等操作，以保证尽可能少的碰撞。</li>
</ul>
<ul>
<li><em><strong>合并散列</strong></em></li>
</ul>
<p><strong>说明</strong>：合并散列是开放寻址和单独链接的混合，碰撞的节点在哈希表中链接。此算法适合固定分配内存的哈希桶，通过存放元素时识别哈希桶上的最大空槽位来解决合并哈希中的冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap04ByCoalescedHashing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//从数组末尾向前找一个空位（cursor），插入新节点。</span></span><br><span class="line">		<span class="comment">//然后在原冲突链的末尾，将idxOfNext指向新节点的下标（cursor），形成“链”。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> tab.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tab[cursor] != <span class="literal">null</span> &amp;&amp; tab[cursor].key != key) &#123;</span><br><span class="line">            --cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        tab[cursor] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将碰撞节点指向这个新节点</span></span><br><span class="line">        <span class="keyword">while</span> (tab[idx].idxOfNext != <span class="number">0</span>)&#123;</span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[idx].idxOfNext = cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (tab[idx].key != key) &#123;</span><br><span class="line">            <span class="comment">//如果不是目标 key，就顺着idxOfNext跳到下一个节点，直到找到 key 相等的节点。</span></span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="type">int</span> idxOfNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>合并散列的最大目的在于将碰撞元素链接起来，避免因为需要寻找碰撞元素所发生的循环遍历。也就是A、B元素存放时发生碰撞，那么在找到A元素的时候可以很快的索引到B元素所在的位置。</p>
</li>
<li><p>相对于直接使用开放寻址，这样的挂在链路指向的方式，可以提升索引的性能。因为在实际的数据存储上，元素的下一个位置不一定空元素，可能已经被其他元素占据，这样就增加了索引的次数。所以使用直接指向地址的方式，会更好的提高索引性能。</p>
</li>
</ul>
<ul>
<li><em><strong>杜鹃散列</strong></em></li>
</ul>
<p><strong>说明</strong>：这个名字起的比较有意思，也代表着它的数据结构。杜鹃鸟在孵化🐣的时候，雏鸟会将其他蛋或幼崽推出巢穴；类似的这个数据结构会使用2组key哈希表，将冲突元素推到另外一个key哈希表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> isRehash)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">k</span> <span class="operator">=</span> maskNull(key);</span><br><span class="line">    <span class="keyword">if</span> (containsKey(k)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (insertEntry(<span class="keyword">new</span> <span class="title class_">Entry</span>&lt;K, V&gt;((K) k, value))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRehash) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rehash(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="keyword">return</span> put((K) k, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">insertEntry</span><span class="params">(Entry&lt;K, V&gt; e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Entry&lt;K, V&gt; current = e;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(hash1, current.key);</span><br><span class="line">    <span class="keyword">while</span> (current != e || count &lt; table.length) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; temp = table[index];</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">            table[index] = current;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = current;</span><br><span class="line">        current = temp;</span><br><span class="line">        <span class="keyword">if</span> (index == hash(hash1, current.key)) &#123;</span><br><span class="line">            index = hash(hash2, current.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = hash(hash1, current.key);</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当多个键映射到同一个单元格时会发生这种情况。杜鹃散列的基本思想是通过使用两个散列函数而不是仅一个散列函数来解决冲突。</li>
<li>这为每个键在哈希表中提供了两个可能的位置。在该算法的一种常用变体中，哈希表被分成两个大小相等的较小的表，每个哈希函数都为这两个表之一提供索引。两个散列函数也可以为单个表提供索引。</li>
<li>在实践中，杜鹃哈希比线性探测慢约 20-30%，线性探测是常用方法中最快的。然而，由于它对搜索时间的最坏情况保证，当需要实时响应率时，杜鹃散列仍然很有价值。杜鹃散列的一个优点是它的无链接列表属性，非常适合 GPU 处理。</li>
</ul>
<ul>
<li><em><strong>跳房子散列</strong></em></li>
</ul>
<p><strong>说明</strong>：跳房子散列是一种基于开放寻址的算法，它结合了杜鹃散列、线性探测和链接的元素，通过桶邻域的概念——任何给定占用桶周围的后续桶，也称为“虚拟”桶。 该算法旨在在哈希表的负载因子增长超过 90% 时提供更好的性能；它还在并发设置中提供了高吞吐量，因此非常适合实现可调整大小的并发哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(AnyType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentPos</span> <span class="operator">=</span> findPos(x);</span><br><span class="line">    <span class="keyword">if</span> (currentPos == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (array[currentPos] != <span class="literal">null</span>) &#123;</span><br><span class="line">        x = array[currentPos].element;</span><br><span class="line">        array[currentPos].isActive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String hope;</span><br><span class="line">    <span class="keyword">if</span> (array[currentPos] != <span class="literal">null</span>) &#123;</span><br><span class="line">        hope = array[currentPos].hope;</span><br><span class="line">        x = array[currentPos].element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hope = <span class="string">&quot;10000000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[currentPos] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;&gt;(x, hope, <span class="literal">true</span>);</span><br><span class="line">    theSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该算法使用一个包含n 个桶的数组。对于每个桶，它的邻域是H个连续桶的小集合（即索引接近原始散列桶的那些）。邻域的期望属性是在邻域的桶中找到一个项目的成本接近于在桶本身中找到它的成本（例如，通过使邻域中的桶落在同一缓存行中）。在最坏的情况下，邻域的大小必须足以容纳对数个项目（即它必须容纳 log( n ) 个项目），但平均只能是一个常数。如果某个桶的邻域被填满，则调整表的大小。</li>
</ul>
<ul>
<li><em><strong>罗宾汉哈希</strong></em></li>
</ul>
<p><strong>说明</strong>：罗宾汉哈希是一种基于开放寻址的冲突解决算法；冲突是通过偏向从其“原始位置”（即项目被散列到的存储桶）最远或最长探测序列长度（PSL）的元素的位移来解决的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 元素碰撞检测</span></span><br><span class="line">    <span class="keyword">while</span> (table[idx] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset &gt; table[idx].offset) &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量不止一个，则查看条目交换位置，entry 是正在查看的条目，增加现在搜索的事物的偏移量和 idx</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">garbage</span> <span class="operator">=</span> table[idx];</span><br><span class="line">            table[idx] = entry;</span><br><span class="line">            entry = garbage;</span><br><span class="line">            idx = increment(idx);</span><br><span class="line">            entry.offset++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset == table[idx].offset) &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量与正在查看的检查键是否相同，如果是则它们交换值，如果不是，则增加 idx 和偏移量并继续</span></span><br><span class="line">            <span class="keyword">if</span> (table[idx].key.equals(key)) &#123;</span><br><span class="line">                <span class="comment">// 发现相同值</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> table[idx].value;</span><br><span class="line">                table[idx].value = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idx = increment(idx);</span><br><span class="line">                entry.offset++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量小于我们正在查看的我们增加 idx 和偏移量并继续</span></span><br><span class="line">            idx = increment(idx);</span><br><span class="line">            entry.offset++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经到达了 null 所在的 idx，将新/移动的放在这里</span></span><br><span class="line">    table[idx] = entry;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 超过负载因子扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= loadFactor * table.length) &#123;</span><br><span class="line">        rehash(table.length * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>09、12 和 01 发生哈希索引碰撞，进行偏移量计算调整。通过最长位置探测碰撞元素位移来处理。</p>
</li>
<li><p>通过测试结果和调试的时候可以看到，哈希索引冲突是通过偏向从其“原始位置”（即项目被散列到的存储桶）最远或最长<em>探测序列长度（PSL）的元素的位移来解决</em>。这块可以添加断点调试验证。</p>
</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>介绍一下散列表</strong></li>
</ul>
<p>​	散列表（Hash Table）是一种基于键值对存储的数据结构。它通过哈希函数将键（key）映射到数组的某个位置（桶或槽），以实现高 效的插入、查找和删除操作，平均时间复杂度为 O(1)。</p>
<ul>
<li><strong>为什么使用散列表</strong></li>
</ul>
<p>​	使用散列表的主要原因是查找、插入和删除操作非常高效，平均时间复杂度为 O(1)，远快于数组、链表等结构。</p>
<ul>
<li><strong>拉链寻址和开放寻址的区别</strong></li>
</ul>
<p>​	拉链法用链表解决冲突，元素可分散在链表中；开放寻址所有元素都在数组内，通过探查空位解决冲突。</p>
<ul>
<li><strong>还有其他什么方式可以解决散列哈希索引冲突</strong></li>
</ul>
<p>​	再哈希法:冲突时，使用另一个哈希函数计算新的位置，减少聚集。</p>
<p>​	合链哈希:结合拉链法和开放寻址，将链表节点也放在哈希表数组中。</p>
<p>​	罗宾汉哈希\跳房子散列\杜鹃散列</p>
<ul>
<li><strong>对应的Java源码中，对于哈希索引冲突提供了什么样的解决方案</strong></li>
</ul>
<p>​	Java标准库的哈希表（如 HashMap、Hashtable、ConcurrentHashMap）主要采用拉链法（链表或红黑树）来解决哈希冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/" data-id="cmdnybnxs00060kqqazycgkek" data-title="哈希表(散列)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-堆栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/%E5%A0%86%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T06:57:00.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/24/%E5%A0%86%E6%A0%88/">堆栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="堆栈数据结构"><a href="#堆栈数据结构" class="headerlink" title="堆栈数据结构"></a>堆栈数据结构</h4><p>在计算机科学中，堆栈是一种抽象数据类型，用作元素的集合，具有两个主要的操作；</p>
<ul>
<li>PUSH：将元素添加到集合</li>
<li>POP：删除最近添加但尚未删除的元素</li>
</ul>
<p>堆栈是一种 LIFO（后进先出）的线性的数据结构，或者更抽象说是一种顺序集合，push 和 pop 操作只发生在结构的一端，称为栈顶。这种结构可以很容易地从堆栈顶部取出一个项目，而要到达堆栈更深处的一个项目可能需要先取出多个其他项目。例如；我们经常看到的浏览器访问记录，总是把最近记录展示给你。还包括：一摞书、一叠盘子、一脑瓜子生活琐事。</p>
<h4 id="实现堆栈结构"><a href="#实现堆栈结构" class="headerlink" title="实现堆栈结构"></a>实现堆栈结构</h4><p>Deque 接口及其实现提供了一组更完整和一致的 LIFO 堆栈操作，应优先使用此类。所以我们本章也是以 ArrayDeque 为原型做代码实现。</p>
<ul>
<li>*** ArrayDeque 介绍***</li>
</ul>
<p>ArrayDeque 是一个基于数组实现的堆栈数据结构，在数据存放时元素通过二进制与运算获取对应的索引存放元素。当数组长度超过初始空间后，进行2的n次幂左移一位扩容，并将数组内容的元素按照分半分别进行迁移。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/ArrayDeque.png" alt="ArrayDeque"></p>
<ul>
<li>堆栈的数据结构是以2的次幂进行初始化，扩容时候为2的倍数。它之所这样是因为保证了在后续计算元素索引位置时，可以进行与运算。也就说 2的n次幂-1 得到的值是一个011111的范围，在与元素索引位置计算时候，找到两个值之间1的位置即可。</li>
<li>数据的压栈，压栈是一个在数组中倒放的方式，通过与运算得到索引值。当发生空间不足时扩容迁移数据，会有2次操作。一次是空间的前半段复制，另外一次是后半段复制。</li>
<li>最后在数据弹出时，按照空间的元素数量总数开始，同样通过与运算计算索引值。分为弹出队列中未发生迁移的数据，和已经完全迁移好的数据。<em>凡是迁移的数据，都是保证了一个顺序。</em></li>
</ul>
<ul>
<li><em><strong>添加元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//计算新元素插入的位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;push.idx head：&#123;&#125;&quot;</span>, head);</span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//如果head和tail重合，说明数组已满，需要扩容。</span></span><br><span class="line">        doubleCapacity();<span class="comment">//调用doubleCapacity()方法将数组容量翻倍。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="添加元素"></p>
<ul>
<li>push 元素的过程相当于找到初始化数组长度的队尾，另外是扩容后从新的队尾开始依次添加元素。此时不用担心元素的输出，因为输出时是从扩容起始点开始输出元素。</li>
</ul>
<ul>
<li><em><strong>扩容空间</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * src      - 源数组</span></span><br><span class="line"><span class="comment">     * srcPos   – 源数组中的起始位置</span></span><br><span class="line"><span class="comment">     * dest     - 目标数组</span></span><br><span class="line"><span class="comment">     * destPos  – 目标数据中的起始位置</span></span><br><span class="line"><span class="comment">     * length   – 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 第一次拷贝元素：[2、1、4、3] 将数组中的扩容后一半元素拷贝到新数组0开始往后的位置。拷贝4、3</span></span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    <span class="comment">// 第二次拷贝元素：[2、1、4、3] 将数组中的前面一半数量的元素，拷贝到新数组后一半开始的位置往后。拷贝2、1</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%89%A9%E5%AE%B9%E7%A9%BA%E9%97%B4.png" alt="扩容空间"></p>
<ul>
<li>空间扩容以2的倍数进行操作，以此保证2的幂等。</li>
<li>System.arraycopy 是操作数据迁移的本地方法，从源数组的某个指定位置，把元素迁移到新数组的指定位置和指定个数个元素。</li>
<li>另外是数据迁移，以 [2、1、4、3] 举例；<ul>
<li>第一次拷贝元素：[2、1、4、3] 将数组中的扩容后一半元素拷贝到新数组0开始往后的位置。拷贝4、3</li>
<li>第二次拷贝元素：[2、1、4、3] 将数组中的前面一半数量的元素，拷贝到新数组后一半开始的位置往后。拷贝2、1</li>
</ul>
</li>
</ul>
<ul>
<li><em><strong>弹出元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[h];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[h] = <span class="literal">null</span>;</span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;pop.idx &#123;&#125; = &#123;&#125; &amp; &#123;&#125;&quot;</span>, head, Integer.toBinaryString(h + <span class="number">1</span>), Integer.toBinaryString(elements.length - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%BC%B9%E5%87%BA%E5%85%83%E7%B4%A0.png" alt="弹出元素"></p>
<ul>
<li>按照索引的计算，以此是弹出索引为：6、7、0、1、2、3、4 对应的元素。head 的值从扩容的长度添加元素后逐步减小，所以当前最开始弹出的元素是6索引对应的值。</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>堆栈的使用场景？</strong></li>
</ul>
<p>​	括号匹配：判断括号是否成对出现。（需要使用先入后出的数据结构的场景）</p>
<ul>
<li><strong>为什么不是用 Stack 类？</strong></li>
</ul>
<p>​	Stack十分粗糙，效率低下。（Stack 过时且效率低，推荐用 ArrayDeque 或 LinkedList 实现栈结构。）</p>
<ul>
<li><strong>ArrayDeque 是基于什么实现的？</strong></li>
</ul>
<p>​	ArrayDeque 是用环形数组实现的双端队列，支持高效的头尾插入和删除操作。</p>
<ul>
<li><strong>ArrayDeque 数据结构使用过程叙述。</strong></li>
</ul>
<p>​	ArrayDeque是双端队列，使用的时候提供从两端插入或弹出，那它可以同时实现栈和队列的功能</p>
<ul>
<li><strong>ArrayDeque 为什么要初始化2的n次幂个长度？</strong></li>
</ul>
<p>​	为了便于进行无符号取模(2^n - 1)得到索引</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/24/%E5%A0%86%E6%A0%88/" data-id="cmdnybnxu000c0kqq8wk7dkd9" data-title="堆栈" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T02:58:30.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/24/%E9%98%9F%E5%88%97/">队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h4><p>在计算机科学中, 一个 <strong>队列(queue)</strong> 是一种特殊类型的抽象数据类型或集合。集合中的实体按顺序保存。</p>
<ul>
<li>从理论上讲，队列的一个特征是它没有特定的容量。不管已经包含多少元素，总是可以再添加一个新元素。</li>
<li>队列既可以是数组实现也可以是链表实现。所以当我们在 Java 中使用队列的时候，Deque 的实现类就是；LinkedList 和 ArrayDeque的实现类。</li>
<li>队列不只是单端从一个口入另外一个口出，也可以是双端队列。例如在 Java 中 Queue 是单端队列接口、Deque 是双端队列接口，都有对应的实现类。</li>
</ul>
<hr>
<h4 id="延迟队列介绍"><a href="#延迟队列介绍" class="headerlink" title="延迟队列介绍"></a>延迟队列介绍</h4><p>队列的数据结构更像是数组和链表的变种，只要能看懂数组和链表，就能看懂队列。那么这里我们来扩展实现一个<strong>延迟队列</strong>，并在这个过程中会涉及到<strong>阻塞队列</strong>、<strong>优先队列</strong>的使用。通过这样的一个手写源码的学习队列的扩展使用。</p>
<h5 id="1-延迟队列说明"><a href="#1-延迟队列说明" class="headerlink" title="1. 延迟队列说明"></a>1. 延迟队列说明</h5><p>DelayQueue 是一个 BlockingQueue（无界阻塞）队列，它封装了一个使用完全二叉堆排序元素的 PriorityQueue（优先队列）。在添加元素时使用 Delay（延迟时间）作为排序条件，延迟最小的元素会优先放到队首。</p>
<ul>
<li>延迟队列的第一个核心点在于对所加入的元素按照一定的规则进行排序存放，这样才能让在延迟弹出元素的时候，按照所存放元素的排序进行输出。</li>
<li>那么这个延迟队列中用到的排序方式就是 PriorityQueue 优先队列，它的数据结构是数组实现的队列，但体现形式是一棵二叉堆树结构。在元素存放时，通过对存放元素的比较和替换形成二叉堆结构。</li>
</ul>
<h5 id="2-二叉堆结构"><a href="#2-二叉堆结构" class="headerlink" title="2. 二叉堆结构"></a>2. 二叉堆结构</h5><p>二叉堆是一种特殊结构的堆，它的表现形态可以是一棵完整或近似二叉树的结构。如我们本章节要实现的延迟队列中的元素存放，使用的就是 PriorityQueue 实现的平衡二叉堆结构，数据以队列形式存放在基础数组中。</p>
<ul>
<li><strong>父子节点索引关系</strong>：<ul>
<li>假如父节点为queue[n]，那么左子节点为queue[2n+1]，右子节点为queue[2n+2]</li>
<li>任意孩子节点的父节点位置，都是 <code>(n-1)&gt;&gt;&gt;1</code> 相当于减1后除2取整</li>
</ul>
</li>
<li><strong>节点间大小关系</strong>：<ul>
<li>父节点小于等于任意孩子节点</li>
<li>同一层级的两个孩子节点大小不需要维护，它是在弹出元素的时候进行判断的</li>
</ul>
</li>
<li><strong>子叶节点与非子叶节点</strong>：<ul>
<li>一个长度为 size 的优先级队列，当 index &gt;&#x3D; size &gt;&gt;&gt; 1 时，该节点为叶子节点。否则，为非叶子节点。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="延迟队列实现"><a href="#延迟队列实现" class="headerlink" title="延迟队列实现"></a>延迟队列实现</h4><ul>
<li><em><strong>实现介绍</strong></em></li>
</ul>
<p>延迟队列的实现，主要为在优先队列的基础上，添加可重入锁 ReentrantLock 对阻塞队列的实现。当数据存放时，按照二叉堆结构排序元素，出队时依照排序结构进行迁移。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.png" alt="队列实现"></p>
<ol>
<li><p>延迟队列的使用，是以在 DelayQueue 中存放实现了 Delayed 延迟接口的对象。因为只有实现这个对象，才能比较出当前元素与所需存放到对应位置的一个比对计算过程。</p>
</li>
<li><p>另外这里的核心点包括：PriorityQueue —— 优先队列、ReentrantLock —— 可重入锁、Condition —— 信号量</p>
</li>
</ol>
<ul>
<li><em><strong>入队实现</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点Idx，相当于除以2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        logger.info(<span class="string">&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;</span>, k, parent);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="comment">// 如果当前位置元素大于父节点元素，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;</span>, JSON.toJSONString(e), JSON.toJSONString(key));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相反当前位置元素小于父节点位置，则进行替换</span></span><br><span class="line">        logger.info(<span class="string">&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;</span>, JSON.toJSONString(e), k);</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \r\n当前队列：&#123;&#125; \r\n&quot;</span>, k, JSON.toJSONString(key), JSON.toJSONString(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>DelayQueue 延迟队列，元素入队最终会调用到优先队列的 PriorityQueue#siftUpComparable 方法。</p>
</li>
<li><p>以入队元素2举例，如图所示入队过程。</p>
</li>
<li><p><code>(k - 1) &gt;&gt;&gt; 1</code> 为什么使用<code> &gt;&gt;&gt;</code>右移1位；</p>
</li>
<li><p>首先我们是需要通过右移替代除以2的运算，提升运算效率，找到父节点。<em>移位器比除法器简单得多，在大多数处理器上，移位指令的执行速度比除法指令快</em></p>
</li>
<li><p><code>&gt;&gt;</code> 是算术位移，<code>&gt;&gt;&gt;</code> 是逻辑右移</p>
</li>
<li><p>算术和逻辑左移和乘法的等价，但由于符号位的存在算术右移和除法不等价。</p>
</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%85%A5%E9%98%9F%E5%AE%9E%E7%8E%B0.png" alt="入队实现"></p>
<ol>
<li>首先将元素2挂到队列尾部，之后通过 (k - 1) &gt;&gt;&gt; 1 计算父节点位置，与对应元素进行比对和判断交换。</li>
<li>交换过程包括2-&gt;6、2-&gt;5，以此交换结束后元素保存完毕。</li>
</ol>
<ul>
<li><em><strong>出队实现</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">    <span class="comment">// 先找出中间件节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 找到左子节点和右子节点，两个节点进行比较，找出最大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子节点与右子节点比较，取最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; ((Comparable&lt;? <span class="built_in">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;</span>, JSON.toJSONString(c), JSON.toJSONString(queue[right]));</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值大于c值，位置替换，继续比较</span></span><br><span class="line">        logger.info(<span class="string">&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;</span>, JSON.toJSONString(queue[k]), JSON.toJSONString(c));</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把目标值放到对应位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;</span>, k, JSON.toJSONString(key));</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DelayQueue 延迟队列，元素出队会调用到 PriorityQueue#siftDownComparable 方法，不断地向下迁移元素。这个过程会比对左右子节点的值，找到最小的。所以整个过程会比入队麻烦一些。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%87%BA%E9%98%9F%E5%AE%9E%E7%8E%B0.png" alt="出队实现"></p>
<p>这里以弹出元素1举例，之后将队尾元素替换到相应的位置。整个过程分为6张图表述。</p>
<ol>
<li>图1到图2，找出根元素弹出。</li>
<li>图3到图4，将根元素向下迁移，与子元素比对，并替换位置。如果这个位置与8相比，小于8则继续向下迁移。</li>
<li>图4到图5，继续迁移，在原节点4的位置对应的两个子元素，都比8大，这个时候就可以停下来了。</li>
<li>图5到图6，更换元素位置，把队尾的元素替换到对应元素1向下迁移检测的位置。</li>
</ol>
<ul>
<li><em><strong>操作加锁</strong></em></li>
</ul>
<p><strong>offer：</strong>——入队元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//加锁，保证下面的代码块同一时刻只有一个线程能执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);<span class="comment">// 向队列q插入元素e</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            available.signal();<span class="comment">// 如果e是队首元素，唤醒等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 无论如何都要释放锁，防止死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>poll：</strong>——出队元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">// 加锁，保证下面的代码块同一时刻只有一个线程能执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek();<span class="comment">// 查看队首元素</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 队列为空或队首元素还没到期，返回null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q.poll();<span class="comment">// 队首元素可用，出队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 无论如何都要释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素的入队和出队都会使用 ReentrantLock 的方式进行加锁处理。确保线程安全。</li>
</ul>
<h5 id="为什么要用-ReentrantLock？"><a href="#为什么要用-ReentrantLock？" class="headerlink" title="为什么要用 ReentrantLock？"></a>为什么要用 ReentrantLock？</h5><ul>
<li><p>在多线程环境下，多个线程可能同时对队列进行入队（offer）和出队（poll）操作。</p>
</li>
<li><p>如果不加锁，可能会出现数据竞争、状态不一致等问题（比如两个线程同时插入或删除元素，导致队列结构损坏）。</p>
</li>
<li><p>ReentrantLock 是一种可重入的互斥锁，能保证同一时刻只有一个线程能执行被保护的代码块，从而保证队列操作的<strong>原子性</strong>和<strong>一致性</strong>。</p>
</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>单端队列和双端队列，分别对应的实现类是哪个？</strong></li>
</ul>
<p>​	单端队列（Queue）</p>
<ol>
<li><p>典型实现类：LinkedList、ArrayBlockingQueue、PriorityQueue、DelayQueue 等。</p>
</li>
<li><p>最大区别：只能在一端插入（入队），另一端删除（出队），即“先进先出”（FIFO）。</p>
</li>
</ol>
<p>​	双端队列（Deque）</p>
<ol>
<li><p>典型实现类：LinkedList、ArrayDeque、LinkedBlockingDeque。</p>
</li>
<li><p>最大区别：两端都可以插入和删除元素，既支持队列（FIFO）也支持栈（LIFO）操作。</p>
</li>
</ol>
<ul>
<li><strong>简述延迟队列&#x2F;优先队列的实现方式</strong></li>
</ul>
<p>​	优先队列（PriorityQueue）：底层通常用二叉堆实现，元素按优先级自动排序，每次出队都是优先级最高（或最低）的元素。</p>
<p>​	延迟队列（DelayQueue）：底层也是用优先队列（PriorityQueue）实现，元素按到期时间排序，只有到期的元素才能出队。</p>
<ul>
<li><strong>二叉堆插入&#x2F;弹出元素的过程</strong></li>
</ul>
<p>​	二叉堆插入元素过程：</p>
<ol>
<li><p>新元素放到堆的最后一个位置。</p>
</li>
<li><p>不断与父节点比较，如果不满足堆序（如小顶堆新元素比父节点小），就交换位置。</p>
</li>
<li><p>直到堆序满足或到达根节点，插入完成。</p>
<p>二叉堆弹出元素过程：</p>
</li>
<li><p>取出堆顶元素（最小或最大）。</p>
</li>
<li><p>用最后一个元素填补堆顶空位。</p>
</li>
<li><p>从堆顶开始，不断与子节点比较，如果不满足堆序就交换位置。</p>
</li>
<li><p>直到堆序满足或到达叶子节点，弹出完成。</p>
</li>
</ol>
<ul>
<li><strong>延迟队列的使用场景</strong></li>
</ul>
<ol>
<li><p>定时任务调度：如定时发送消息、定时执行某个操作。</p>
</li>
<li><p>订单超时处理：如电商下单后30分钟未支付自动取消订单。</p>
</li>
<li><p>缓存过期处理：缓存数据到期后自动清理。</p>
</li>
<li><p>消息延迟投递：消息队列中延迟发送消息。</p>
</li>
<li><p>重试机制：任务失败后延迟一段时间再重试。</p>
</li>
</ol>
<ul>
<li><strong>延迟队列为什么添加信号量</strong></li>
</ul>
<p>​	延迟队列添加信号量（如Condition）是为了在没有到期元素时让线程阻塞等待，而不是一直占用CPU自旋。当有新元素到期或插入时，通过信号量唤醒等待线程，保证高效和线程安全。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/24/%E9%98%9F%E5%88%97/" data-id="cmdnybny2001a0kqqh1xdhbx9" data-title="队列" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/23/%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2025-07-23T11:54:21.000Z" itemprop="datePublished">2025-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/23/%E6%95%B0%E7%BB%84/">数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="数组的数据结构"><a href="#数组的数据结构" class="headerlink" title="数组的数据结构"></a>数组的数据结构</h4><ul>
<li>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型数据的集合。</li>
<li>数组的特点：<ol>
<li>数组是相同数据类型的元素集合（int 不能存放 double）</li>
<li>数组中各元素的存储是有先后顺序的，它们在内存中按照这个顺序连续存放到一起。内存地址连续。</li>
<li>数组获取元素的时间复杂度为O(1)</li>
</ol>
</li>
</ul>
<hr>
<h4 id="实现一个ArrayList-数组"><a href="#实现一个ArrayList-数组" class="headerlink" title="实现一个ArrayList 数组"></a>实现一个ArrayList 数组</h4><ul>
<li><em><strong>基本设计</strong></em></li>
</ul>
<p>数组是一个固定的、连续的、线性的数据结构，那么想把它作为一个自动扩展容量的数组列表，则需要做一些扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//ArrayList 元素数组缓存区</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化 ArrayList 阶段，如果不指定大小，默认会初始化一个空的元素。这个时候是没有默认长度的。</li>
<li>那么什么时候给初始化的长度呢？是在首次添加元素的时候，因为所有的添加元素操作，也都是需要判断容量，以及是否扩容的。那么在 add 添加元素时统一完成这个事情，还是比较好处理的。</li>
<li>之后就是随着元素的添加，容量是会不足的。当容量不足的是，需要进行扩容操作。同时还得需要把旧数据迁移到新的数组上。<em>所以数据的迁移算是一个比较耗时的操作</em></li>
</ol>
<ul>
<li><em><strong>添加元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="comment">//计算添加新元素后所需的最小容量（当前元素个数+1）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minCapacity</span> <span class="operator">=</span> size + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果当前数组是“空数组”（即还没分配实际空间），则将最小容量设为默认容量（如10）和minCapacity中的较大者，保证初次分配时有足够空间。</span></span><br><span class="line">    <span class="keyword">if</span>(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)&#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果最小所需容量大于当前数组长度，说明需要扩容。</span></span><br><span class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//记录旧容量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新容量为旧容量的1.5倍（右移1位等于除以2），即扩容50%。</span></span><br><span class="line">        <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			newCapacity = minCapacity;<span class="comment">//如果1.5倍扩容后仍然不够，则直接扩容到minCapacity，保证能放下新元素。	</span></span><br><span class="line">        &#125;</span><br><span class="line">        elementData = Arrays.copyOf(elementData,newCapacity);<span class="comment">//用Arrays.copyOf扩容数组，将原有元素复制到新数组。</span></span><br><span class="line">    &#125;</span><br><span class="line">    elementData[size++] = e;<span class="comment">//将新元素放到数组末尾，size自增。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示添加成功。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="添加元素"></p>
<ol>
<li>判断当前容量与初始化容量，使用 Math.max 函数取最大值最为最小初始化空间。</li>
<li>接下来是判断 minCapacity 和元素的数量，是否达到了扩容。首次创建 ArrayList 是一定会扩容的，也就是初始化 DEFAULT_CAPACITY &#x3D; 10 的容量。</li>
<li>Arrays.copyOf 实际上是创建一个新的空间数组，之后调用的 System.arraycopy 迁移到新创建的数组上。这样后续所有的扩容操作，也就都保持统一了。</li>
<li>ArrayList 扩容完成后，就是使用 elementData[size++] &#x3D; e; 添加元素操作了。</li>
</ol>
<ul>
<li><em><strong>移除元素</strong></em></li>
</ul>
<p>ArrayList 的重点离不开对 System.arraycopy 的使用，它是一个本地方法，可以让你从原数组的特定位置，迁移到新数组的指定位置和迁移数量。如图 2-5 所示，数据迁移 <em>测试代码在 java-algorithms</em></p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/System.arraycopy.png" alt="System.arraycopy"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    E <span class="title function_">oldValue</span> <span class="params">(E)</span> elementData[index];<span class="comment">//取出下标为index的元素，保存到oldValue，用于最后返回。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index -<span class="number">1</span>;<span class="comment">//计算需要向前移动的元素个数。</span></span><br><span class="line">    <span class="comment">//如果numMoved&gt;0，说明被删除元素后面还有元素，需要整体向前移动一位。</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*System.arraycopy的含义：</span></span><br><span class="line"><span class="comment">		从elementData的index+1位置开始，拷贝numMoved个元素，</span></span><br><span class="line"><span class="comment">		拷贝到elementData的index位置开始。*/</span></span><br><span class="line">        System.arraycopy(elemnetData,index + <span class="number">1</span>,elementData,index,numMoved);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//size--，数组长度减一。把原来最后一个元素位置（现在已经没有用了）置为null，帮助垃圾回收（GC）。</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;<span class="comment">//返回被删除的元素。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>ArrayList 的元素删除，就是在确定出元素位置后，使用 System.arraycopy 拷贝数据方式移动数据，把需要删除的元素位置覆盖掉。</p>
</li>
<li><p>此外它还会把已经删除的元素设置为 null 一方面让我们不会在读取到这个元素，另外一方面也是为了 GC</p>
</li>
</ol>
<ul>
<li><em><strong>获取元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span><span class="comment">//重写了 Object 类的 toString() 方法，用于打印当前对象的字符串表示。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ArrayList&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;elementData=&quot;</span> + Arrays.toString(elementData) +</span><br><span class="line">            <span class="string">&quot;, size=&quot;</span> + size +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;<span class="comment">//  ArrayList&#123;elementData=[元素1, 元素2, ...], size=实际元素个数&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取元素就比较简单了，直接从 elementData 使用索引直接获取即可。这个是一个 O(1) 操作。也正因为搜索元素的便捷性，才让 ArrayList 使用的那么广泛。同时为了兼容可以通过元素来获取数据，而不是直接通过下标，引出了 HashMap 使用哈希值计算下标的计算方式，也引出了斐波那契散列。它们的设计都是在尽可能减少元素碰撞的情况下，尽可能使用贴近 O(1) 的时间复杂度获取数据。</li>
</ol>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>数据结构中有哪些是线性表数据结构？</strong></li>
</ul>
<p>​	数组、链表、栈、队列</p>
<ul>
<li><strong>数组的元素删除和获取，时间复杂度是多少？</strong></li>
</ul>
<p>​	数组元素的获取的时间复杂度是o(1)，因为可以根据索引精确的获取到内存地址，删除，在最坏的情况下是o(n)</p>
<ul>
<li><strong>ArrayList 中默认的初始化长度是多少？</strong></li>
</ul>
<p>​	ArrayList 中默认的初始化长度是10。</p>
<ul>
<li><strong>ArrayList 中扩容的范围是多大一次？</strong></li>
</ul>
<p>​	ArrayList 中扩容的范围是当前容量的一半。</p>
<ul>
<li><strong>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什么？</strong></li>
</ul>
<p>​	ArrayList 完成扩容是通过创建一个新的更大容量的数组，然后将旧数组中的元素复制到新数组中。</p>
<p>​	当前容量 + 当前容量&gt;&gt;1 也就是1.5倍的当前容量，然后调用arraycopy,数据迁移，将容量+1返回</p>
<p>​	System.arraycopy的参数 </p>
<p>​	1. src:原来的数组 </p>
<p>​	2. srcPos：原来数组要复制的起始位置</p>
<p>​	3. dest:目标数组 </p>
<p>​	4. destPos:目标数组放置的起始位置 </p>
<p>​	5. length:复制的长度 </p>
<p>​	Array.arraycopy底层调用的也是System.arraycopy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/23/%E6%95%B0%E7%BB%84/" data-id="cmdnybnxw000m0kqq7w3jdlh1" data-title="数组" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" rel="tag">创建文章</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" style="font-size: 10px;">创建文章</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">工具学习</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E9%87%8D%E7%82%B9/" style="font-size: 15px;">重点</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>
          </li>
        
          <li>
            <a href="/2025/07/28/2-3%E6%A0%91/">2-3树</a>
          </li>
        
          <li>
            <a href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a>
          </li>
        
          <li>
            <a href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">二分搜索树</a>
          </li>
        
          <li>
            <a href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/">字典树</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>