<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-布隆过滤器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T09:02:07.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="布隆过滤器结构"><a href="#布隆过滤器结构" class="headerlink" title="布隆过滤器结构"></a>布隆过滤器结构</h4><p>布隆过滤器是一个基于数组和哈希函数散列元素的结构，很像HashMap的哈希桶。布隆过滤器可以用于检测一个元素是否在集合中。它的优点是空间效率和查询时间比一般算法要好很多，但也有一定概率的误判性。<em>如HashMap出现哈希碰撞💥</em></p>
<hr>
<h4 id="布隆过滤器实现"><a href="#布隆过滤器实现" class="headerlink" title="布隆过滤器实现"></a>布隆过滤器实现</h4><p>布隆过滤器的实现条件包括可以存放二进制元素的 BitSet 以及多样性的哈希计算函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashGenerator.HashGroup[] GROUPS = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>.HashGroup[]&#123;HashGenerator.HashGroup.G1, HashGenerator.HashGroup.G2, HashGenerator.HashGroup.G3, HashGenerator.HashGroup.G4&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitSet bits;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> HashGenerator[] generators;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的元素存放都经过多样的哈希计算存放到 BitSet 中，这样可以尽可能的分散元素，减少误判性。</p>
<ul>
<li><em><strong>哈希函数</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG1</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">        hash = Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % (seed * size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG2</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">7397</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % seed * (size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG3</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash += c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % (seed * size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG4</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs(seed * (size - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里提供了四种哈希计算的方式，相当于每一个哈希计算都是一次扰动处理。一个元素的存放可以经过四次哈希，尽量让元素值做到散列。</li>
</ul>
<ul>
<li><em><strong>构建容器</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span>[] seeds)</span> &#123;</span><br><span class="line">    bits = <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    generators = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>[seeds.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seeds.length; i++) &#123;</span><br><span class="line">        generators[i] = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>(size, seeds[i], GROUPS[i % GROUPS.length]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数根据所需创建的容器大小和哈希种子来初始化布隆过滤器。</li>
</ul>
<ul>
<li><em><strong>添加元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> generator.doHash(value);</span><br><span class="line">        bits.set(hash, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素时按照元素初始化时的哈希计算种类，获取哈希并存放。</li>
</ul>
<ul>
<li><em><strong>比对元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        ret = ret &amp;&amp; bits.get(generator.doHash(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>比对元素时用的是同一类哈希计算方式，并且把这些哈希值 <code>&amp;&amp;</code> 计算。<em>用N个比特位置记录一个值更准确</em></li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>布隆过滤器的使用场景？</strong></li>
</ul>
<p><strong>布隆过滤器使用场景</strong>：缓存穿透防护（避免查询不存在的数据）、垃圾邮件过滤、网页爬虫URL去重、数据库查询优化（预先判断数据是否存在）、分布式系统中的重复数据检测、黑名单快速判断等需要快速判断元素是否”可能存在”的场景。</p>
<p><strong>核心优势</strong>：空间效率极高，查询速度快，但存在误判（可能存在但实际不存在）。</p>
<ul>
<li><strong>布隆过滤器的实现原理和方式？</strong></li>
</ul>
<p><strong>布隆过滤器实现原理</strong>：使用位数组和多个哈希函数，插入元素时将其通过k个哈希函数映射到位数组的k个位置并置1，查询时检查这k个位置是否都为1。</p>
<p><strong>实现方式</strong>：初始化m位的位数组全为0，选择k个独立哈希函数，插入时设置对应位为1，查询时检查所有对应位。</p>
<p><strong>核心特点</strong>：不存在假阴性（存在的一定返回存在），但有假阳性（可能误判不存在的为存在），无法删除元素。</p>
<ul>
<li><strong>如何提高布隆过滤器的准确性？</strong></li>
</ul>
<p><strong>增加位数组大小</strong>：更大的m值降低哈希冲突概率。<strong>优化哈希函数数量</strong>：选择最优的k值（约为m&#x2F;n*ln2）平衡误判率。<strong>使用高质量哈希函数</strong>：选择分布均匀、冲突少的哈希算法。<strong>控制元素数量</strong>：避免超过设计容量导致误判率急剧上升。</p>
<p><strong>核心公式</strong>：误判率≈(1-e^(-kn&#x2F;m))^k，通过调整m、k、n三个参数优化准确性。</p>
<ul>
<li><strong>有哪些中哈希计算方式？</strong></li>
</ul>
<p><strong>除法散列</strong>：h(k) &#x3D; k mod m，简单但容易聚集。<strong>乘法散列</strong>：h(k) &#x3D; ⌊m(kA mod 1)⌋，A为常数。<strong>平方取中法</strong>：对关键字平方后取中间几位。<strong>折叠法</strong>：将关键字分段相加。</p>
<p><strong>字符串哈希</strong>：djb2、sdbm、FNV等算法。<strong>密码学哈希</strong>：MD5、SHA-1、SHA-256等安全性更高。<strong>现代哈希</strong>：MurmurHash、CityHash等高性能算法。</p>
<p><strong>选择原则</strong>：根据数据特点和性能要求选择合适的哈希函数。</p>
<ul>
<li><strong>都有哪些类型的布隆过滤器实现？<em>Google 开源的 Guava 中自带的布隆过滤器、Redis 中的布隆过滤器</em></strong></li>
</ul>
<p><strong>标准布隆过滤器</strong>：经典实现，不支持删除操作。<strong>计数布隆过滤器</strong>：用计数器替代位数组，支持删除但占用更多空间。<strong>可扩展布隆过滤器</strong>：动态增加容量避免误判率上升。</p>
<p><strong>Guava布隆过滤器</strong>：Google开源，支持自定义误判率和容量，提供便捷API。<strong>Redis布隆过滤器</strong>：通过RedisBloom模块实现，支持分布式场景，提供bf.add和bf.exists命令。</p>
<p><strong>其他实现</strong>：Cassandra、HBase等数据库内置布隆过滤器优化查询性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" data-id="cmdocxzds000ni8qqcjmpbs6r" data-title="布隆过滤器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%9B%BE/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T07:35:44.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%9B%BE/">图</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="图的数据结构"><a href="#图的数据结构" class="headerlink" title="图的数据结构"></a>图的数据结构</h4><p>图（Graph）结构是一种比树结构复杂的非线性的数据结构，图在实际生活中的例子非常多，比如；地铁线路网、微信好友关系链、计算机中的状态执行等，都可以抽象成图的结构。</p>
<p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E) &#x3D; 【G表示图、V表示顶点个数、E表示边的个数】。图的数据结构是多对多关系，就像你的微信好友可能也是我的微信好友，且相互交叉对应。与之对应的是树，树是1对多关系，所以树也是一种特殊的没有闭环的图。</p>
<p>按照图<strong>是否有方向</strong>和<strong>是否有权重</strong>可以分为一下4类组合；</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%9B%BE%E7%A7%8D%E7%B1%BB.png" alt="图种"></p>
<ul>
<li>顶点：图中的任意节点都算作顶点，图中任意两个顶点间都可能存在连接，如果没有顶点间没有连线则称为空图。</li>
<li>无向图：图中任意两个顶点间都没有指向，则称这样的图为无向图。</li>
<li>有向图：图中任意两个顶点间都有指向边，则称这样的图为有向图。</li>
<li>无权重：图中任意两个顶点间的连线，没有权重值，则无权重。</li>
<li>有权重：图中任意两个顶点间的连线，包含权重值，则有权重。</li>
</ul>
<hr>
<h4 id="图的结构实现"><a href="#图的结构实现" class="headerlink" title="图的结构实现"></a>图的结构实现</h4><p>图的结构实现可以基于数组、链表和红黑树实现，也因此将使用数组实现的图称为邻接矩阵，链表和红黑树实现的图称为邻接表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的矩阵【数组】</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"><span class="comment">// 图的矩阵【链表】</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"><span class="comment">// 图的矩阵【红黑树】</span></span><br><span class="line"><span class="keyword">private</span> TreeSet&lt;Integer&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>图的数据存放可以使用 int 数组、LinkedList 链表、TreeSet 红黑树等方式存储。</p>
<ul>
<li><strong>邻接矩阵【数组】</strong></li>
</ul>
<ol>
<li><strong>无向图&amp;无权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x][y] = <span class="number">1</span>;</span><br><span class="line">    table[y][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，对称插入节点。例如：0→1、1→0，两个方向都插入元素。</li>
</ul>
<ol start="2">
<li><strong>有向图&amp;有权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x][y] = weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，插入单向节点，节点值为权重值。例如：0→2，权重值是4。</li>
</ul>
<ul>
<li><em><strong>邻接表【链表】</strong></em></li>
</ul>
<ol>
<li><strong>无向图&amp;无权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y&#125;);</span><br><span class="line">    table[y].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;x&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，无向无权重直接对称插入元素即可。</li>
</ul>
<ol start="2">
<li><strong>有向图&amp;有权重</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，有方向，有权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y, weight&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，有方向有权重则只插入单个指向，并需要通过数组或者对象的方式记录权重值。</li>
</ul>
<ul>
<li><em><strong>遍历</strong></em></li>
</ul>
<p>图的最终实现是通过 TreeSet 红黑树的方式，这样即节省空间，又能提高元素的索引和遍历效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">private</span> TreeSet&lt;Integer&gt;[] table;</span><br></pre></td></tr></table></figure>

<ol>
<li>深度遍历，不断地向下探测。广度遍历横行探测。</li>
<li>当有权重时候，则深度和广度会按照权重进行选择优先遍历的顺序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        order.add(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                queue.add(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 深度优先，前序遍历</span></span><br><span class="line">    pre.add(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : graph.adj(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先，后序遍历</span></span><br><span class="line">    post.add(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>图的使用场景是什么？</strong></li>
</ul>
<p><strong>图的使用场景</strong>：社交网络（好友关系）、地图导航（最短路径）、网络拓扑（路由算法）、任务调度（依赖关系）、推荐系统（关联分析）、电路设计、生物信息学（基因网络）、搜索引擎（网页链接）、交通规划等需要表示复杂关系和连接的问题。</p>
<p><strong>核心优势</strong>：能够自然表达实体间的多对多关系和复杂网络结构。</p>
<ul>
<li><strong>图有的分类？</strong></li>
</ul>
<p><strong>按边的方向</strong>：有向图（边有方向）、无向图（边无方向）。</p>
<p><strong>按边的权重</strong>：带权图（边有权值）、无权图（边无权值）。</p>
<p><strong>按连通性</strong>：连通图（任意两点可达）、非连通图、强连通图（有向图中任意两点互相可达）。</p>
<ul>
<li><strong>图怎么存放权重值？</strong></li>
</ul>
<p><strong>邻接矩阵</strong>：二维数组matrix[i][j]存储从顶点i到顶点j的边权重，无边时存储无穷大或特殊值。</p>
<p><strong>邻接表</strong>：每个顶点维护一个列表，存储(目标顶点, 权重)的键值对。</p>
<p><strong>边列表</strong>：直接存储所有边的信息，每条边包含(起点, 终点, 权重)三元组。</p>
<p><strong>核心选择</strong>：稠密图用邻接矩阵，稀疏图用邻接表，算法处理用边列表。</p>
<ul>
<li><strong>图的广度遍历</strong></li>
</ul>
<p><strong>图的广度遍历（BFS）</strong>：从起始顶点开始，先访问所有相邻顶点，再逐层向外扩展访问。<strong>实现方式</strong>：使用队列存储待访问顶点，用visited数组标记已访问节点避免重复。<strong>遍历顺序</strong>：按距离起点的层次逐层访问，同层顶点访问顺序取决于邻接表顺序。</p>
<p><strong>核心特点</strong>：能找到最短路径（无权图），时间复杂度O(V+E)。</p>
<ul>
<li><strong>图的深度遍历</strong></li>
</ul>
<p><strong>图的深度遍历（DFS）</strong>：从起始顶点开始，沿着一条路径尽可能深入，直到无法继续时回溯到上一个顶点，继续探索其他路径。<strong>实现方式</strong>：使用栈（或递归）存储待访问顶点，用visited数组标记已访问节点避免重复。<strong>遍历特点</strong>：优先深度探索，能检测环路和连通分量。</p>
<p><strong>核心特点</strong>：适合路径搜索和拓扑排序，时间复杂度O(V+E)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%9B%BE/" data-id="cmdocxzdo000ai8qq85xteqoj" data-title="图" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-并查集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-07-29T03:25:50.000Z" itemprop="datePublished">2025-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="并查集数据结构"><a href="#并查集数据结构" class="headerlink" title="并查集数据结构"></a>并查集数据结构</h5><p>并查集数据结构（也称为联合-查找数据结构或合并-查找集）基于数组实现的一种跟踪元素的数据结构，这些元素被划分为多个不相交（非重叠）的子集。</p>
<p>它提供了近乎恒定的时间操作（以逆阿克曼函数为界）来添加新集合、合并现有集合以及确定元素是否在同一个集合中。除了推荐算法、好友关系链、族谱等，并查集在 <code>Kruskal</code>的算法中扮演着关键角色，用于寻找无向边加权图的最小生成树。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/4.png"></p>
<p>为了尽可能少的检索次数到根元素，在01：粗暴合并的基础上，有了基于数量、排序的合并方式，同时还包括可以压缩路径。这样再索引到根节点的时间复杂度就又降低了。</p>
<hr>
<h4 id="并查集结构实现"><a href="#并查集结构实现" class="headerlink" title="并查集结构实现"></a>并查集结构实现</h4><p>并查集的实现非常巧妙，只基于数组就可以实现出一个树的效果（基于数组实现的还有二叉堆也是树的结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line">	  <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 数量【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] count;</span><br><span class="line">	<span class="comment">// 排序【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集的元素存放在数组中，通过对数组元素的下标索引指向其他元素，构成一棵树。count 数量、rank 排序，是用于对并查集合并元素时的优化处理。</p>
<ul>
<li><em><strong>默认合并 - union(1, 8)</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E9%BB%98%E8%AE%A4%E5%90%88%E5%B9%B6.png" alt="默认合并"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查索引是否越界，抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> items[i];</span><br><span class="line">    <span class="comment">// 返回索引i对应的根节点值（集合标识符）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentVal</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 获取parent节点所属集合的根节点值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childVal</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="comment">// 获取child节点所属集合的根节点值</span></span><br><span class="line">    <span class="keyword">if</span> (parentVal == childVal) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果两个节点已经在同一集合中，直接返回</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i ++)&#123;</span><br><span class="line">        <span class="comment">// 遍历整个数组</span></span><br><span class="line">        <span class="keyword">if</span> (items[i] == childVal)&#123;</span><br><span class="line">            <span class="comment">// 找到所有属于child集合的节点</span></span><br><span class="line">            items[i] = parentVal;</span><br><span class="line">            <span class="comment">// 将它们的根节点值改为parent集合的根节点值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成两个集合的合并操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>union 是合并元素的方法，两个入参意思是把 child 指向的根节点，指向 parent 指向的根节点。后面所有案例中 union 方法属性字段意思相同。</li>
<li>find 找到元素对应的根节点值，之后使用 union 方法对 items 数组内的元素全部遍历，把所有值等于 child 的节点，都替换为 parent 节点值。</li>
<li>每次合并都for循环比较耗时，所以后续做了一些列的优化。</li>
</ul>
<ul>
<li><em><strong>粗暴合并</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E7%B2%97%E6%9A%B4%E5%90%88%E5%B9%B6.png" alt="粗暴合并"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 找到元素的根节点，当i == item[i]，就是自己指向自己，这个节点就是根节点</span></span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 孩子节点值替换为父节点值</span></span><br><span class="line">    items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>find 循环找到置顶节点的最终根节点，例如；8 → 6、6 → 6，那么说明8的根节点是6，因为6自己指向自己了，它就是根节点。</li>
<li>union 将 8 指向的根节点 6，更换为 1 指向的根节点 0。最终替换完就是 6 → 0，那么8的根节点有也是0了。</li>
<li>这样虽然减少了每次 for 循环更新，但粗暴的合并会对节点的索引带来一定的复杂度。所以还需要继续优化。</li>
</ul>
<ul>
<li><em><strong>压缩路径</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8E%8B%E7%BC%A9%E8%B7%AF%E5%BE%84.png" alt="压缩路径"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        items[i] = items[items[i]];</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[parentRootIdx] &gt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[parentRootIdx] &lt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[parentRootIdx] = items[childRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">        rank[parentRootIdx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(8, 1) 在rank合并下，压缩路径长度。</p>
<ul>
<li>这里的 union 方法与<code>4. 排序合并</code>相比并没有变化，变化的地方主要在 find 过程中压缩路径。</li>
<li>find 基于查找根元素时，对当前元素值对应的父节点值，替换给当前元素。减少一级路径，做到压缩路径的目的。</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>并查集叙述？</strong></li>
</ul>
<p><strong>并查集</strong>：用于处理不相交集合的合并和查询问题的数据结构。<strong>核心操作</strong>：find（查找元素所属集合）和union（合并两个集合）。<strong>主要实现</strong>：数组存储每个元素的父节点，通过路径压缩和按秩合并优化性能。<strong>应用场景</strong>：连通性问题、最小生成树算法、动态连通性查询等。<strong>时间复杂度</strong>：优化后接近O(1)。</p>
<ul>
<li><strong>并查集的使用场景？</strong></li>
</ul>
<p><strong>并查集使用场景</strong>：判断图的连通性、检测无向图中的环、最小生成树算法（Kruskal）、社交网络中的朋友圈划分、像素连通区域检测、网络连接状态判断、动态连通性查询等需要快速合并和查找集合关系的问题。</p>
<p><strong>核心特点</strong>：擅长处理”分组”和”连通性”相关的动态问题。</p>
<ul>
<li><strong>并查集怎么合并元素？</strong></li>
</ul>
<p><strong>并查集合并元素</strong>：通过union操作将两个元素所属的集合合并。<strong>具体步骤</strong>：1）找到两个元素各自的根节点；2）如果根节点相同则已在同一集合；3）否则将一个根节点指向另一个根节点，完成合并。<strong>优化策略</strong>：按秩合并（小树挂到大树下）避免树过深，提高后续查找效率。</p>
<ul>
<li><strong>并查集合并元素的优化策略？</strong></li>
</ul>
<p><strong>按秩合并</strong>：将深度小的树挂到深度大的树下，避免树过深影响查找效率。</p>
<p><strong>路径压缩</strong>：在find操作中将路径上所有节点直接指向根节点，减少后续查找深度。</p>
<p><strong>两者结合</strong>：使union和find操作的时间复杂度接近O(1)，大幅提升整体性能。</p>
<ul>
<li><strong>如何压缩路径？</strong></li>
</ul>
<p><strong>路径压缩</strong>：在find操作中，将查找路径上的所有节点直接指向根节点。<strong>实现方式</strong>：递归查找根节点时，在返回过程中将当前节点的父指针直接指向根节点，使树变得扁平化。<strong>效果</strong>：后续对同一路径上节点的查找操作时间复杂度接近O(1)。</p>
<p><strong>代码核心</strong>：<code>parent[x] = find(parent[x])</code>，递归压缩路径。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/" data-id="cmdocxzdt000ti8qqc2xc448v" data-title="并查集" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-红黑树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T08:59:18.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="红黑树数据结构"><a href="#红黑树数据结构" class="headerlink" title="红黑树数据结构"></a>红黑树数据结构</h4><p>建立在 BST 二叉搜索树的基础上，AVL、2-3树、红黑树都是自平衡二叉树（统称B-树）。但相比于AVL树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。也正因红黑树在插入和删除时不需要太多的平衡操作，也让它成为；Java中HashMap的元素碰撞后的转换、Linux的CFS进行调度算法、多路复用技术的Epoll等各类底层的数据结构实现。</p>
<p>红黑树的五条定义：</p>
<ol>
<li><strong>每个节点不是红色就是黑色。</strong><ul>
<li>黑色决定平衡，红色不决定平衡。这对应了2-3树中一个节点内可以存放1~2个节点。</li>
</ul>
</li>
<li><strong>根是黑色的。</strong><ul>
<li>这条规则有时会被省略。由于根总是可以从红色变为黑色，但不一定相反，因此该规则对分析几乎没有影响。</li>
</ul>
</li>
<li><strong>所有叶子 (NIL) 都是黑色的。</strong><ul>
<li>这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。</li>
</ul>
</li>
<li><strong>如果一个节点是红色的，那么它的两个子节点都是黑色的。</strong><ul>
<li>通常这条规则也叫不会有连续的红色节点。这体现在2-3树中，一个节点最多临时会有3个节点，中间是黑色节点，左右是红色节点。2-3树中出现这样的情况后，会进行节点迁移，中间节点成为父节点，左右节点成为子节点。</li>
</ul>
</li>
<li><strong>从给定节点到其任何后代 NIL 节点的每条路径都包含相同数量的黑色节点。</strong><ul>
<li>对应2-3树中，每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="红黑树结构实现"><a href="#红黑树结构实现" class="headerlink" title="红黑树结构实现"></a>红黑树结构实现</h4><p>基于 BST 二叉搜索树的基础上，AVL树添加了树高作为计算平衡因子的条件，那么红黑树也需要添加一个新的颜色属性，用于处理平衡操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">// 红黑树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.RED;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>相比于AVL树通过左右旋转平衡树高，红黑树则是在2-3树的基础上，只对黑色节点维护树高，所以它会使用到染色和左右旋来对树高调衡。<em>染色与左右旋相比，减少了平衡操作</em></p>
<ul>
<li><em><strong>左倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="左倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.right;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span> (uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current = grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>右倾染色</strong></em></li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E5%80%BE%E6%9F%93%E8%89%B2.png" alt="右倾"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.left;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span>(uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current= grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li>
<li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li>
</ul>
<ul>
<li><em><strong>左旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次左旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%B7%A6%E6%97%8B.png" alt="一次左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的左侧小图，新增的节点5导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点4提起来，而对应红黑树则需要先进行染色，待操作的节点4为黑色，两个孩子节点为红色。</li>
<li>最后是把节点3进行一次左旋操作，完成树的平衡。对应步骤3中的左侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>右旋+左旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要右旋+左旋的情况，在AVL树中有同样的场景。本身树需要左旋操作，但整体分支树节点偏左，此时需要右旋调整树结构再左旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%2B%E5%B7%A6.png" alt="右左"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏左↙，先右旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.left)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateRight(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点4以后，4↙5 结构偏左，需要先进行右旋调衡树结构，再进行左旋。其实这个时候再进行的左旋就和上面一次左旋操作一致了。</li>
</ul>
<ul>
<li><em><strong>右旋调整</strong></em></li>
</ul>
<ol>
<li><strong>一次右旋</strong></li>
</ol>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E4%B8%80%E6%AC%A1%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的右侧小图，新增的节点1导致2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点2提起来，而对应红黑树则需要先进行染色，待操作的节点2为黑色，两个孩子节点为红色。</li>
<li>最后是把节点2进行一次右旋操作，完成树的平衡。对应步骤3中的右侧小图是2-3树调衡后的结果。</li>
</ul>
<ol start="2">
<li><strong>左旋+右旋</strong></li>
</ol>
<p>当一次左旋没法调衡，需要左旋+右旋的情况，在AVL树中有同样的场景。本身树需要右旋操作，但整体分支树节点偏右，此时需要左旋调整树结构再右旋。</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%2B%E5%8F%B3.png" alt="左右"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏右↘，先左旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.right)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateLeft(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树新增节点2以后，1↘2 结构偏右，需要先进行左旋调衡树结构，再进行右旋。其实这个时候再进行的右旋就和上面一次右旋操作一致了。</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>红黑树都有哪些使用场景？</strong></li>
</ul>
<p><strong>红黑树使用场景</strong>：Java TreeMap&#x2F;TreeSet、C++ STL的map&#x2F;set、Linux内核进程调度、数据库索引结构、编译器符号表、内存管理	器、高性能缓存系统等需要稳定O(log n)性能的场景。</p>
<p><strong>核心优势</strong>：相比AVL树旋转次数少，相比普通BST保证平衡，适合频繁插入删除的应用。</p>
<ul>
<li><strong>相比于BST树，红黑树有什么用途？</strong></li>
</ul>
<p><strong>红黑树相比BST的用途</strong>：解决BST最坏情况退化成链表的问题，通过着色和旋转机制保证树的近似平衡，确保查找、插入、删除操作始终维持O(log n)时间复杂度，避免性能恶化。</p>
<p><strong>关键作用</strong>：防止恶意数据攻击导致的性能退化，提供稳定可预期的性能保证。</p>
<ul>
<li><strong>B-树是什么意思，都包括哪些？</strong></li>
</ul>
<p><strong>B-树定义</strong>：多路平衡搜索树，每个节点可存储多个键值和子节点，所有叶子节点在同一层。</p>
<p><strong>主要类型</strong>：B树（内部节点和叶子节点都存数据）、B+树（只有叶子节点存数据，内部节点只存索引）、B*树（B+树的优化版本，节点利用率更高）。</p>
<p><strong>核心用途</strong>：数据库索引、文件系统，因为减少磁盘I&#x2F;O次数，适合大数据量存储。</p>
<ul>
<li><strong>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</strong></li>
</ul>
<p><strong>染色情况</strong>：父节点和叔叔节点都是红色时，将父节点、叔叔节点染黑，祖父节点染红。</p>
<p><strong>左旋情况</strong>：父节点是红色、叔叔节点是黑色，且新节点是父节点的右子节点时。</p>
<p><strong>左旋+右旋情况</strong>：父节点是红色、叔叔节点是黑色，新节点是父节点的左子节点，但父节点是祖父节点的右子节点时（右-左型不平衡）。</p>
<p><strong>核心原则</strong>：通过染色、旋转保持红黑树的5个性质不被破坏。</p>
<ul>
<li><strong>红黑树的特点是什么？</strong></li>
</ul>
<p><strong>红黑树特点</strong>：节点非红即黑、根节点是黑色、红节点的子节点必须是黑色、从任一节点到叶子节点的路径包含相同数量的黑节点、叶子节点（NIL）是黑色。</p>
<p><strong>核心优势</strong>：自平衡、最坏情况仍保证O(log n)性能、相比AVL树旋转次数少、插入删除效率高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/" data-id="cmdocxzdv0012i8qq6kz20vta" data-title="红黑树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2-3树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/2-3%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T07:57:52.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/2-3%E6%A0%91/">2-3树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="2-3树数据结构"><a href="#2-3树数据结构" class="headerlink" title="2-3树数据结构"></a>2-3树数据结构</h4><p>2–3树是一种树型数据结构，由约翰·霍普克洛夫特于1970年发明。它通过在一个节点存放1-2个元素来平衡树高。从而也使2-3树存在2叉节点和3叉节点。</p>
<p><img src="https://bugstack.cn/images/article/algorithm/tree-23-01.png?raw=true" alt="img"></p>
<p>这里要提到一点，在BST二叉搜索树可能退化成链表的基础上。引出了自平衡二叉树，也就是包括上一章实现的AVL树和Java API HashMap中用到的红黑树，它们都属于BalancedTree，也统称为B树，平衡的意思。</p>
<p>而本章实现的2-3树也是一种简单的平衡树，其中每个具有子节点（内部节点）的节点要么有两个子节点（2 节点）和一个数据元素，要么有三个子节点（3 节点）和两个数据元素。另外 2-3 树是3阶B 树，2-3-4 树是4阶B树。</p>
<hr>
<h4 id="2-3树结构实现"><a href="#2-3树结构实现" class="headerlink" title="2-3树结构实现"></a>2-3树结构实现</h4><ul>
<li><em><strong>节点定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node_2_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="comment">// 孩子</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3[] children;</span><br><span class="line">    <span class="comment">// 父亲【非必须】</span></span><br><span class="line">    <span class="keyword">public</span> Node_2_3 parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node_2_3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">this</span>.number = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="built_in">this</span>.number - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.items[idx] &lt; e) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = <span class="built_in">this</span>.items[idx];</span><br><span class="line">            --idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = e;</span><br><span class="line">        ++<span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2-3树的几点元素需要包括；一个数组的元素集合、元素的序号、孩子元素。因为一个节点最多可临时放入3个元素，那么就会最多有4个孩子元素，所以孩子元素也是一个数组并且在构造函数中按照4个元素进行初始化。</li>
<li>由于本身2-3树插入元素的开始阶段，并不是直接创建一个新的节点，而是在初始化的数组空间中存入元素。所以在节点中提供了一个插入元素的方法 insert 来处理新增元素。</li>
<li>另外2-3树的节点类，还提供了一个方便查询的方法。包括：获取左边元素、中间元素、右边元素，以及最小值、最大值和判断是否有孩子节点。这些内容可以源码。</li>
</ul>
<ul>
<li><em><strong>拆分节点</strong></em></li>
</ul>
<p>当一个节点内有3个元素的时候，就要发起拆分东西，拆分的过程分为；</p>
<ol>
<li>对3个节点的中间节点，插入到父节点上。</li>
<li>剩余2个节点创建出新的节点。</li>
<li>建立父节点和新创建的2个节点间关系。</li>
</ol>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8B%86%E5%88%86%E8%8A%82%E7%82%B9.png" alt="拆分节点"></p>
<ol>
<li>插入父节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">split</span><span class="params">(Node_2_3 node, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    parent.insert(node.getMiddleItem());</span><br><span class="line">    </span><br><span class="line">    Node_2_3[] newNodes = <span class="built_in">this</span>.triangle(node);</span><br><span class="line">    <span class="built_in">this</span>.replaceChild(parent, node, newNodes[<span class="number">0</span>], newNodes[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整个2-3树拆分的过程就是在 split 这个方法里，第一步解决了是否有父节点，没有则创建。</li>
<li>之后将原节点的中间值插入到父节点中。接下来的操作就是拆分新节点和更换孩子节点建立新连接。</li>
</ul>
<ol start="2">
<li>拆分新节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3[] triangle(Node_2_3 node) &#123;</span><br><span class="line">    Node_2_3[] newNodes = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">2</span>];</span><br><span class="line">    newNodes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">0</span>]);</span><br><span class="line">    newNodes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!node.isLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 左孩子</span></span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">0</span>] = node.children[<span class="number">0</span>];</span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">1</span>] = node.children[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 右孩子</span></span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">0</span>] = node.children[<span class="number">2</span>];</span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">1</span>] = node.children[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于传递进来的节点，将节点的左右孩子创建新节点，如果这个孩子节点还有分支节点，则一并更新。</li>
</ul>
<ol start="3">
<li>建立新连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceChild</span><span class="params">(Node_2_3 parent, Node_2_3 oldChild, Node_2_3 child01, Node_2_3 child02)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChild == parent.children[<span class="number">0</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = parent.children[<span class="number">1</span>];</span><br><span class="line">        parent.children[<span class="number">1</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">0</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldChild == parent.children[<span class="number">1</span>]) &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">        parent.children[<span class="number">2</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">1</span>] = child01;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.children[<span class="number">3</span>] = child02;</span><br><span class="line">        parent.children[<span class="number">2</span>] = child01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>建立新连接需要判断这个节点 oldChild 是父节点的左、中、右，之后进行依次的更换。</li>
<li>如拆分节点的介绍图中，用到的就是 <code>parent.children[1] = child02;parent.children[0] = child01;</code> 两步操作过程。</li>
</ul>
<ul>
<li><em><strong>新增节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录元素</span></span><br><span class="line">    elementList.add(e);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = insert(e, root);</span><br><span class="line">        <span class="keyword">if</span> (root.number == <span class="number">3</span>) &#123;</span><br><span class="line">            root = split(root, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.isLeaf()) &#123;</span><br><span class="line">        parent.insert(e);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node_2_3</span> <span class="variable">child</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent.number == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; parent.getMiddleItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getRight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child.number == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.split(child, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增节点的过程就比较简单了，一种是使用递归找到可以插入的位置，另外一种就是 where 循环。我们再BST、AVL两种数据结构种都是用了 where 循环。</li>
<li>在2-3树中 insert 方法递归到对应的插入位置后，开始插入元素。当插入元素结束后判断这个节点是否已经达到了3个节点，如果是则进行拆分。<em>拆分就调用了上面的步骤</em></li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>2-3树的数据结构描述</strong></li>
</ul>
<p>​	每个节点包含1-2个键值和2-3个子节点指针，2节点存储1个键，3节点存储2个键（按大小排序），所有叶子节点在同一层，满足搜索树性质。</p>
<ul>
<li><strong>2-3树一个节点最多可以存放几个元素</strong></li>
</ul>
<p>​	2-3树一个节点最多存放2个元素（3节点包含2个键值）。</p>
<ul>
<li><strong>2-3树插入节点时间复杂度</strong></li>
</ul>
<p>​	O(log n)，因为树高度为O(log n)且插入时最多向上分裂到根节点。</p>
<ul>
<li><strong>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></strong></li>
</ul>
<p>​	中间元素上移到父节点，左右元素分裂成两个2节点，不需要旋转操作，只需要节点分裂和元素上移。</p>
<ul>
<li><strong>2-3树，你能手写一下吗？</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node23</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];        <span class="comment">// 最多2个键</span></span><br><span class="line">    Node23[] children = <span class="keyword">new</span> <span class="title class_">Node23</span>[<span class="number">3</span>]; <span class="comment">// 最多3个子节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">keyCount</span> <span class="operator">=</span> <span class="number">0</span>;               <span class="comment">// 当前键的数量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> <span class="literal">true</span>;          <span class="comment">// 是否为叶子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is2Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">is3Node</span><span class="params">()</span> &#123; <span class="keyword">return</span> keyCount == <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/2-3%E6%A0%91/" data-id="cmdocxzde0000i8qqbrtv1222" data-title="2-3树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-平衡二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T02:30:39.000Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="AVL树数据结构"><a href="#AVL树数据结构" class="headerlink" title="AVL树数据结构"></a>AVL树数据结构</h4><p>AVL 自平衡二叉树的出现，其目的在于解决二叉搜索树退化成链表的问题。当我们向BST二叉搜索树顺序存入<code>1、2、3、4、5、6、7</code>个元素时，它会退化成一条链表，因而失去树查询的时间复杂度，所以我们需要AVL树平衡树高。如图所示</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/AVL%E6%A0%91.png" alt="AVL"></p>
<p>那么AVL树是怎么平衡树高的呢？</p>
<p>当二叉树的左右分支树高差不为1时，需要进行左旋或者右旋，来调衡树高。这有点像开车的时候，如果车头偏左就往右打方向盘，车头偏右就往左打方向盘是一个道理。那这个方向盘(左旋、右旋)是怎么打的呢，主要分以下四种情况；</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/4.png" alt="4"></p>
<ul>
<li>节点树高：以节点4为说明，最长的左右分支节点个数，就是节点4的最大树高。这里节点4左右孩子节点最长路径都为2，所以它的树高为2。同理可计算其他节点树高。</li>
<li>平衡因子：通过当前节点的左右子节点作差计算平衡因子，之后AVL树通过平衡因子，定义了什么时候进行左旋和右旋。</li>
</ul>
<hr>
<h4 id="AVL树代码实现"><a href="#AVL树代码实现" class="headerlink" title="AVL树代码实现"></a>AVL树代码实现</h4><p>对于 AVL 树的实现与 BST 二叉搜索树相比，在树的节点定义上多了一个树高的属性。也有些AVL树使用的是平衡因子的属性，就是通过树高计算后的结果。树节点代码结构如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>图解左旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%B7%A6%E6%97%8B.png" alt="左旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.right;              <span class="comment">// 保存右子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 右子节点继承原节点的父节点</span></span><br><span class="line">  </span><br><span class="line">    node.right = temp.left;              <span class="comment">// 原节点的右子树变为右子节点的左子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;            <span class="comment">// 如果新的右子树不为空</span></span><br><span class="line">        node.right.parent = node;        <span class="comment">// 设置新右子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    temp.left = node;                    <span class="comment">// 原节点成为右子节点的左子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为右子节点</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>左旋的作用，相当于通过向上迁移树高差大于1的右子节点来降低树高的操作。</li>
<li>通过节点4拿到父节点2和右子节点5，把父节点2和右子节点5建立关联</li>
<li>节点5的左子节点，相当于是大于4的那么一个值，只不过这里不体现。那么这个节点5的左子节点，应该被迁移到节点4的右子节点上。</li>
<li>整理节点5的关系，左子节点为4。左子节点4的父节点为5</li>
<li>如果说迁移上来的节点5无父节点，那么它就是父节点 root &#x3D; temp</li>
<li>迁移上来的节点5，找到原节点4是对应父节点的左子节点还是右子节点，对应的设置节点5的左右位置</li>
</ol>
<h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>图解右旋操作；它就是一种摘链更换调整节点的处理过程</p>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateRight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;               <span class="comment">// 保存左子节点，它将成为新的根</span></span><br><span class="line">    temp.parent = node.parent;           <span class="comment">// 左子节点继承原节点的父节点</span></span><br><span class="line">    </span><br><span class="line">    node.left = temp.right;              <span class="comment">// 原节点的左子树变为左子节点的右子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;             <span class="comment">// 如果新的左子树不为空</span></span><br><span class="line">        node.left.parent = node;         <span class="comment">// 设置新左子树的父节点为原节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp.right = node;                   <span class="comment">// 原节点成为左子节点的右子树</span></span><br><span class="line">    node.parent = temp;                  <span class="comment">// 原节点的父节点设为左子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;           <span class="comment">// 如果新根没有父节点</span></span><br><span class="line">        root = temp;                     <span class="comment">// 设为整棵树的根</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 否则需要连接到原来的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123; <span class="comment">// 如果原节点是左子节点</span></span><br><span class="line">            temp.parent.left = temp;     <span class="comment">// 父节点的左指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">// 如果原节点是右子节点</span></span><br><span class="line">            temp.parent.right = temp;    <span class="comment">// 父节点的右指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;                         <span class="comment">// 返回新的子树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="左旋-右旋-右旋-左旋"><a href="#左旋-右旋-右旋-左旋" class="headerlink" title="左旋 + 右旋&#x2F;右旋 + 左旋"></a>左旋 + 右旋&#x2F;右旋 + 左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (factor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node.left);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.left = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (factor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node.right);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.right = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>AVL 树平衡因子怎么计算？</strong></li>
</ul>
<p>​	AVL树平衡因子 &#x3D; 左子树高度 - 右子树高度，取值范围[-1,0,1]，超出范围需旋转调整。</p>
<ul>
<li><strong>AVL 树左旋操作的目的是什么？</strong></li>
</ul>
<p>​	将右偏重的子树通过左旋转换为平衡状态，消除右子树过高导致的不平衡。</p>
<ul>
<li><strong>AVL 树左旋操作的流程是什么？</strong></li>
</ul>
<p>​	将右子节点提升为新根，原根节点下沉为新根的左子节点，原右子节点的左子树转移给原根节点作为右子树，最后重新连接所有父子关	系。</p>
<ul>
<li><strong>AVL 树什么情况下要左旋+右旋？</strong></li>
</ul>
<p>​	当左子树的右子树过高导致左-右型不平衡时，先对左子节点左旋，再对根节点右旋。</p>
<ul>
<li><strong>AVL 树的插入和读取的时间复杂度？</strong></li>
</ul>
<p>​	插入和查找都是O(log n)，因为AVL树通过自平衡保证树高度始终为O(log n)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cmdocxzdt000qi8qq852scy11" data-title="平衡二叉树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二分搜索树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T08:42:25.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">二分搜索树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="二叉搜索树的数据结构"><a href="#二叉搜索树的数据结构" class="headerlink" title="二叉搜索树的数据结构"></a>二叉搜索树的数据结构</h4><p>二叉搜索树（Binary Search Tree），也称二叉查找树。如果你看见有序二叉树（Ordered Binary tree）、排序二叉树（Sorted Binary Tree）那么说的都是一个东西。</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>二叉搜索树也是一颗没有经过调衡的基础性数据结构，在一定概率上它完成有可能退化成链表，也就是从近似O(logn)的时间复杂度退化到O(n)。关于二叉搜索树的平衡解决方案，包括；AVL树、2-3树、红黑树等。</p>
<hr>
<h4 id="二叉搜索树结构实现"><a href="#二叉搜索树结构实现" class="headerlink" title="二叉搜索树结构实现"></a>二叉搜索树结构实现</h4><p>二叉搜索树是整个树结构中最基本的树，同时也是树这个体系中实现起来最容易的数据结构。但之所以要使用基于二叉搜索树之上的其他树结构，主要是因为使用数据结构就是对数据的存放和读取。那么为了提高吞吐效率，则需要尽可能的平衡元素的排序，体现在树上则需要进行一些列操作，所以会有不同的结构树实现。</p>
<ul>
<li><em><strong>树枝定义</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer value;</span><br><span class="line"><span class="keyword">public</span> Node parent;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于组成一颗树的节点，则需要包括；值和与之关联的三角结构，一个父节点、两个孩子节点。如果是AVL树还需要树高，红黑树还需要染色标记。</li>
</ul>
<ul>
<li><em><strong>插入节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引出待插入元素位置，也就是插入到哪个父元素下</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">search</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (search != <span class="literal">null</span> &amp;&amp; search.value != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = search;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; search.value) &#123;</span><br><span class="line">            search = search.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            search = search.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (parent.value &gt; newNode.value) &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断插入元素时候是否有树根，没有则会把当前节点创建出一颗树根来。</li>
<li>如果当前树是有树根的，则对插入元素与当前树进行一个节点遍历操作，找到元素可以插入的索引位置 parent（挂到这个父节点下）。也就是 search 搜索过程。</li>
<li>最后就是插入元素，通过给插入值创建一个 Node 节点，并绑定它的父元素，以及把新元素挂到索引到的 parent 节点下。</li>
</ul>
<ul>
<li><em><strong>索引节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.value != <span class="literal">null</span> &amp;&amp; node.value != e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; node.value) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值查找的过程，就是对二叉搜索树的遍历，不断的循环节点，按照节点值的左右匹配，找出最终相当的值节点。</li>
</ul>
<ul>
<li><em><strong>删除节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">delNode</span> <span class="operator">=</span> search(e);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == delNode) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> delete(delNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node delNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (delNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为删除的节点，有2个孩子节点，这个时候找到这条分支下，最左侧做小的节点。用它来替换删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">miniNode</span> <span class="operator">=</span> getMiniNode(delNode.right);</span><br><span class="line">        <span class="keyword">if</span> (miniNode.parent != delNode) &#123;</span><br><span class="line">            <span class="comment">// 交换位置，用miniNode右节点，替换miniNode</span></span><br><span class="line">            transplant(miniNode, miniNode.right);</span><br><span class="line">            <span class="comment">// 把miniNode 提升父节点，设置右子树并进行挂链。替代待删节点</span></span><br><span class="line">            miniNode.right = delNode.right;</span><br><span class="line">            miniNode.right.parent = miniNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置，删除节点和miniNode 可打印测试观察；System.out.println(this);</span></span><br><span class="line">        transplant(delNode, miniNode);</span><br><span class="line">        <span class="comment">// 把miniNode 提升到父节点，设置左子树并挂链</span></span><br><span class="line">        miniNode.left = delNode.left;</span><br><span class="line">        miniNode.left.parent = miniNode;</span><br><span class="line">        result = miniNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">transplant</span><span class="params">(Node delNode, Node addNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除元素是左/右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delNode.parent.left == delNode) &#123;</span><br><span class="line">        delNode.parent.left = addNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delNode.parent.right = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addNode) &#123;</span><br><span class="line">        addNode.parent = delNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有右子树</strong></p>
<ul>
<li>直接用右子树替换删除节点</li>
</ul>
<p><strong>只有左子树</strong></p>
<ul>
<li>直接用左子树替换删除节点</li>
</ul>
<p><strong>有两个子树</strong></p>
<ul>
<li>找到右子树中的最小节点（后继节点）</li>
<li>用后继节点替换删除节点</li>
<li>处理后继节点的原位置</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li>
</ul>
<p>​	基本性质：左子树 &lt; 根节点 &lt; 右子树，中序遍历有序，平均O(log n)操作复杂度。</p>
<p>​	核心操作：查找（比较递归）、插入（找位置插入）、删除（三种情况：0&#x2F;1&#x2F;2个子节点）。</p>
<p>​	主要变体：AVL树（自平衡）、红黑树（着色平衡）、B树（多路）、线索二叉树（利用空指针）。核心目标都是避免退化成链表，保持O(log n)性能。</p>
<ul>
<li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li>
</ul>
<p>​	平均情况：插入、删除、查找都是 O(log n)。最坏情况：当树退化成链表时（如顺序插入），所有操作变成 O(n)。关键：平衡二叉树通过自平衡保证最坏情况也是 O(log n)。</p>
<ul>
<li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li>
</ul>
<p>​	核心思路 ：找到右子树中的最小节点（后继节点）来替换被删除节点。</p>
<p>​	具体步骤：1）找到右子树最左侧的最小节点；2）如果最小节点不是右子树根，先将其右子树移植到原位置；3）用最小节点替换被删除节点，重新连接左右子树和父节点关系。</p>
<p>​	原理：右子树最小节点值刚好大于左子树所有值且小于右子树其余值，替换后仍保持BST性质。</p>
<ul>
<li><strong>二叉搜索树的节点都包括了哪些信息</strong></li>
</ul>
<p>​	基本信息：节点值（key&#x2F;data）、左子节点指针、右子节点指针。可选信息：父节点指针（便于向上遍历和删除操作）。扩展信息：节点颜色（红黑树）、平衡因子（AVL树）、子树大小等附加属性。</p>
<p>​	核心结构：<code>&#123;value, left, right, parent&#125;</code>，其中parent可选但常用。</p>
<ul>
<li><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></li>
</ul>
<p>​	核心问题：普通二叉搜索树在最坏情况下会退化成链表，时间复杂度从O(log n)恶化到O(n)。<strong>红黑树优势</strong>：通过着色和旋转机制保证树的近似平衡，确保最坏情况下仍是O(log n)。<strong>HashMap场景</strong>：哈希冲突时链表过长影响性能，红黑树能稳定保证查找效率，避免恶意构造数据导致性能攻击。</p>
<p>​	简单说：红黑树是自平衡的BST，防止极端情况下性能退化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" data-id="cmdocxzdl0004i8qqageneb1w" data-title="二分搜索树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字典树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T03:05:39.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/">字典树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="字典树数据结构"><a href="#字典树数据结构" class="headerlink" title="字典树数据结构"></a>字典树数据结构</h4><p>在计算机科学中，字典树(Trie)也被称为”单词查找树“或”数字树“，有时候也被称为基数树或前缀树（因为可以通过前缀的方式进行索引）。—— 它是一种搜索树，一种已排序的数据结构，通常用于存储动态集或键为字符串的关联数组。</p>
<p>与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<hr>
<h4 id="字典树结构实现"><a href="#字典树结构实现" class="headerlink" title="字典树结构实现"></a>字典树结构实现</h4><p>字典树字母的存放有26个，也就是说在实现的过程中，每一个节点的分支都有26个槽位用来存放可能出现的字母组合。同理如果是数字树的话就是10个数字的组合，每个字典树上的节点对应的分支则有10个操作存放可能出现组合的数字。</p>
<ul>
<li><em><strong>树枝节点</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 形成一个链 */</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] slot = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字母 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：数量 &gt; 0 表示一个单词 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前缀 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：具体的一个单词字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String word;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解释：单词的注释说明 */</span></span><br><span class="line">    <span class="keyword">public</span> String explain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字典的树的节点需要包括此节点内嵌的关联节点，之后是节点的字母、到此字母是否为单词、单词的前缀、单词字符串和当前单词的非必要注释。</li>
</ul>
<ul>
<li><em><strong>插入元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String words, String explain)</span> &#123; <span class="comment">// 插入单词及其解释到字典树</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = words.toCharArray(); <span class="comment">// 将单词转为字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算字符在 slot 数组中的下标（假设都是小写字母）</span></span><br><span class="line">        <span class="keyword">if</span> (root.slot[idx] == <span class="literal">null</span>) &#123; <span class="comment">// 如果对应子节点不存在</span></span><br><span class="line">            root.slot[idx] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>(); <span class="comment">// 创建新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        root.c = c; <span class="comment">// 记录当前字符</span></span><br><span class="line">        root.prefix++; <span class="comment">// 前缀计数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    root.explain = explain; <span class="comment">// 存储单词的解释说明</span></span><br><span class="line">    root.isWord = <span class="literal">true</span>;     <span class="comment">// 标记该节点为单词结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png" alt="插入元素"></p>
<ul>
<li>insert 方法接收单词和注释信息，并对一个单词按照 char 进行拆分，拆分后则计算出索引位置并以此存放。存放完成后标记单词和附属上单词的注释信息。</li>
</ul>
<ul>
<li><em><strong>索引元素</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123; <span class="comment">// 查找所有以 prefix 为前缀的单词</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">char</span>[] chars = prefix.toCharArray(); <span class="comment">// 将前缀转为字符数组</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 用于缓存已匹配的前缀</span></span><br><span class="line">    <span class="comment">// 精准匹配：根据前缀逐步查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123; <span class="comment">// 遍历前缀的每个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 计算下标</span></span><br><span class="line">        <span class="comment">// 匹配为空，前缀不存在</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; root.slot.length || idx &lt; <span class="number">0</span> || root.slot[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// 没有匹配，返回空列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        cache.append(c); <span class="comment">// 缓存当前字符</span></span><br><span class="line">        root = root.slot[idx]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模糊匹配：递归查找所有以 prefix 开头的单词</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">if</span> (root.prefix != <span class="number">0</span>) &#123; <span class="comment">// 如果有以该前缀开头的单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.slot.length; i++) &#123; <span class="comment">// 遍历所有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 计算字符</span></span><br><span class="line">                collect(root.slot[i], String.valueOf(cache) + c, list, <span class="number">15</span>); <span class="comment">// 递归收集单词，最多15个</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt;= <span class="number">15</span>) &#123; <span class="comment">// 达到上限提前返回</span></span><br><span class="line">                    <span class="keyword">return</span> list;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(TrieNode trieNode, String pre, List&lt;String&gt; queue, <span class="type">int</span> resultLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到单词</span></span><br><span class="line">    <span class="keyword">if</span> (trieNode.isWord) &#123; <span class="comment">// 当前节点是单词结尾</span></span><br><span class="line">        trieNode.word = pre; <span class="comment">// 记录完整单词</span></span><br><span class="line">        <span class="comment">// 保存检索到的单词和解释到 queue</span></span><br><span class="line">        queue.add(trieNode.word + <span class="string">&quot; -&gt; &quot;</span> + trieNode.explain);</span><br><span class="line">        <span class="keyword">if</span> (queue.size() &gt;= resultLimit) &#123; <span class="comment">// 达到结果上限</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用，查找所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trieNode.slot.length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i); <span class="comment">// 计算字符</span></span><br><span class="line">        <span class="keyword">if</span> (trieNode.slot[i] != <span class="literal">null</span>) &#123; <span class="comment">// 子节点不为空</span></span><br><span class="line">            collect(trieNode.slot[i], pre + c, queue, resultLimit); <span class="comment">// 递归收集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E7%B4%A2%E5%BC%95.png" alt="索引"></p>
<ul>
<li>从字典树从检索元素的过程分为2部分，第1部分是根据提供的索引前缀精准匹配到单词信息，第2部分是根据索引前缀的最后一个单词开始，循环递归遍历从当前位置所能关联到的字母直至判断为是单词标记为结束，通过这样的方式把所有匹配动的单词索引出来。</li>
<li>list.size() &gt;&#x3D; 15 是判定索引的最大长度，超过这个数量就停止索引了，毕竟这是一种O(n)时间复杂度的操作，如果加载数十万单词进行匹配，执行速度还是比较耗时的。</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>简述字典树的数据结构</strong></li>
</ul>
<p>​	本质： 树形结构存储字符串，共享公共前缀</p>
<p>​	结构：</p>
<ul>
<li>节点存储字符</li>
<li>路径 &#x3D; 字符串</li>
<li>标记单词结尾</li>
</ul>
<p>​	复杂度： O(字符串长度)</p>
<p>​	用途： 自动补全、前缀匹配、拼写检查</p>
<p>​	优势： 前缀查询快，节省空间</p>
<ul>
<li><strong>叙述你怎么来实现一个字典树</strong></li>
</ul>
<p>​	子节点数组（26个字母）</p>
<p>​	布尔标记（是否单词结尾）</p>
<p>​	插入： 逐字符遍历，不存在就创建节点，最后标记结尾</p>
<p>​	查找：*逐字符遍历，检查路径是否存在且标记为单词</p>
<p>​	前缀查询： 遍历到前缀末尾即可</p>
<p>​	关键点： 字符映射到数组索引，路径即字符串</p>
<ul>
<li><strong>字典树的实际业务场景举例【排序、全文搜索、网络搜索引擎、生物信息】</strong></li>
</ul>
<p>​	字符串字典序排序\关键词索引构建\查询补全\DNA序列匹配</p>
<p>​	<strong>核心优势：</strong> 前缀匹配效率高，特别适合大规模字符串集合的快速检索场景。</p>
<ul>
<li><strong>字典树的存入和检索的时间复杂度</strong></li>
</ul>
<p>​	存入（Insert）：O(m)</p>
<p>​	检索（Search）：O(m)</p>
<p>​	前缀查找：O(p)</p>
<p>​	其中 m 是字符串长度，p 是前缀长度(字典树是典型的<strong>空间换时间</strong>的数据结构，特别适合字符串查找和前缀匹配场景。)</p>
<ul>
<li><strong>还有哪些字典树的实现方式</strong></li>
</ul>
<ol>
<li><p>数组实现</p>
<p>固定大小数组存储子节点</p>
<ul>
<li>优点：O(1)访问速度</li>
<li>缺点：空间浪费</li>
</ul>
</li>
<li><p>哈希表实现</p>
<p>HashMap存储子节点</p>
<ul>
<li>优点：空间高效，支持任意字符集</li>
<li>缺点：哈希冲突影响性能</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%AD%97%E5%85%B8%E6%A0%91/" data-id="cmdocxzdr000ji8qq89nc9kta" data-title="字典树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/25/%E5%A0%86/" class="article-date">
  <time class="dt-published" datetime="2025-07-25T01:44:53.000Z" itemprop="datePublished">2025-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/25/%E5%A0%86/">堆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h4><p>在计算机科学中，<strong>堆(heap)</strong> 的实现是一种基于树的特殊的数据结构，它可以在数组上构建出树的结构体，并满足堆的属性；</p>
<ul>
<li><p>最小堆：如果<code>P</code> 是 <code>C</code> 的一个父级节点， 那么 <code>P</code> 的key(或value)应小于或等于 <code>C</code> 的对应值。</p>
</li>
<li><p>最大堆：与最小堆的定义正好相反，最大堆(max heap) , <code>P</code> 的key(或value)大于 <code>C</code> 的对应值。</p>
</li>
</ul>
<hr>
<h4 id="堆的代码实现"><a href="#堆的代码实现" class="headerlink" title="堆的代码实现"></a>堆的代码实现</h4><ul>
<li><em><strong>实现介绍</strong></em></li>
</ul>
<p>堆的实现在 Java API 中主要体现在延迟队列的实现二叉堆上，这里小傅哥单独把这部分代码拆分出来，了解下关于小堆和大堆的实现。</p>
<p>从对堆的数据结构介绍上可以看到，小堆和大堆的唯一区别仅是对元素的排序方式不同。所以也就是说在存放和获取元素的时候对元素的填充和摘除时，排序方式不同而已。</p>
<ul>
<li><em><strong>入堆实现</strong></em></li>
</ul>
<p>堆的在存放元素时，以遵循它的特点，会在存放过程中，通过队尾元素向上比对迁移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】元素：&#123;&#125; 当前队列：&#123;&#125;&quot;</span>, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点Idx，相当于除以2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        logger.info(<span class="string">&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;</span>, k, parent);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="comment">// 如果当前位置元素，大于父节点元素，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;</span>, JSON.toJSONString(e), JSON.toJSONString(x));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相反父节点位置大于当前位置元素，则进行替换</span></span><br><span class="line">        logger.info(<span class="string">&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;</span>, JSON.toJSONString(e), k);</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \r\n当前队列：&#123;&#125; \r\n&quot;</span>, k, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>入堆的实现 add 方法最终会调用到 siftUpComparable 方法，进行排序的方式进行处理。而这个排序 compareTo 方法是由具体的 MinHeap、MaxHeap 来做实现。</li>
<li>以入堆元素2举例，如图所示入堆过程。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%85%A5%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="入堆实现"></p>
<ul>
<li>首先将元素2挂到队列尾部，之后通过 (k - 1) &gt;&gt;&gt; 1 计算父节点位置，与对应元素进行比对和判断交换。</li>
<li>交换过程包括 2-&gt;6、2-&gt;5，以此交换结束后元素保存完毕。</li>
</ul>
<ul>
<li><em><strong>出堆实现</strong></em></li>
</ul>
<p>元素的出堆其实很简单，只要把根元素直接删除弹出即可。但剩余接下里的步骤才是复杂的，因为需要在根元素迁移走后，寻找另外的最小元素迁移到对头。这个过程与入堆正好相反，这是一个不断向下迁移的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="comment">// 先找出中间件节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 找到左子节点和右子节点，两个节点进行比较，找出最大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子节点与右子节点比较，取最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; compareTo((E) c, (E) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;</span>, JSON.toJSONString(c), JSON.toJSONString(queue[right]));</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) c) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值小于c值，位置替换，继续比较</span></span><br><span class="line">        logger.info(<span class="string">&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;</span>, JSON.toJSONString(queue[k]), JSON.toJSONString(c));</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把目标值放到对应位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;</span>, k, JSON.toJSONString(x));</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不断地向下迁移元素。这个过程会比对左右子节点的值，找到最小的。所以整个过程会比入堆麻烦一些。</li>
</ul>
<p><img src="https://pub-678b3ade17f8432b8ca7d50cff1ea054.r2.dev/%E5%87%BA%E5%A0%86%E5%AE%9E%E7%8E%B0.png" alt="出堆实现"></p>
<p>这里以弹出元素1举例，之后将堆尾元素替换到相应的位置。整个过程分为6张图表述。</p>
<ol>
<li>图1到图2，找出根元素弹出。</li>
<li>图3到图4，将根元素向下迁移，与子元素比对，并替换位置。如果这个位置与8相比，小于8则继续向下迁移。</li>
<li>图4到图5，继续迁移，在原节点4的位置对应的两个子元素，都比8大，这个时候就可以停下来了。</li>
<li>图5到图6，更换元素位置，把队尾的元素替换到对应元素1向下迁移检测的位置。</li>
</ol>
<ul>
<li><em><strong>最小堆（MinHeap）和最大堆（MaxHeap）</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstElement.compareTo(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> secondElement.compareTo(firstElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用：实现最小堆。</p>
<ul>
<li><p>原理：compareTo 返回 firstElement.compareTo(secondElement)，即：</p>
</li>
<li><p>如果 firstElement &lt; secondElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最小的元素。</p>
</li>
</ul>
</li>
<li><p>作用：实现最大堆。</p>
<ul>
<li><p>原理：compareTo 返回 secondElement.compareTo(firstElement)，即：</p>
</li>
<li><p>如果 secondElement &lt; firstElement，返回负数，表示 firstElement 应排在前面。</p>
</li>
<li><p>这样堆顶总是最大的元素。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ul>
<li><strong>堆的数据结构是什么样？</strong></li>
</ul>
<p>​	堆是一种完全二叉树结构，通常用数组实现。</p>
<ul>
<li><p>最大堆：每个节点的值都大于等于其子节点（堆顶是最大值）。</p>
</li>
<li><p>最小堆：每个节点的值都小于等于其子节点（堆顶是最小值）。</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li><p>父子节点通过数组下标可以快速定位（如父节点下标为 i，左子为 2i+1，右子为 2i+2）。</p>
</li>
<li><p>结构紧凑，没有“空洞”。</p>
</li>
<li><p><strong>堆的数据结构使用场景？</strong></p>
</li>
</ul>
<p>​	堆常用于优先队列（如任务调度）、排序算法（堆排序）、动态获取最大&#x2F;最小值（如实时统计Top K）、图算法（如Dijkstra最短路径）等需要频繁取最大&#x2F;最小元素的场景。</p>
<ul>
<li><strong>堆的数据结构实现方式有哪些？</strong></li>
</ul>
<ol>
<li>数组实现（最常用）</li>
</ol>
<p>​		利用完全二叉树的性质，父子节点通过下标计算关联，结构紧凑，效率高。</p>
<ol start="2">
<li>链式二叉树实现</li>
</ol>
<p>​		用指针（引用）连接父子节点，结构灵活，但空间利用率和访问效率不如数组。</p>
<ol start="3">
<li>多路堆（如d叉堆）</li>
</ol>
<p>​		可以用数组或链表实现，每个节点有 d 个子节点，适合特殊场景（如堆优化的优先队列）。</p>
<ul>
<li><strong>最小堆和最大堆的区别是什么？</strong></li>
</ul>
<p>​	最小堆和最大堆的区别在于堆顶元素的大小关系：</p>
<ul>
<li><p>最小堆：每个节点的值都小于等于其子节点，堆顶是最小值。</p>
</li>
<li><p>最大堆：每个节点的值都大于等于其子节点，堆顶是最大值。</p>
</li>
</ul>
<p>用途不同：</p>
<ul>
<li><p>最小堆适合快速获取最小元素。</p>
</li>
<li><p>最大堆适合快速获取最大元素。</p>
</li>
<li><p><strong>有了解斐波那契堆吗？</strong></p>
</li>
</ul>
<p>​	斐波那契堆（Fibonacci Heap）是一种<strong>高级堆数据</strong>结构，支持更快的合并（合并两个堆）、插入和减少键值等操作，适用于<strong>需要大量合并和减少最小值操作</strong>的场景（如Dijkstra最短路径算法）。它的结构比普通二叉堆复杂，操作的<strong>摊还时间复杂度更低</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/25/%E5%A0%86/" data-id="cmdocxzdo000bi8qqagvicg73" data-title="堆" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-哈希表-散列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T07:48:47.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/">哈希表(散列)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="哈希数据结构"><a href="#哈希数据结构" class="headerlink" title="哈希数据结构"></a>哈希数据结构</h4><p>哈希表的存在是为了解决能通过O(1)时间复杂度直接索引到指定元素。</p>
<p>HashMap 中的拉链寻址 + 红黑树、扰动函数、负载因子、合并散列、杜鹃散列、跳房子哈希、罗宾汉哈希等各类数据结构设计。让元素在发生哈希冲突时，也可以存放到新的槽位，并尽可能保证索引的时间复杂度小于O(n)</p>
<hr>
<h4 id="实现哈希散列"><a href="#实现哈希散列" class="headerlink" title="实现哈希散列"></a>实现哈希散列</h4><p>哈希散列是一个非常常见的数据结构，无论是我们使用的 HashMap、ThreaLocal 还是你在刷题中位了提升索引效率，都会用到哈希散列。</p>
<p>只要哈希桶的长度由负载因子控制的合理，每次查找元素的平均时间复杂度与桶中存储的元素数量无关。另外许多哈希表设计还允许对键值对的任意插入和删除，每次操作的摊销固定平均成本。</p>
<ul>
<li><em><strong>哈希碰撞</strong></em></li>
</ul>
<p><strong>说明</strong>：通过模拟简单 HashMap 实现，去掉拉链寻址等设计，验证元素哈希索引位置碰撞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap01</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] tab = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        tab[idx] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (V) tab[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap01 的实现只是通过哈希计算出的下标，散列存放到固定的数组内。那么这样当发生元素下标碰撞时，原有的元素就会被新的元素替换掉。</li>
</ul>
<ul>
<li><em><strong>拉链寻址</strong></em></li>
</ul>
<p><strong>说明</strong>：既然我们没法控制元素不碰撞，但我们可以对碰撞后的元素进行管理。比如像 HashMap 中拉链法一样，把碰撞的元素存放到链表上。这里我们就来简化实现一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap02BySeparateChaining</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Node&lt;K, V&gt;&gt;[] tab = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果该位置还没有链表，就新建一个链表并添加节点。</span></span><br><span class="line"><span class="comment">			如果已经有链表，直接把新节点加到链表末尾。</span></span><br><span class="line"><span class="comment">			注意：这里没有去重（同一个 key 会重复插入）。*/</span></span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*计算 key 的哈希值，找到对应链表。</span></span><br><span class="line"><span class="comment">		遍历链表，找到 key 相等的节点，返回其 value。</span></span><br><span class="line"><span class="comment">		如果没找到，返回 null。*/</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt; kvNode : tab[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(kvNode.getKey())) &#123;</span><br><span class="line">                <span class="keyword">return</span> kvNode.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为元素在存放到哈希桶上时，可能发生下标索引膨胀，所以这里我们把每一个元素都设定成一个 Node 节点，这些节点通过 LinkedList 链表关联，当然你也可以通过 Node 节点构建出链表 next 元素即可。</li>
<li>那么这时候在发生元素碰撞，相同位置的元素就都被存放到链表上了，获取的时候需要对存放多个元素的链表进行遍历获取。</li>
</ul>
<ul>
<li><em><strong>开放寻址</strong></em></li>
</ul>
<p><strong>说明</strong>：除了对哈希桶上碰撞的索引元素进行拉链存放，还有不引入新的额外的数据结构，只是在哈希桶上存放碰撞元素的方式。它叫开放寻址，也就是 ThreaLocal 中运用斐波那契散列+开放寻址的处理方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap03ByOpenAddressing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果该位置已被占用（哈希冲突），则向后线性探查，找到下一个空位插入。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tab[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i ++)&#123;</span><br><span class="line">            <span class="comment">//从 idx 开始向后线性查找，遇到 key 相等的节点就返回 value。</span></span><br><span class="line">            <span class="keyword">if</span> (tab[idx] != <span class="literal">null</span> &amp;&amp; tab[idx].key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>开放寻址的设计会对碰撞的元素，寻找哈希桶上新的位置，这个位置从当前碰撞位置开始向后寻找，直到找到空的位置存放。</li>
<li>在 ThreadLocal 的实现中会使用斐波那契散列、索引计算累加、启发式清理、探测式清理等操作，以保证尽可能少的碰撞。</li>
</ul>
<ul>
<li><em><strong>合并散列</strong></em></li>
</ul>
<p><strong>说明</strong>：合并散列是开放寻址和单独链接的混合，碰撞的节点在哈希表中链接。此算法适合固定分配内存的哈希桶，通过存放元素时识别哈希桶上的最大空槽位来解决合并哈希中的冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap04ByCoalescedHashing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//从数组末尾向前找一个空位（cursor），插入新节点。</span></span><br><span class="line">		<span class="comment">//然后在原冲突链的末尾，将idxOfNext指向新节点的下标（cursor），形成“链”。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> tab.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tab[cursor] != <span class="literal">null</span> &amp;&amp; tab[cursor].key != key) &#123;</span><br><span class="line">            --cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        tab[cursor] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将碰撞节点指向这个新节点</span></span><br><span class="line">        <span class="keyword">while</span> (tab[idx].idxOfNext != <span class="number">0</span>)&#123;</span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[idx].idxOfNext = cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (tab[idx].key != key) &#123;</span><br><span class="line">            <span class="comment">//如果不是目标 key，就顺着idxOfNext跳到下一个节点，直到找到 key 相等的节点。</span></span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="type">int</span> idxOfNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>合并散列的最大目的在于将碰撞元素链接起来，避免因为需要寻找碰撞元素所发生的循环遍历。也就是A、B元素存放时发生碰撞，那么在找到A元素的时候可以很快的索引到B元素所在的位置。</p>
</li>
<li><p>相对于直接使用开放寻址，这样的挂在链路指向的方式，可以提升索引的性能。因为在实际的数据存储上，元素的下一个位置不一定空元素，可能已经被其他元素占据，这样就增加了索引的次数。所以使用直接指向地址的方式，会更好的提高索引性能。</p>
</li>
</ul>
<ul>
<li><em><strong>杜鹃散列</strong></em></li>
</ul>
<p><strong>说明</strong>：这个名字起的比较有意思，也代表着它的数据结构。杜鹃鸟在孵化🐣的时候，雏鸟会将其他蛋或幼崽推出巢穴；类似的这个数据结构会使用2组key哈希表，将冲突元素推到另外一个key哈希表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> isRehash)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">k</span> <span class="operator">=</span> maskNull(key);</span><br><span class="line">    <span class="keyword">if</span> (containsKey(k)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (insertEntry(<span class="keyword">new</span> <span class="title class_">Entry</span>&lt;K, V&gt;((K) k, value))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRehash) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rehash(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="keyword">return</span> put((K) k, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">insertEntry</span><span class="params">(Entry&lt;K, V&gt; e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Entry&lt;K, V&gt; current = e;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(hash1, current.key);</span><br><span class="line">    <span class="keyword">while</span> (current != e || count &lt; table.length) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; temp = table[index];</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">            table[index] = current;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = current;</span><br><span class="line">        current = temp;</span><br><span class="line">        <span class="keyword">if</span> (index == hash(hash1, current.key)) &#123;</span><br><span class="line">            index = hash(hash2, current.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = hash(hash1, current.key);</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当多个键映射到同一个单元格时会发生这种情况。杜鹃散列的基本思想是通过使用两个散列函数而不是仅一个散列函数来解决冲突。</li>
<li>这为每个键在哈希表中提供了两个可能的位置。在该算法的一种常用变体中，哈希表被分成两个大小相等的较小的表，每个哈希函数都为这两个表之一提供索引。两个散列函数也可以为单个表提供索引。</li>
<li>在实践中，杜鹃哈希比线性探测慢约 20-30%，线性探测是常用方法中最快的。然而，由于它对搜索时间的最坏情况保证，当需要实时响应率时，杜鹃散列仍然很有价值。杜鹃散列的一个优点是它的无链接列表属性，非常适合 GPU 处理。</li>
</ul>
<ul>
<li><em><strong>跳房子散列</strong></em></li>
</ul>
<p><strong>说明</strong>：跳房子散列是一种基于开放寻址的算法，它结合了杜鹃散列、线性探测和链接的元素，通过桶邻域的概念——任何给定占用桶周围的后续桶，也称为“虚拟”桶。 该算法旨在在哈希表的负载因子增长超过 90% 时提供更好的性能；它还在并发设置中提供了高吞吐量，因此非常适合实现可调整大小的并发哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(AnyType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentPos</span> <span class="operator">=</span> findPos(x);</span><br><span class="line">    <span class="keyword">if</span> (currentPos == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (array[currentPos] != <span class="literal">null</span>) &#123;</span><br><span class="line">        x = array[currentPos].element;</span><br><span class="line">        array[currentPos].isActive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String hope;</span><br><span class="line">    <span class="keyword">if</span> (array[currentPos] != <span class="literal">null</span>) &#123;</span><br><span class="line">        hope = array[currentPos].hope;</span><br><span class="line">        x = array[currentPos].element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hope = <span class="string">&quot;10000000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[currentPos] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;&gt;(x, hope, <span class="literal">true</span>);</span><br><span class="line">    theSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该算法使用一个包含n 个桶的数组。对于每个桶，它的邻域是H个连续桶的小集合（即索引接近原始散列桶的那些）。邻域的期望属性是在邻域的桶中找到一个项目的成本接近于在桶本身中找到它的成本（例如，通过使邻域中的桶落在同一缓存行中）。在最坏的情况下，邻域的大小必须足以容纳对数个项目（即它必须容纳 log( n ) 个项目），但平均只能是一个常数。如果某个桶的邻域被填满，则调整表的大小。</li>
</ul>
<ul>
<li><em><strong>罗宾汉哈希</strong></em></li>
</ul>
<p><strong>说明</strong>：罗宾汉哈希是一种基于开放寻址的冲突解决算法；冲突是通过偏向从其“原始位置”（即项目被散列到的存储桶）最远或最长探测序列长度（PSL）的元素的位移来解决的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 元素碰撞检测</span></span><br><span class="line">    <span class="keyword">while</span> (table[idx] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset &gt; table[idx].offset) &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量不止一个，则查看条目交换位置，entry 是正在查看的条目，增加现在搜索的事物的偏移量和 idx</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">garbage</span> <span class="operator">=</span> table[idx];</span><br><span class="line">            table[idx] = entry;</span><br><span class="line">            entry = garbage;</span><br><span class="line">            idx = increment(idx);</span><br><span class="line">            entry.offset++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset == table[idx].offset) &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量与正在查看的检查键是否相同，如果是则它们交换值，如果不是，则增加 idx 和偏移量并继续</span></span><br><span class="line">            <span class="keyword">if</span> (table[idx].key.equals(key)) &#123;</span><br><span class="line">                <span class="comment">// 发现相同值</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> table[idx].value;</span><br><span class="line">                table[idx].value = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idx = increment(idx);</span><br><span class="line">                entry.offset++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前偏移量小于我们正在查看的我们增加 idx 和偏移量并继续</span></span><br><span class="line">            idx = increment(idx);</span><br><span class="line">            entry.offset++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经到达了 null 所在的 idx，将新/移动的放在这里</span></span><br><span class="line">    table[idx] = entry;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 超过负载因子扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= loadFactor * table.length) &#123;</span><br><span class="line">        rehash(table.length * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>09、12 和 01 发生哈希索引碰撞，进行偏移量计算调整。通过最长位置探测碰撞元素位移来处理。</p>
</li>
<li><p>通过测试结果和调试的时候可以看到，哈希索引冲突是通过偏向从其“原始位置”（即项目被散列到的存储桶）最远或最长<em>探测序列长度（PSL）的元素的位移来解决</em>。这块可以添加断点调试验证。</p>
</li>
</ul>
<hr>
<h4 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h4><ul>
<li><strong>介绍一下散列表</strong></li>
</ul>
<p>​	散列表（Hash Table）是一种基于键值对存储的数据结构。它通过哈希函数将键（key）映射到数组的某个位置（桶或槽），以实现高 效的插入、查找和删除操作，平均时间复杂度为 O(1)。</p>
<ul>
<li><strong>为什么使用散列表</strong></li>
</ul>
<p>​	使用散列表的主要原因是查找、插入和删除操作非常高效，平均时间复杂度为 O(1)，远快于数组、链表等结构。</p>
<ul>
<li><strong>拉链寻址和开放寻址的区别</strong></li>
</ul>
<p>​	拉链法用链表解决冲突，元素可分散在链表中；开放寻址所有元素都在数组内，通过探查空位解决冲突。</p>
<ul>
<li><strong>还有其他什么方式可以解决散列哈希索引冲突</strong></li>
</ul>
<p>​	再哈希法:冲突时，使用另一个哈希函数计算新的位置，减少聚集。</p>
<p>​	合链哈希:结合拉链法和开放寻址，将链表节点也放在哈希表数组中。</p>
<p>​	罗宾汉哈希\跳房子散列\杜鹃散列</p>
<ul>
<li><strong>对应的Java源码中，对于哈希索引冲突提供了什么样的解决方案</strong></li>
</ul>
<p>​	Java标准库的哈希表（如 HashMap、Hashtable、ConcurrentHashMap）主要采用拉链法（链表或红黑树）来解决哈希冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/24/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97/" data-id="cmdocxzdm0006i8qqd4wfhonf" data-title="哈希表(散列)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" rel="tag">创建文章</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E7%82%B9/" rel="tag">重点</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/" style="font-size: 10px;">创建文章</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">工具学习</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E9%87%8D%E7%82%B9/" style="font-size: 15px;">重点</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%9B%BE/">图</a>
          </li>
        
          <li>
            <a href="/2025/07/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>
          </li>
        
          <li>
            <a href="/2025/07/28/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>
          </li>
        
          <li>
            <a href="/2025/07/28/2-3%E6%A0%91/">2-3树</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>